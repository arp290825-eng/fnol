"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/services/openai.ts":
/*!********************************!*\
  !*** ./lib/services/openai.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenAIService: function() { return /* binding */ OpenAIService; },\n/* harmony export */   openaiService: function() { return /* binding */ openaiService; }\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai */ \"(app-pages-browser)/./node_modules/openai/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Initialize OpenAI client\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n    apiKey: process.env.OPENAI_API_KEY || \"\",\n    dangerouslyAllowBrowser: true // For demo purposes - in production, use server-side API routes\n});\nclass OpenAIService {\n    async callLLM(prompt, systemPrompt, functions) {\n        try {\n            var _choice_message, _choice_message1;\n            const messages = [];\n            if (systemPrompt) {\n                messages.push({\n                    role: \"system\",\n                    content: systemPrompt\n                });\n            }\n            messages.push({\n                role: \"user\",\n                content: prompt\n            });\n            const requestConfig = {\n                model: this.model,\n                messages,\n                temperature: this.temperature,\n                max_tokens: 2000\n            };\n            // Add function calling if functions are provided\n            if (functions && functions.length > 0) {\n                requestConfig.functions = functions;\n                requestConfig.function_call = \"auto\";\n            }\n            const response = await openai.chat.completions.create(requestConfig);\n            const choice = response.choices[0];\n            if (!choice) {\n                throw new Error(\"No response from OpenAI\");\n            }\n            const result = {\n                content: ((_choice_message = choice.message) === null || _choice_message === void 0 ? void 0 : _choice_message.content) || \"\"\n            };\n            // Handle function calls\n            if ((_choice_message1 = choice.message) === null || _choice_message1 === void 0 ? void 0 : _choice_message1.function_call) {\n                result.functionCalls = [\n                    {\n                        name: choice.message.function_call.name,\n                        arguments: JSON.parse(choice.message.function_call.arguments || \"{}\")\n                    }\n                ];\n            }\n            return result;\n        } catch (error) {\n            console.error(\"OpenAI API call failed:\", error);\n            throw new Error(\"OpenAI API call failed: \".concat(error));\n        }\n    }\n    async extractClaimFields(emailText, documents) {\n        const systemPrompt = \"You are an expert insurance claims processor. Extract structured claim information from the provided email and documents. Be precise and only extract information that is explicitly stated or can be confidently inferred.\";\n        const prompt = \"Extract claim fields from this FNOL email and attachments:\\n\\nEMAIL:\\n\".concat(emailText, \"\\n\\nDOCUMENTS:\\n\").concat(documents.join(\"\\n\\n---\\n\\n\"), \"\\n\\nExtract the following fields if present:\\n- policyNumber: Insurance policy number\\n- claimantName: Name of the person filing the claim\\n- contactEmail: Contact email address\\n- contactPhone: Contact phone number\\n- lossDate: Date when the loss occurred (YYYY-MM-DD format)\\n- lossType: Type of loss (Collision, Water, Fire, Theft, Liability, Other)\\n- lossLocation: Where the loss occurred\\n- description: Brief description of what happened\\n- vehicleInfo: If auto claim - year, make, model, license plate\\n- propertyAddress: If property claim - property address\\n- estimatedDamage: Estimated damage amount if mentioned\\n\\nReturn ONLY a JSON object with the extracted fields. Use null for missing fields.\");\n        const functions = [\n            {\n                name: \"extract_claim_fields\",\n                description: \"Extract structured claim information from email and documents\",\n                parameters: {\n                    type: \"object\",\n                    properties: {\n                        policyNumber: {\n                            type: \"string\",\n                            description: \"Insurance policy number\"\n                        },\n                        claimantName: {\n                            type: \"string\",\n                            description: \"Name of claimant\"\n                        },\n                        contactEmail: {\n                            type: \"string\",\n                            description: \"Contact email\"\n                        },\n                        contactPhone: {\n                            type: \"string\",\n                            description: \"Contact phone number\"\n                        },\n                        lossDate: {\n                            type: \"string\",\n                            description: \"Loss date in YYYY-MM-DD format\"\n                        },\n                        lossType: {\n                            type: \"string\",\n                            enum: [\n                                \"Collision\",\n                                \"Water\",\n                                \"Fire\",\n                                \"Theft\",\n                                \"Liability\",\n                                \"Other\"\n                            ],\n                            description: \"Type of loss\"\n                        },\n                        lossLocation: {\n                            type: \"string\",\n                            description: \"Location where loss occurred\"\n                        },\n                        description: {\n                            type: \"string\",\n                            description: \"Description of what happened\"\n                        },\n                        vehicleInfo: {\n                            type: \"object\",\n                            properties: {\n                                year: {\n                                    type: \"string\"\n                                },\n                                make: {\n                                    type: \"string\"\n                                },\n                                model: {\n                                    type: \"string\"\n                                },\n                                licensePlate: {\n                                    type: \"string\"\n                                }\n                            },\n                            description: \"Vehicle information for auto claims\"\n                        },\n                        propertyAddress: {\n                            type: \"string\",\n                            description: \"Property address for property claims\"\n                        },\n                        estimatedDamage: {\n                            type: \"number\",\n                            description: \"Estimated damage amount\"\n                        }\n                    },\n                    required: []\n                }\n            }\n        ];\n        const response = await this.callLLM(prompt, systemPrompt, functions);\n        if (response.functionCalls && response.functionCalls.length > 0) {\n            return response.functionCalls[0].arguments;\n        }\n        // Fallback: try to parse JSON from content\n        try {\n            return JSON.parse(response.content);\n        } catch (e) {\n            throw new Error(\"Failed to extract structured claim fields from LLM response\");\n        }\n    }\n    async classifyDocument(filename, content) {\n        const systemPrompt = \"You are a document classification expert for insurance claims. Classify the document type and extract key fields.\";\n        const prompt = \"Classify this document and extract key information:\\n\\nFILENAME: \".concat(filename, \"\\nCONTENT:\\n\").concat(content.substring(0, 2000), \"...\\n\\nClassify the document type as one of:\\n- PoliceReport\\n- RepairEstimate  \\n- Invoice\\n- MedicalRecord\\n- IncidentReport\\n- DamagePhoto\\n- Other\\n\\nAlso extract relevant key fields based on the document type.\");\n        const functions = [\n            {\n                name: \"classify_document\",\n                description: \"Classify document type and extract key fields\",\n                parameters: {\n                    type: \"object\",\n                    properties: {\n                        type: {\n                            type: \"string\",\n                            enum: [\n                                \"PoliceReport\",\n                                \"RepairEstimate\",\n                                \"Invoice\",\n                                \"MedicalRecord\",\n                                \"IncidentReport\",\n                                \"DamagePhoto\",\n                                \"Other\"\n                            ],\n                            description: \"Document type classification\"\n                        },\n                        confidence: {\n                            type: \"number\",\n                            minimum: 0,\n                            maximum: 1,\n                            description: \"Confidence score for classification\"\n                        },\n                        keyFields: {\n                            type: \"object\",\n                            description: \"Key fields extracted from the document\"\n                        }\n                    },\n                    required: [\n                        \"type\",\n                        \"confidence\",\n                        \"keyFields\"\n                    ]\n                }\n            }\n        ];\n        const response = await this.callLLM(prompt, systemPrompt, functions);\n        if (response.functionCalls && response.functionCalls.length > 0) {\n            const args = response.functionCalls[0].arguments;\n            return {\n                type: args.type || \"Other\",\n                confidence: args.confidence || 0.5,\n                keyFields: args.keyFields || {}\n            };\n        }\n        // Fallback classification\n        return {\n            type: \"Other\",\n            confidence: 0.5,\n            keyFields: {}\n        };\n    }\n    async generateFieldEvidence(fieldName, value, emailText, documents) {\n        const systemPrompt = \"You are an evidence analyst for insurance claims. Identify the source and rationale for extracted field values.\";\n        const prompt = \"Analyze the evidence for this extracted field:\\n\\nFIELD: \".concat(fieldName, \"\\nVALUE: \").concat(value, \"\\n\\nSOURCE TEXT:\\nEMAIL: \").concat(emailText, \"\\n\\nDOCUMENTS:\\n\").concat(documents.join(\"\\n\\n---\\n\\n\"), \"\\n\\nProvide:\\n1. Confidence score (0-1) for this field extraction\\n2. Source locator (where in the text this value was found)\\n3. Brief rationale explaining why this value was extracted\");\n        const functions = [\n            {\n                name: \"analyze_field_evidence\",\n                description: \"Analyze evidence for extracted field\",\n                parameters: {\n                    type: \"object\",\n                    properties: {\n                        confidence: {\n                            type: \"number\",\n                            minimum: 0,\n                            maximum: 1,\n                            description: \"Confidence score for field extraction\"\n                        },\n                        sourceLocator: {\n                            type: \"string\",\n                            description: \"Location where value was found (e.g., email_text:100-150, doc1:50-75)\"\n                        },\n                        rationale: {\n                            type: \"string\",\n                            description: \"Brief explanation of why this value was extracted\"\n                        }\n                    },\n                    required: [\n                        \"confidence\",\n                        \"sourceLocator\",\n                        \"rationale\"\n                    ]\n                }\n            }\n        ];\n        const response = await this.callLLM(prompt, systemPrompt, functions);\n        if (response.functionCalls && response.functionCalls.length > 0) {\n            const args = response.functionCalls[0].arguments;\n            return {\n                confidence: args.confidence || 0.7,\n                sourceLocator: args.sourceLocator || \"text_inference\",\n                rationale: args.rationale || \"Inferred from document context\"\n            };\n        }\n        // Fallback evidence\n        return {\n            confidence: 0.7,\n            sourceLocator: \"text_inference\",\n            rationale: \"Inferred from document context\"\n        };\n    }\n    async queryPolicyDatabase(lossType, description, extractedFields) {\n        const systemPrompt = \"You are a policy database search expert. Given claim information, identify the most relevant policy clauses.\";\n        const prompt = \"Find relevant policy clauses for this claim:\\n\\nLOSS TYPE: \".concat(lossType, \"\\nDESCRIPTION: \").concat(description, \"\\nEXTRACTED FIELDS: \").concat(JSON.stringify(extractedFields, null, 2), \"\\n\\nBased on this information, identify which of these policy clauses are most relevant:\\n\\nAUTO INSURANCE:\\n- AUTO-COL-001: Collision Coverage - covers vehicle collisions\\n- AUTO-LIAB-001: Bodily Injury Liability - covers injury to others\\n- AUTO-PD-001: Property Damage Liability - covers damage to others' property\\n\\nHOMEOWNERS:\\n- HO-WATER-001: Water Damage Coverage - covers sudden water damage\\n- HO-STORM-001: Wind and Hail Coverage - covers storm damage\\n\\nCOMMERCIAL LIABILITY:\\n- CGL-SLIP-001: Premises Liability Coverage - covers slip and fall\\n- CGL-MED-001: Medical Payments Coverage - covers medical expenses\\n\\nReturn the top 3 most relevant clauses with similarity scores.\");\n        const functions = [\n            {\n                name: \"query_policy_clauses\",\n                description: \"Find relevant policy clauses for the claim\",\n                parameters: {\n                    type: \"object\",\n                    properties: {\n                        relevantClauses: {\n                            type: \"array\",\n                            items: {\n                                type: \"object\",\n                                properties: {\n                                    clauseId: {\n                                        type: \"string\",\n                                        description: \"Policy clause ID\"\n                                    },\n                                    title: {\n                                        type: \"string\",\n                                        description: \"Clause title\"\n                                    },\n                                    similarity: {\n                                        type: \"number\",\n                                        minimum: 0,\n                                        maximum: 1,\n                                        description: \"Similarity score to the claim\"\n                                    },\n                                    rationale: {\n                                        type: \"string\",\n                                        description: \"Why this clause is relevant\"\n                                    }\n                                },\n                                required: [\n                                    \"clauseId\",\n                                    \"title\",\n                                    \"similarity\",\n                                    \"rationale\"\n                                ]\n                            },\n                            maxItems: 3\n                        }\n                    },\n                    required: [\n                        \"relevantClauses\"\n                    ]\n                }\n            }\n        ];\n        const response = await this.callLLM(prompt, systemPrompt, functions);\n        if (response.functionCalls && response.functionCalls.length > 0) {\n            return response.functionCalls[0].arguments.relevantClauses || [];\n        }\n        return [];\n    }\n    async summarizeProcessing(extractedFields, documents, policyHits) {\n        var _policyHits_;\n        const systemPrompt = \"You are a claims processing supervisor. Summarize the automated processing results and provide recommendations.\";\n        const prompt = \"Summarize this automated claim processing:\\n\\nEXTRACTED FIELDS:\\n\".concat(JSON.stringify(extractedFields, null, 2), \"\\n\\nDOCUMENTS PROCESSED: \").concat(documents.length, \"\\nDOCUMENT TYPES: \").concat(documents.map((d)=>d.type).join(\", \"), \"\\n\\nPOLICY HITS: \").concat(policyHits.length, \"\\nTOP POLICY MATCH: \").concat(((_policyHits_ = policyHits[0]) === null || _policyHits_ === void 0 ? void 0 : _policyHits_.title) || \"None\", \"\\n\\nProvide:\\n1. A brief summary of the claim\\n2. Recommendations for next steps\\n3. Any risk flags or concerns\");\n        const functions = [\n            {\n                name: \"summarize_claim_processing\",\n                description: \"Summarize claim processing results\",\n                parameters: {\n                    type: \"object\",\n                    properties: {\n                        summary: {\n                            type: \"string\",\n                            description: \"Brief summary of the claim and processing\"\n                        },\n                        recommendations: {\n                            type: \"array\",\n                            items: {\n                                type: \"string\"\n                            },\n                            description: \"Recommended next steps\"\n                        },\n                        riskFlags: {\n                            type: \"array\",\n                            items: {\n                                type: \"string\"\n                            },\n                            description: \"Risk flags or concerns identified\"\n                        }\n                    },\n                    required: [\n                        \"summary\",\n                        \"recommendations\",\n                        \"riskFlags\"\n                    ]\n                }\n            }\n        ];\n        const response = await this.callLLM(prompt, systemPrompt, functions);\n        if (response.functionCalls && response.functionCalls.length > 0) {\n            return response.functionCalls[0].arguments;\n        }\n        return {\n            summary: \"Claim processed automatically with extracted information.\",\n            recommendations: [\n                \"Review extracted information\",\n                \"Verify policy coverage\"\n            ],\n            riskFlags: []\n        };\n    }\n    constructor(model = \"gpt-4-1106-preview\", temperature = 0.1){\n        this.model = model;\n        this.temperature = temperature;\n    }\n}\n// Export singleton instance\nconst openaiService = new OpenAIService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9vcGVuYWkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyQjtBQUUzQiwyQkFBMkI7QUFDM0IsTUFBTUMsU0FBUyxJQUFJRCw4Q0FBTUEsQ0FBQztJQUN4QkUsUUFBUUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxjQUFjLElBQUk7SUFDdENDLHlCQUF5QixLQUFLLGdFQUFnRTtBQUNoRztBQW9CTyxNQUFNQztJQVNYLE1BQU1DLFFBQ0pDLE1BQWMsRUFDZEMsWUFBcUIsRUFDckJDLFNBQTBCLEVBQ0o7UUFDdEIsSUFBSTtnQkErQlNDLGlCQUlQQTtZQWxDSixNQUFNQyxXQUFrQixFQUFFO1lBRTFCLElBQUlILGNBQWM7Z0JBQ2hCRyxTQUFTQyxJQUFJLENBQUM7b0JBQUVDLE1BQU07b0JBQVVDLFNBQVNOO2dCQUFhO1lBQ3hEO1lBRUFHLFNBQVNDLElBQUksQ0FBQztnQkFBRUMsTUFBTTtnQkFBUUMsU0FBU1A7WUFBTztZQUU5QyxNQUFNUSxnQkFBcUI7Z0JBQ3pCQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztnQkFDakJMO2dCQUNBTSxhQUFhLElBQUksQ0FBQ0EsV0FBVztnQkFDN0JDLFlBQVk7WUFDZDtZQUVBLGlEQUFpRDtZQUNqRCxJQUFJVCxhQUFhQSxVQUFVVSxNQUFNLEdBQUcsR0FBRztnQkFDckNKLGNBQWNOLFNBQVMsR0FBR0E7Z0JBQzFCTSxjQUFjSyxhQUFhLEdBQUc7WUFDaEM7WUFFQSxNQUFNQyxXQUFXLE1BQU10QixPQUFPdUIsSUFBSSxDQUFDQyxXQUFXLENBQUNDLE1BQU0sQ0FBQ1Q7WUFFdEQsTUFBTUwsU0FBU1csU0FBU0ksT0FBTyxDQUFDLEVBQUU7WUFFbEMsSUFBSSxDQUFDZixRQUFRO2dCQUNYLE1BQU0sSUFBSWdCLE1BQU07WUFDbEI7WUFFQSxNQUFNQyxTQUFzQjtnQkFDMUJiLFNBQVNKLEVBQUFBLGtCQUFBQSxPQUFPa0IsT0FBTyxjQUFkbEIsc0NBQUFBLGdCQUFnQkksT0FBTyxLQUFJO1lBQ3RDO1lBRUEsd0JBQXdCO1lBQ3hCLEtBQUlKLG1CQUFBQSxPQUFPa0IsT0FBTyxjQUFkbEIsdUNBQUFBLGlCQUFnQlUsYUFBYSxFQUFFO2dCQUNqQ08sT0FBT0UsYUFBYSxHQUFHO29CQUFDO3dCQUN0QkMsTUFBTXBCLE9BQU9rQixPQUFPLENBQUNSLGFBQWEsQ0FBQ1UsSUFBSTt3QkFDdkNDLFdBQVdDLEtBQUtDLEtBQUssQ0FBQ3ZCLE9BQU9rQixPQUFPLENBQUNSLGFBQWEsQ0FBQ1csU0FBUyxJQUFJO29CQUNsRTtpQkFBRTtZQUNKO1lBRUEsT0FBT0o7UUFDVCxFQUFFLE9BQU9PLE9BQU87WUFDZEMsUUFBUUQsS0FBSyxDQUFDLDJCQUEyQkE7WUFDekMsTUFBTSxJQUFJUixNQUFNLDJCQUFpQyxPQUFOUTtRQUM3QztJQUNGO0lBRUEsTUFBTUUsbUJBQW1CQyxTQUFpQixFQUFFQyxTQUFtQixFQUFnQztRQUM3RixNQUFNOUIsZUFBZ0I7UUFFdEIsTUFBTUQsU0FBUyx5RUFNakIrQixPQUhBRCxXQUFVLG9CQUdvQixPQUE5QkMsVUFBVUMsSUFBSSxDQUFDLGdCQUFlO1FBaUI1QixNQUFNOUIsWUFBNEI7WUFBQztnQkFDakNxQixNQUFNO2dCQUNOVSxhQUFhO2dCQUNiQyxZQUFZO29CQUNWQyxNQUFNO29CQUNOQyxZQUFZO3dCQUNWQyxjQUFjOzRCQUFFRixNQUFNOzRCQUFVRixhQUFhO3dCQUEwQjt3QkFDdkVLLGNBQWM7NEJBQUVILE1BQU07NEJBQVVGLGFBQWE7d0JBQW1CO3dCQUNoRU0sY0FBYzs0QkFBRUosTUFBTTs0QkFBVUYsYUFBYTt3QkFBZ0I7d0JBQzdETyxjQUFjOzRCQUFFTCxNQUFNOzRCQUFVRixhQUFhO3dCQUF1Qjt3QkFDcEVRLFVBQVU7NEJBQUVOLE1BQU07NEJBQVVGLGFBQWE7d0JBQWlDO3dCQUMxRVMsVUFBVTs0QkFDUlAsTUFBTTs0QkFDTlEsTUFBTTtnQ0FBQztnQ0FBYTtnQ0FBUztnQ0FBUTtnQ0FBUztnQ0FBYTs2QkFBUTs0QkFDbkVWLGFBQWE7d0JBQ2Y7d0JBQ0FXLGNBQWM7NEJBQUVULE1BQU07NEJBQVVGLGFBQWE7d0JBQStCO3dCQUM1RUEsYUFBYTs0QkFBRUUsTUFBTTs0QkFBVUYsYUFBYTt3QkFBK0I7d0JBQzNFWSxhQUFhOzRCQUNYVixNQUFNOzRCQUNOQyxZQUFZO2dDQUNWVSxNQUFNO29DQUFFWCxNQUFNO2dDQUFTO2dDQUN2QlksTUFBTTtvQ0FBRVosTUFBTTtnQ0FBUztnQ0FDdkIxQixPQUFPO29DQUFFMEIsTUFBTTtnQ0FBUztnQ0FDeEJhLGNBQWM7b0NBQUViLE1BQU07Z0NBQVM7NEJBQ2pDOzRCQUNBRixhQUFhO3dCQUNmO3dCQUNBZ0IsaUJBQWlCOzRCQUFFZCxNQUFNOzRCQUFVRixhQUFhO3dCQUF1Qzt3QkFDdkZpQixpQkFBaUI7NEJBQUVmLE1BQU07NEJBQVVGLGFBQWE7d0JBQTBCO29CQUM1RTtvQkFDQWtCLFVBQVUsRUFBRTtnQkFDZDtZQUNGO1NBQUU7UUFFRixNQUFNckMsV0FBVyxNQUFNLElBQUksQ0FBQ2YsT0FBTyxDQUFDQyxRQUFRQyxjQUFjQztRQUUxRCxJQUFJWSxTQUFTUSxhQUFhLElBQUlSLFNBQVNRLGFBQWEsQ0FBQ1YsTUFBTSxHQUFHLEdBQUc7WUFDL0QsT0FBT0UsU0FBU1EsYUFBYSxDQUFDLEVBQUUsQ0FBQ0UsU0FBUztRQUM1QztRQUVBLDJDQUEyQztRQUMzQyxJQUFJO1lBQ0YsT0FBT0MsS0FBS0MsS0FBSyxDQUFDWixTQUFTUCxPQUFPO1FBQ3BDLEVBQUUsVUFBTTtZQUNOLE1BQU0sSUFBSVksTUFBTTtRQUNsQjtJQUNGO0lBRUEsTUFBTWlDLGlCQUFpQkMsUUFBZ0IsRUFBRTlDLE9BQWUsRUFJckQ7UUFDRCxNQUFNTixlQUFnQjtRQUV0QixNQUFNRCxTQUFTLG9FQUlqQk8sT0FGVThDLFVBQVMsZ0JBRVEsT0FBM0I5QyxRQUFRK0MsU0FBUyxDQUFDLEdBQUcsT0FBTTtRQWF6QixNQUFNcEQsWUFBNEI7WUFBQztnQkFDakNxQixNQUFNO2dCQUNOVSxhQUFhO2dCQUNiQyxZQUFZO29CQUNWQyxNQUFNO29CQUNOQyxZQUFZO3dCQUNWRCxNQUFNOzRCQUNKQSxNQUFNOzRCQUNOUSxNQUFNO2dDQUFDO2dDQUFnQjtnQ0FBa0I7Z0NBQVc7Z0NBQWlCO2dDQUFrQjtnQ0FBZTs2QkFBUTs0QkFDOUdWLGFBQWE7d0JBQ2Y7d0JBQ0FzQixZQUFZOzRCQUNWcEIsTUFBTTs0QkFDTnFCLFNBQVM7NEJBQ1RDLFNBQVM7NEJBQ1R4QixhQUFhO3dCQUNmO3dCQUNBeUIsV0FBVzs0QkFDVHZCLE1BQU07NEJBQ05GLGFBQWE7d0JBQ2Y7b0JBQ0Y7b0JBQ0FrQixVQUFVO3dCQUFDO3dCQUFRO3dCQUFjO3FCQUFZO2dCQUMvQztZQUNGO1NBQUU7UUFFRixNQUFNckMsV0FBVyxNQUFNLElBQUksQ0FBQ2YsT0FBTyxDQUFDQyxRQUFRQyxjQUFjQztRQUUxRCxJQUFJWSxTQUFTUSxhQUFhLElBQUlSLFNBQVNRLGFBQWEsQ0FBQ1YsTUFBTSxHQUFHLEdBQUc7WUFDL0QsTUFBTStDLE9BQU83QyxTQUFTUSxhQUFhLENBQUMsRUFBRSxDQUFDRSxTQUFTO1lBQ2hELE9BQU87Z0JBQ0xXLE1BQU13QixLQUFLeEIsSUFBSSxJQUFJO2dCQUNuQm9CLFlBQVlJLEtBQUtKLFVBQVUsSUFBSTtnQkFDL0JHLFdBQVdDLEtBQUtELFNBQVMsSUFBSSxDQUFDO1lBQ2hDO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUIsT0FBTztZQUNMdkIsTUFBTTtZQUNOb0IsWUFBWTtZQUNaRyxXQUFXLENBQUM7UUFDZDtJQUNGO0lBRUEsTUFBTUUsc0JBQ0pDLFNBQWlCLEVBQ2pCQyxLQUFVLEVBQ1ZoQyxTQUFpQixFQUNqQkMsU0FBbUIsRUFLbEI7UUFDRCxNQUFNOUIsZUFBZ0I7UUFFdEIsTUFBTUQsU0FBUyw0REFHVjhELE9BREFELFdBQVUsYUFJVi9CLE9BSEFnQyxPQUFNLDZCQU1iL0IsT0FIT0QsV0FBVSxvQkFHYSxPQUE5QkMsVUFBVUMsSUFBSSxDQUFDLGdCQUFlO1FBTzVCLE1BQU05QixZQUE0QjtZQUFDO2dCQUNqQ3FCLE1BQU07Z0JBQ05VLGFBQWE7Z0JBQ2JDLFlBQVk7b0JBQ1ZDLE1BQU07b0JBQ05DLFlBQVk7d0JBQ1ZtQixZQUFZOzRCQUNWcEIsTUFBTTs0QkFDTnFCLFNBQVM7NEJBQ1RDLFNBQVM7NEJBQ1R4QixhQUFhO3dCQUNmO3dCQUNBOEIsZUFBZTs0QkFDYjVCLE1BQU07NEJBQ05GLGFBQWE7d0JBQ2Y7d0JBQ0ErQixXQUFXOzRCQUNUN0IsTUFBTTs0QkFDTkYsYUFBYTt3QkFDZjtvQkFDRjtvQkFDQWtCLFVBQVU7d0JBQUM7d0JBQWM7d0JBQWlCO3FCQUFZO2dCQUN4RDtZQUNGO1NBQUU7UUFFRixNQUFNckMsV0FBVyxNQUFNLElBQUksQ0FBQ2YsT0FBTyxDQUFDQyxRQUFRQyxjQUFjQztRQUUxRCxJQUFJWSxTQUFTUSxhQUFhLElBQUlSLFNBQVNRLGFBQWEsQ0FBQ1YsTUFBTSxHQUFHLEdBQUc7WUFDL0QsTUFBTStDLE9BQU83QyxTQUFTUSxhQUFhLENBQUMsRUFBRSxDQUFDRSxTQUFTO1lBQ2hELE9BQU87Z0JBQ0wrQixZQUFZSSxLQUFLSixVQUFVLElBQUk7Z0JBQy9CUSxlQUFlSixLQUFLSSxhQUFhLElBQUk7Z0JBQ3JDQyxXQUFXTCxLQUFLSyxTQUFTLElBQUk7WUFDL0I7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQixPQUFPO1lBQ0xULFlBQVk7WUFDWlEsZUFBZTtZQUNmQyxXQUFXO1FBQ2I7SUFDRjtJQUVBLE1BQU1DLG9CQUNKdkIsUUFBZ0IsRUFDaEJULFdBQW1CLEVBQ25CaUMsZUFBb0MsRUFNbEM7UUFDRixNQUFNakUsZUFBZ0I7UUFFdEIsTUFBTUQsU0FBUyw4REFHSmlDLE9BREZTLFVBQVMsbUJBRUZqQixPQURMUSxhQUFZLHdCQUNrQyxPQUF6Q1IsS0FBSzBDLFNBQVMsQ0FBQ0QsaUJBQWlCLE1BQU0sSUFBRztRQW1CekQsTUFBTWhFLFlBQTRCO1lBQUM7Z0JBQ2pDcUIsTUFBTTtnQkFDTlUsYUFBYTtnQkFDYkMsWUFBWTtvQkFDVkMsTUFBTTtvQkFDTkMsWUFBWTt3QkFDVmdDLGlCQUFpQjs0QkFDZmpDLE1BQU07NEJBQ05rQyxPQUFPO2dDQUNMbEMsTUFBTTtnQ0FDTkMsWUFBWTtvQ0FDVmtDLFVBQVU7d0NBQUVuQyxNQUFNO3dDQUFVRixhQUFhO29DQUFtQjtvQ0FDNURzQyxPQUFPO3dDQUFFcEMsTUFBTTt3Q0FBVUYsYUFBYTtvQ0FBZTtvQ0FDckR1QyxZQUFZO3dDQUNWckMsTUFBTTt3Q0FDTnFCLFNBQVM7d0NBQ1RDLFNBQVM7d0NBQ1R4QixhQUFhO29DQUNmO29DQUNBK0IsV0FBVzt3Q0FBRTdCLE1BQU07d0NBQVVGLGFBQWE7b0NBQThCO2dDQUMxRTtnQ0FDQWtCLFVBQVU7b0NBQUM7b0NBQVk7b0NBQVM7b0NBQWM7aUNBQVk7NEJBQzVEOzRCQUNBc0IsVUFBVTt3QkFDWjtvQkFDRjtvQkFDQXRCLFVBQVU7d0JBQUM7cUJBQWtCO2dCQUMvQjtZQUNGO1NBQUU7UUFFRixNQUFNckMsV0FBVyxNQUFNLElBQUksQ0FBQ2YsT0FBTyxDQUFDQyxRQUFRQyxjQUFjQztRQUUxRCxJQUFJWSxTQUFTUSxhQUFhLElBQUlSLFNBQVNRLGFBQWEsQ0FBQ1YsTUFBTSxHQUFHLEdBQUc7WUFDL0QsT0FBT0UsU0FBU1EsYUFBYSxDQUFDLEVBQUUsQ0FBQ0UsU0FBUyxDQUFDNEMsZUFBZSxJQUFJLEVBQUU7UUFDbEU7UUFFQSxPQUFPLEVBQUU7SUFDWDtJQUVBLE1BQU1NLG9CQUNKUixlQUFvQyxFQUNwQ25DLFNBQWdCLEVBQ2hCNEMsVUFBaUIsRUFLaEI7WUFZZUE7UUFYaEIsTUFBTTFFLGVBQWdCO1FBRXRCLE1BQU1ELFNBQVMsb0VBS0krQixPQUZyQk4sS0FBSzBDLFNBQVMsQ0FBQ0QsaUJBQWlCLE1BQU0sSUFBRyw2QkFHekJuQyxPQURLQSxVQUFVbkIsTUFBTSxFQUFDLHNCQUd6QitELE9BRkc1QyxVQUFVNkMsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFMUMsSUFBSSxFQUFFSCxJQUFJLENBQUMsT0FBTSxxQkFHcEMyQyxPQURMQSxXQUFXL0QsTUFBTSxFQUFDLHdCQUNrQixPQUEvQitELEVBQUFBLGVBQUFBLFVBQVUsQ0FBQyxFQUFFLGNBQWJBLG1DQUFBQSxhQUFlSixLQUFLLEtBQUksUUFBTztRQU8vQyxNQUFNckUsWUFBNEI7WUFBQztnQkFDakNxQixNQUFNO2dCQUNOVSxhQUFhO2dCQUNiQyxZQUFZO29CQUNWQyxNQUFNO29CQUNOQyxZQUFZO3dCQUNWMEMsU0FBUzs0QkFDUDNDLE1BQU07NEJBQ05GLGFBQWE7d0JBQ2Y7d0JBQ0E4QyxpQkFBaUI7NEJBQ2Y1QyxNQUFNOzRCQUNOa0MsT0FBTztnQ0FBRWxDLE1BQU07NEJBQVM7NEJBQ3hCRixhQUFhO3dCQUNmO3dCQUNBK0MsV0FBVzs0QkFDVDdDLE1BQU07NEJBQ05rQyxPQUFPO2dDQUFFbEMsTUFBTTs0QkFBUzs0QkFDeEJGLGFBQWE7d0JBQ2Y7b0JBQ0Y7b0JBQ0FrQixVQUFVO3dCQUFDO3dCQUFXO3dCQUFtQjtxQkFBWTtnQkFDdkQ7WUFDRjtTQUFFO1FBRUYsTUFBTXJDLFdBQVcsTUFBTSxJQUFJLENBQUNmLE9BQU8sQ0FBQ0MsUUFBUUMsY0FBY0M7UUFFMUQsSUFBSVksU0FBU1EsYUFBYSxJQUFJUixTQUFTUSxhQUFhLENBQUNWLE1BQU0sR0FBRyxHQUFHO1lBQy9ELE9BQU9FLFNBQVNRLGFBQWEsQ0FBQyxFQUFFLENBQUNFLFNBQVM7UUFDNUM7UUFFQSxPQUFPO1lBQ0xzRCxTQUFTO1lBQ1RDLGlCQUFpQjtnQkFBQztnQkFBZ0M7YUFBeUI7WUFDM0VDLFdBQVcsRUFBRTtRQUNmO0lBQ0Y7SUE1WkFDLFlBQVl4RSxRQUFnQixvQkFBb0IsRUFBRUMsY0FBc0IsR0FBRyxDQUFFO1FBQzNFLElBQUksQ0FBQ0QsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ0MsV0FBVyxHQUFHQTtJQUNyQjtBQTBaRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNd0UsZ0JBQWdCLElBQUlwRixnQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvc2VydmljZXMvb3BlbmFpLnRzPzZlZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknXG5cbi8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudFxuY29uc3Qgb3BlbmFpID0gbmV3IE9wZW5BSSh7XG4gIGFwaUtleTogcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVkgfHwgJycsXG4gIGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlIC8vIEZvciBkZW1vIHB1cnBvc2VzIC0gaW4gcHJvZHVjdGlvbiwgdXNlIHNlcnZlci1zaWRlIEFQSSByb3V0ZXNcbn0pXG5cbmV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb25DYWxsIHtcbiAgbmFtZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgcGFyYW1ldGVyczoge1xuICAgIHR5cGU6ICdvYmplY3QnXG4gICAgcHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuICAgIHJlcXVpcmVkOiBzdHJpbmdbXVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTExNUmVzcG9uc2Uge1xuICBjb250ZW50OiBzdHJpbmdcbiAgZnVuY3Rpb25DYWxscz86IEFycmF5PHtcbiAgICBuYW1lOiBzdHJpbmdcbiAgICBhcmd1bWVudHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgfT5cbn1cblxuZXhwb3J0IGNsYXNzIE9wZW5BSVNlcnZpY2Uge1xuICBwcml2YXRlIG1vZGVsOiBzdHJpbmdcbiAgcHJpdmF0ZSB0ZW1wZXJhdHVyZTogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IobW9kZWw6IHN0cmluZyA9ICdncHQtNC0xMTA2LXByZXZpZXcnLCB0ZW1wZXJhdHVyZTogbnVtYmVyID0gMC4xKSB7XG4gICAgdGhpcy5tb2RlbCA9IG1vZGVsXG4gICAgdGhpcy50ZW1wZXJhdHVyZSA9IHRlbXBlcmF0dXJlXG4gIH1cblxuICBhc3luYyBjYWxsTExNKFxuICAgIHByb21wdDogc3RyaW5nLFxuICAgIHN5c3RlbVByb21wdD86IHN0cmluZyxcbiAgICBmdW5jdGlvbnM/OiBGdW5jdGlvbkNhbGxbXVxuICApOiBQcm9taXNlPExMTVJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzOiBhbnlbXSA9IFtdXG4gICAgICBcbiAgICAgIGlmIChzeXN0ZW1Qcm9tcHQpIHtcbiAgICAgICAgbWVzc2FnZXMucHVzaCh7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBzeXN0ZW1Qcm9tcHQgfSlcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbWVzc2FnZXMucHVzaCh7IHJvbGU6ICd1c2VyJywgY29udGVudDogcHJvbXB0IH0pXG5cbiAgICAgIGNvbnN0IHJlcXVlc3RDb25maWc6IGFueSA9IHtcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICB0ZW1wZXJhdHVyZTogdGhpcy50ZW1wZXJhdHVyZSxcbiAgICAgICAgbWF4X3Rva2VuczogMjAwMFxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZnVuY3Rpb24gY2FsbGluZyBpZiBmdW5jdGlvbnMgYXJlIHByb3ZpZGVkXG4gICAgICBpZiAoZnVuY3Rpb25zICYmIGZ1bmN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcXVlc3RDb25maWcuZnVuY3Rpb25zID0gZnVuY3Rpb25zXG4gICAgICAgIHJlcXVlc3RDb25maWcuZnVuY3Rpb25fY2FsbCA9ICdhdXRvJ1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZShyZXF1ZXN0Q29uZmlnKVxuICAgICAgXG4gICAgICBjb25zdCBjaG9pY2UgPSByZXNwb25zZS5jaG9pY2VzWzBdXG4gICAgICBcbiAgICAgIGlmICghY2hvaWNlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcmVzcG9uc2UgZnJvbSBPcGVuQUknKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQ6IExMTVJlc3BvbnNlID0ge1xuICAgICAgICBjb250ZW50OiBjaG9pY2UubWVzc2FnZT8uY29udGVudCB8fCAnJ1xuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgZnVuY3Rpb24gY2FsbHNcbiAgICAgIGlmIChjaG9pY2UubWVzc2FnZT8uZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICByZXN1bHQuZnVuY3Rpb25DYWxscyA9IFt7XG4gICAgICAgICAgbmFtZTogY2hvaWNlLm1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZShjaG9pY2UubWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyB8fCAne30nKVxuICAgICAgICB9XVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ09wZW5BSSBBUEkgY2FsbCBmYWlsZWQ6JywgZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZW5BSSBBUEkgY2FsbCBmYWlsZWQ6ICR7ZXJyb3J9YClcbiAgICB9XG4gIH1cblxuICBhc3luYyBleHRyYWN0Q2xhaW1GaWVsZHMoZW1haWxUZXh0OiBzdHJpbmcsIGRvY3VtZW50czogc3RyaW5nW10pOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIGFueT4+IHtcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhbiBleHBlcnQgaW5zdXJhbmNlIGNsYWltcyBwcm9jZXNzb3IuIEV4dHJhY3Qgc3RydWN0dXJlZCBjbGFpbSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBwcm92aWRlZCBlbWFpbCBhbmQgZG9jdW1lbnRzLiBCZSBwcmVjaXNlIGFuZCBvbmx5IGV4dHJhY3QgaW5mb3JtYXRpb24gdGhhdCBpcyBleHBsaWNpdGx5IHN0YXRlZCBvciBjYW4gYmUgY29uZmlkZW50bHkgaW5mZXJyZWQuYFxuXG4gICAgY29uc3QgcHJvbXB0ID0gYEV4dHJhY3QgY2xhaW0gZmllbGRzIGZyb20gdGhpcyBGTk9MIGVtYWlsIGFuZCBhdHRhY2htZW50czpcblxuRU1BSUw6XG4ke2VtYWlsVGV4dH1cblxuRE9DVU1FTlRTOlxuJHtkb2N1bWVudHMuam9pbignXFxuXFxuLS0tXFxuXFxuJyl9XG5cbkV4dHJhY3QgdGhlIGZvbGxvd2luZyBmaWVsZHMgaWYgcHJlc2VudDpcbi0gcG9saWN5TnVtYmVyOiBJbnN1cmFuY2UgcG9saWN5IG51bWJlclxuLSBjbGFpbWFudE5hbWU6IE5hbWUgb2YgdGhlIHBlcnNvbiBmaWxpbmcgdGhlIGNsYWltXG4tIGNvbnRhY3RFbWFpbDogQ29udGFjdCBlbWFpbCBhZGRyZXNzXG4tIGNvbnRhY3RQaG9uZTogQ29udGFjdCBwaG9uZSBudW1iZXJcbi0gbG9zc0RhdGU6IERhdGUgd2hlbiB0aGUgbG9zcyBvY2N1cnJlZCAoWVlZWS1NTS1ERCBmb3JtYXQpXG4tIGxvc3NUeXBlOiBUeXBlIG9mIGxvc3MgKENvbGxpc2lvbiwgV2F0ZXIsIEZpcmUsIFRoZWZ0LCBMaWFiaWxpdHksIE90aGVyKVxuLSBsb3NzTG9jYXRpb246IFdoZXJlIHRoZSBsb3NzIG9jY3VycmVkXG4tIGRlc2NyaXB0aW9uOiBCcmllZiBkZXNjcmlwdGlvbiBvZiB3aGF0IGhhcHBlbmVkXG4tIHZlaGljbGVJbmZvOiBJZiBhdXRvIGNsYWltIC0geWVhciwgbWFrZSwgbW9kZWwsIGxpY2Vuc2UgcGxhdGVcbi0gcHJvcGVydHlBZGRyZXNzOiBJZiBwcm9wZXJ0eSBjbGFpbSAtIHByb3BlcnR5IGFkZHJlc3Ncbi0gZXN0aW1hdGVkRGFtYWdlOiBFc3RpbWF0ZWQgZGFtYWdlIGFtb3VudCBpZiBtZW50aW9uZWRcblxuUmV0dXJuIE9OTFkgYSBKU09OIG9iamVjdCB3aXRoIHRoZSBleHRyYWN0ZWQgZmllbGRzLiBVc2UgbnVsbCBmb3IgbWlzc2luZyBmaWVsZHMuYFxuXG4gICAgY29uc3QgZnVuY3Rpb25zOiBGdW5jdGlvbkNhbGxbXSA9IFt7XG4gICAgICBuYW1lOiAnZXh0cmFjdF9jbGFpbV9maWVsZHMnLFxuICAgICAgZGVzY3JpcHRpb246ICdFeHRyYWN0IHN0cnVjdHVyZWQgY2xhaW0gaW5mb3JtYXRpb24gZnJvbSBlbWFpbCBhbmQgZG9jdW1lbnRzJyxcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBwb2xpY3lOdW1iZXI6IHsgdHlwZTogJ3N0cmluZycsIGRlc2NyaXB0aW9uOiAnSW5zdXJhbmNlIHBvbGljeSBudW1iZXInIH0sXG4gICAgICAgICAgY2xhaW1hbnROYW1lOiB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjcmlwdGlvbjogJ05hbWUgb2YgY2xhaW1hbnQnIH0sXG4gICAgICAgICAgY29udGFjdEVtYWlsOiB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjcmlwdGlvbjogJ0NvbnRhY3QgZW1haWwnIH0sXG4gICAgICAgICAgY29udGFjdFBob25lOiB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjcmlwdGlvbjogJ0NvbnRhY3QgcGhvbmUgbnVtYmVyJyB9LFxuICAgICAgICAgIGxvc3NEYXRlOiB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjcmlwdGlvbjogJ0xvc3MgZGF0ZSBpbiBZWVlZLU1NLUREIGZvcm1hdCcgfSxcbiAgICAgICAgICBsb3NzVHlwZTogeyBcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLCBcbiAgICAgICAgICAgIGVudW06IFsnQ29sbGlzaW9uJywgJ1dhdGVyJywgJ0ZpcmUnLCAnVGhlZnQnLCAnTGlhYmlsaXR5JywgJ090aGVyJ10sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1R5cGUgb2YgbG9zcydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGxvc3NMb2NhdGlvbjogeyB0eXBlOiAnc3RyaW5nJywgZGVzY3JpcHRpb246ICdMb2NhdGlvbiB3aGVyZSBsb3NzIG9jY3VycmVkJyB9LFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB7IHR5cGU6ICdzdHJpbmcnLCBkZXNjcmlwdGlvbjogJ0Rlc2NyaXB0aW9uIG9mIHdoYXQgaGFwcGVuZWQnIH0sXG4gICAgICAgICAgdmVoaWNsZUluZm86IHsgXG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgeWVhcjogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICBtYWtlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgIG1vZGVsOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICAgIGxpY2Vuc2VQbGF0ZTogeyB0eXBlOiAnc3RyaW5nJyB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdWZWhpY2xlIGluZm9ybWF0aW9uIGZvciBhdXRvIGNsYWltcydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByb3BlcnR5QWRkcmVzczogeyB0eXBlOiAnc3RyaW5nJywgZGVzY3JpcHRpb246ICdQcm9wZXJ0eSBhZGRyZXNzIGZvciBwcm9wZXJ0eSBjbGFpbXMnIH0sXG4gICAgICAgICAgZXN0aW1hdGVkRGFtYWdlOiB7IHR5cGU6ICdudW1iZXInLCBkZXNjcmlwdGlvbjogJ0VzdGltYXRlZCBkYW1hZ2UgYW1vdW50JyB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbXVxuICAgICAgfVxuICAgIH1dXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIHN5c3RlbVByb21wdCwgZnVuY3Rpb25zKVxuICAgIFxuICAgIGlmIChyZXNwb25zZS5mdW5jdGlvbkNhbGxzICYmIHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHNbMF0uYXJndW1lbnRzXG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiB0cnkgdG8gcGFyc2UgSlNPTiBmcm9tIGNvbnRlbnRcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2UuY29udGVudClcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3Qgc3RydWN0dXJlZCBjbGFpbSBmaWVsZHMgZnJvbSBMTE0gcmVzcG9uc2UnKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGNsYXNzaWZ5RG9jdW1lbnQoZmlsZW5hbWU6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgdHlwZTogc3RyaW5nXG4gICAgY29uZmlkZW5jZTogbnVtYmVyXG4gICAga2V5RmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIH0+IHtcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhIGRvY3VtZW50IGNsYXNzaWZpY2F0aW9uIGV4cGVydCBmb3IgaW5zdXJhbmNlIGNsYWltcy4gQ2xhc3NpZnkgdGhlIGRvY3VtZW50IHR5cGUgYW5kIGV4dHJhY3Qga2V5IGZpZWxkcy5gXG5cbiAgICBjb25zdCBwcm9tcHQgPSBgQ2xhc3NpZnkgdGhpcyBkb2N1bWVudCBhbmQgZXh0cmFjdCBrZXkgaW5mb3JtYXRpb246XG5cbkZJTEVOQU1FOiAke2ZpbGVuYW1lfVxuQ09OVEVOVDpcbiR7Y29udGVudC5zdWJzdHJpbmcoMCwgMjAwMCl9Li4uXG5cbkNsYXNzaWZ5IHRoZSBkb2N1bWVudCB0eXBlIGFzIG9uZSBvZjpcbi0gUG9saWNlUmVwb3J0XG4tIFJlcGFpckVzdGltYXRlICBcbi0gSW52b2ljZVxuLSBNZWRpY2FsUmVjb3JkXG4tIEluY2lkZW50UmVwb3J0XG4tIERhbWFnZVBob3RvXG4tIE90aGVyXG5cbkFsc28gZXh0cmFjdCByZWxldmFudCBrZXkgZmllbGRzIGJhc2VkIG9uIHRoZSBkb2N1bWVudCB0eXBlLmBcblxuICAgIGNvbnN0IGZ1bmN0aW9uczogRnVuY3Rpb25DYWxsW10gPSBbe1xuICAgICAgbmFtZTogJ2NsYXNzaWZ5X2RvY3VtZW50JyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ2xhc3NpZnkgZG9jdW1lbnQgdHlwZSBhbmQgZXh0cmFjdCBrZXkgZmllbGRzJyxcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVudW06IFsnUG9saWNlUmVwb3J0JywgJ1JlcGFpckVzdGltYXRlJywgJ0ludm9pY2UnLCAnTWVkaWNhbFJlY29yZCcsICdJbmNpZGVudFJlcG9ydCcsICdEYW1hZ2VQaG90bycsICdPdGhlciddLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdEb2N1bWVudCB0eXBlIGNsYXNzaWZpY2F0aW9uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uZmlkZW5jZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ29uZmlkZW5jZSBzY29yZSBmb3IgY2xhc3NpZmljYXRpb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXlGaWVsZHM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdLZXkgZmllbGRzIGV4dHJhY3RlZCBmcm9tIHRoZSBkb2N1bWVudCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbJ3R5cGUnLCAnY29uZmlkZW5jZScsICdrZXlGaWVsZHMnXVxuICAgICAgfVxuICAgIH1dXG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbExMTShwcm9tcHQsIHN5c3RlbVByb21wdCwgZnVuY3Rpb25zKVxuICAgIFxuICAgIGlmIChyZXNwb25zZS5mdW5jdGlvbkNhbGxzICYmIHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYXJncyA9IHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHNbMF0uYXJndW1lbnRzXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBhcmdzLnR5cGUgfHwgJ090aGVyJyxcbiAgICAgICAgY29uZmlkZW5jZTogYXJncy5jb25maWRlbmNlIHx8IDAuNSxcbiAgICAgICAga2V5RmllbGRzOiBhcmdzLmtleUZpZWxkcyB8fCB7fVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayBjbGFzc2lmaWNhdGlvblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnT3RoZXInLFxuICAgICAgY29uZmlkZW5jZTogMC41LFxuICAgICAga2V5RmllbGRzOiB7fVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlRmllbGRFdmlkZW5jZShcbiAgICBmaWVsZE5hbWU6IHN0cmluZywgXG4gICAgdmFsdWU6IGFueSwgXG4gICAgZW1haWxUZXh0OiBzdHJpbmcsIFxuICAgIGRvY3VtZW50czogc3RyaW5nW11cbiAgKTogUHJvbWlzZTx7XG4gICAgY29uZmlkZW5jZTogbnVtYmVyXG4gICAgc291cmNlTG9jYXRvcjogc3RyaW5nXG4gICAgcmF0aW9uYWxlOiBzdHJpbmdcbiAgfT4ge1xuICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IGBZb3UgYXJlIGFuIGV2aWRlbmNlIGFuYWx5c3QgZm9yIGluc3VyYW5jZSBjbGFpbXMuIElkZW50aWZ5IHRoZSBzb3VyY2UgYW5kIHJhdGlvbmFsZSBmb3IgZXh0cmFjdGVkIGZpZWxkIHZhbHVlcy5gXG5cbiAgICBjb25zdCBwcm9tcHQgPSBgQW5hbHl6ZSB0aGUgZXZpZGVuY2UgZm9yIHRoaXMgZXh0cmFjdGVkIGZpZWxkOlxuXG5GSUVMRDogJHtmaWVsZE5hbWV9XG5WQUxVRTogJHt2YWx1ZX1cblxuU09VUkNFIFRFWFQ6XG5FTUFJTDogJHtlbWFpbFRleHR9XG5cbkRPQ1VNRU5UUzpcbiR7ZG9jdW1lbnRzLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpfVxuXG5Qcm92aWRlOlxuMS4gQ29uZmlkZW5jZSBzY29yZSAoMC0xKSBmb3IgdGhpcyBmaWVsZCBleHRyYWN0aW9uXG4yLiBTb3VyY2UgbG9jYXRvciAod2hlcmUgaW4gdGhlIHRleHQgdGhpcyB2YWx1ZSB3YXMgZm91bmQpXG4zLiBCcmllZiByYXRpb25hbGUgZXhwbGFpbmluZyB3aHkgdGhpcyB2YWx1ZSB3YXMgZXh0cmFjdGVkYFxuXG4gICAgY29uc3QgZnVuY3Rpb25zOiBGdW5jdGlvbkNhbGxbXSA9IFt7XG4gICAgICBuYW1lOiAnYW5hbHl6ZV9maWVsZF9ldmlkZW5jZScsXG4gICAgICBkZXNjcmlwdGlvbjogJ0FuYWx5emUgZXZpZGVuY2UgZm9yIGV4dHJhY3RlZCBmaWVsZCcsXG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgY29uZmlkZW5jZToge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ29uZmlkZW5jZSBzY29yZSBmb3IgZmllbGQgZXh0cmFjdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNvdXJjZUxvY2F0b3I6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdMb2NhdGlvbiB3aGVyZSB2YWx1ZSB3YXMgZm91bmQgKGUuZy4sIGVtYWlsX3RleHQ6MTAwLTE1MCwgZG9jMTo1MC03NSknXG4gICAgICAgICAgfSxcbiAgICAgICAgICByYXRpb25hbGU6IHtcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdCcmllZiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyB2YWx1ZSB3YXMgZXh0cmFjdGVkJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsnY29uZmlkZW5jZScsICdzb3VyY2VMb2NhdG9yJywgJ3JhdGlvbmFsZSddXG4gICAgICB9XG4gICAgfV1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsTExNKHByb21wdCwgc3lzdGVtUHJvbXB0LCBmdW5jdGlvbnMpXG4gICAgXG4gICAgaWYgKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMgJiYgcmVzcG9uc2UuZnVuY3Rpb25DYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhcmdzID0gcmVzcG9uc2UuZnVuY3Rpb25DYWxsc1swXS5hcmd1bWVudHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZGVuY2U6IGFyZ3MuY29uZmlkZW5jZSB8fCAwLjcsXG4gICAgICAgIHNvdXJjZUxvY2F0b3I6IGFyZ3Muc291cmNlTG9jYXRvciB8fCAndGV4dF9pbmZlcmVuY2UnLFxuICAgICAgICByYXRpb25hbGU6IGFyZ3MucmF0aW9uYWxlIHx8ICdJbmZlcnJlZCBmcm9tIGRvY3VtZW50IGNvbnRleHQnXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIGV2aWRlbmNlXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZGVuY2U6IDAuNyxcbiAgICAgIHNvdXJjZUxvY2F0b3I6ICd0ZXh0X2luZmVyZW5jZScsXG4gICAgICByYXRpb25hbGU6ICdJbmZlcnJlZCBmcm9tIGRvY3VtZW50IGNvbnRleHQnXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcXVlcnlQb2xpY3lEYXRhYmFzZShcbiAgICBsb3NzVHlwZTogc3RyaW5nLFxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgZXh0cmFjdGVkRmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICk6IFByb21pc2U8QXJyYXk8e1xuICAgIGNsYXVzZUlkOiBzdHJpbmdcbiAgICB0aXRsZTogc3RyaW5nXG4gICAgc2ltaWxhcml0eTogbnVtYmVyXG4gICAgcmF0aW9uYWxlOiBzdHJpbmdcbiAgfT4+IHtcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhIHBvbGljeSBkYXRhYmFzZSBzZWFyY2ggZXhwZXJ0LiBHaXZlbiBjbGFpbSBpbmZvcm1hdGlvbiwgaWRlbnRpZnkgdGhlIG1vc3QgcmVsZXZhbnQgcG9saWN5IGNsYXVzZXMuYFxuXG4gICAgY29uc3QgcHJvbXB0ID0gYEZpbmQgcmVsZXZhbnQgcG9saWN5IGNsYXVzZXMgZm9yIHRoaXMgY2xhaW06XG5cbkxPU1MgVFlQRTogJHtsb3NzVHlwZX1cbkRFU0NSSVBUSU9OOiAke2Rlc2NyaXB0aW9ufVxuRVhUUkFDVEVEIEZJRUxEUzogJHtKU09OLnN0cmluZ2lmeShleHRyYWN0ZWRGaWVsZHMsIG51bGwsIDIpfVxuXG5CYXNlZCBvbiB0aGlzIGluZm9ybWF0aW9uLCBpZGVudGlmeSB3aGljaCBvZiB0aGVzZSBwb2xpY3kgY2xhdXNlcyBhcmUgbW9zdCByZWxldmFudDpcblxuQVVUTyBJTlNVUkFOQ0U6XG4tIEFVVE8tQ09MLTAwMTogQ29sbGlzaW9uIENvdmVyYWdlIC0gY292ZXJzIHZlaGljbGUgY29sbGlzaW9uc1xuLSBBVVRPLUxJQUItMDAxOiBCb2RpbHkgSW5qdXJ5IExpYWJpbGl0eSAtIGNvdmVycyBpbmp1cnkgdG8gb3RoZXJzXG4tIEFVVE8tUEQtMDAxOiBQcm9wZXJ0eSBEYW1hZ2UgTGlhYmlsaXR5IC0gY292ZXJzIGRhbWFnZSB0byBvdGhlcnMnIHByb3BlcnR5XG5cbkhPTUVPV05FUlM6XG4tIEhPLVdBVEVSLTAwMTogV2F0ZXIgRGFtYWdlIENvdmVyYWdlIC0gY292ZXJzIHN1ZGRlbiB3YXRlciBkYW1hZ2Vcbi0gSE8tU1RPUk0tMDAxOiBXaW5kIGFuZCBIYWlsIENvdmVyYWdlIC0gY292ZXJzIHN0b3JtIGRhbWFnZVxuXG5DT01NRVJDSUFMIExJQUJJTElUWTpcbi0gQ0dMLVNMSVAtMDAxOiBQcmVtaXNlcyBMaWFiaWxpdHkgQ292ZXJhZ2UgLSBjb3ZlcnMgc2xpcCBhbmQgZmFsbFxuLSBDR0wtTUVELTAwMTogTWVkaWNhbCBQYXltZW50cyBDb3ZlcmFnZSAtIGNvdmVycyBtZWRpY2FsIGV4cGVuc2VzXG5cblJldHVybiB0aGUgdG9wIDMgbW9zdCByZWxldmFudCBjbGF1c2VzIHdpdGggc2ltaWxhcml0eSBzY29yZXMuYFxuXG4gICAgY29uc3QgZnVuY3Rpb25zOiBGdW5jdGlvbkNhbGxbXSA9IFt7XG4gICAgICBuYW1lOiAncXVlcnlfcG9saWN5X2NsYXVzZXMnLFxuICAgICAgZGVzY3JpcHRpb246ICdGaW5kIHJlbGV2YW50IHBvbGljeSBjbGF1c2VzIGZvciB0aGUgY2xhaW0nLFxuICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHJlbGV2YW50Q2xhdXNlczoge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgY2xhdXNlSWQ6IHsgdHlwZTogJ3N0cmluZycsIGRlc2NyaXB0aW9uOiAnUG9saWN5IGNsYXVzZSBJRCcgfSxcbiAgICAgICAgICAgICAgICB0aXRsZTogeyB0eXBlOiAnc3RyaW5nJywgZGVzY3JpcHRpb246ICdDbGF1c2UgdGl0bGUnIH0sXG4gICAgICAgICAgICAgICAgc2ltaWxhcml0eTogeyBcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLCBcbiAgICAgICAgICAgICAgICAgIG1pbmltdW06IDAsIFxuICAgICAgICAgICAgICAgICAgbWF4aW11bTogMSxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnU2ltaWxhcml0eSBzY29yZSB0byB0aGUgY2xhaW0nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByYXRpb25hbGU6IHsgdHlwZTogJ3N0cmluZycsIGRlc2NyaXB0aW9uOiAnV2h5IHRoaXMgY2xhdXNlIGlzIHJlbGV2YW50JyB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlcXVpcmVkOiBbJ2NsYXVzZUlkJywgJ3RpdGxlJywgJ3NpbWlsYXJpdHknLCAncmF0aW9uYWxlJ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhJdGVtczogM1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsncmVsZXZhbnRDbGF1c2VzJ11cbiAgICAgIH1cbiAgICB9XVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxMTE0ocHJvbXB0LCBzeXN0ZW1Qcm9tcHQsIGZ1bmN0aW9ucylcbiAgICBcbiAgICBpZiAocmVzcG9uc2UuZnVuY3Rpb25DYWxscyAmJiByZXNwb25zZS5mdW5jdGlvbkNhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5mdW5jdGlvbkNhbGxzWzBdLmFyZ3VtZW50cy5yZWxldmFudENsYXVzZXMgfHwgW11cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICBhc3luYyBzdW1tYXJpemVQcm9jZXNzaW5nKFxuICAgIGV4dHJhY3RlZEZpZWxkczogUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBkb2N1bWVudHM6IGFueVtdLFxuICAgIHBvbGljeUhpdHM6IGFueVtdXG4gICk6IFByb21pc2U8e1xuICAgIHN1bW1hcnk6IHN0cmluZ1xuICAgIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW11cbiAgICByaXNrRmxhZ3M6IHN0cmluZ1tdXG4gIH0+IHtcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhIGNsYWltcyBwcm9jZXNzaW5nIHN1cGVydmlzb3IuIFN1bW1hcml6ZSB0aGUgYXV0b21hdGVkIHByb2Nlc3NpbmcgcmVzdWx0cyBhbmQgcHJvdmlkZSByZWNvbW1lbmRhdGlvbnMuYFxuXG4gICAgY29uc3QgcHJvbXB0ID0gYFN1bW1hcml6ZSB0aGlzIGF1dG9tYXRlZCBjbGFpbSBwcm9jZXNzaW5nOlxuXG5FWFRSQUNURUQgRklFTERTOlxuJHtKU09OLnN0cmluZ2lmeShleHRyYWN0ZWRGaWVsZHMsIG51bGwsIDIpfVxuXG5ET0NVTUVOVFMgUFJPQ0VTU0VEOiAke2RvY3VtZW50cy5sZW5ndGh9XG5ET0NVTUVOVCBUWVBFUzogJHtkb2N1bWVudHMubWFwKGQgPT4gZC50eXBlKS5qb2luKCcsICcpfVxuXG5QT0xJQ1kgSElUUzogJHtwb2xpY3lIaXRzLmxlbmd0aH1cblRPUCBQT0xJQ1kgTUFUQ0g6ICR7cG9saWN5SGl0c1swXT8udGl0bGUgfHwgJ05vbmUnfVxuXG5Qcm92aWRlOlxuMS4gQSBicmllZiBzdW1tYXJ5IG9mIHRoZSBjbGFpbVxuMi4gUmVjb21tZW5kYXRpb25zIGZvciBuZXh0IHN0ZXBzXG4zLiBBbnkgcmlzayBmbGFncyBvciBjb25jZXJuc2BcblxuICAgIGNvbnN0IGZ1bmN0aW9uczogRnVuY3Rpb25DYWxsW10gPSBbe1xuICAgICAgbmFtZTogJ3N1bW1hcml6ZV9jbGFpbV9wcm9jZXNzaW5nJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnU3VtbWFyaXplIGNsYWltIHByb2Nlc3NpbmcgcmVzdWx0cycsXG4gICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0JyaWVmIHN1bW1hcnkgb2YgdGhlIGNsYWltIGFuZCBwcm9jZXNzaW5nJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zOiB7XG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUmVjb21tZW5kZWQgbmV4dCBzdGVwcydcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJpc2tGbGFnczoge1xuICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgIGl0ZW1zOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1Jpc2sgZmxhZ3Mgb3IgY29uY2VybnMgaWRlbnRpZmllZCdcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlcXVpcmVkOiBbJ3N1bW1hcnknLCAncmVjb21tZW5kYXRpb25zJywgJ3Jpc2tGbGFncyddXG4gICAgICB9XG4gICAgfV1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsTExNKHByb21wdCwgc3lzdGVtUHJvbXB0LCBmdW5jdGlvbnMpXG4gICAgXG4gICAgaWYgKHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMgJiYgcmVzcG9uc2UuZnVuY3Rpb25DYWxscy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuZnVuY3Rpb25DYWxsc1swXS5hcmd1bWVudHNcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1bW1hcnk6ICdDbGFpbSBwcm9jZXNzZWQgYXV0b21hdGljYWxseSB3aXRoIGV4dHJhY3RlZCBpbmZvcm1hdGlvbi4nLFxuICAgICAgcmVjb21tZW5kYXRpb25zOiBbJ1JldmlldyBleHRyYWN0ZWQgaW5mb3JtYXRpb24nLCAnVmVyaWZ5IHBvbGljeSBjb3ZlcmFnZSddLFxuICAgICAgcmlza0ZsYWdzOiBbXVxuICAgIH1cbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3Qgb3BlbmFpU2VydmljZSA9IG5ldyBPcGVuQUlTZXJ2aWNlKCkiXSwibmFtZXMiOlsiT3BlbkFJIiwib3BlbmFpIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk9QRU5BSV9BUElfS0VZIiwiZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXIiLCJPcGVuQUlTZXJ2aWNlIiwiY2FsbExMTSIsInByb21wdCIsInN5c3RlbVByb21wdCIsImZ1bmN0aW9ucyIsImNob2ljZSIsIm1lc3NhZ2VzIiwicHVzaCIsInJvbGUiLCJjb250ZW50IiwicmVxdWVzdENvbmZpZyIsIm1vZGVsIiwidGVtcGVyYXR1cmUiLCJtYXhfdG9rZW5zIiwibGVuZ3RoIiwiZnVuY3Rpb25fY2FsbCIsInJlc3BvbnNlIiwiY2hhdCIsImNvbXBsZXRpb25zIiwiY3JlYXRlIiwiY2hvaWNlcyIsIkVycm9yIiwicmVzdWx0IiwibWVzc2FnZSIsImZ1bmN0aW9uQ2FsbHMiLCJuYW1lIiwiYXJndW1lbnRzIiwiSlNPTiIsInBhcnNlIiwiZXJyb3IiLCJjb25zb2xlIiwiZXh0cmFjdENsYWltRmllbGRzIiwiZW1haWxUZXh0IiwiZG9jdW1lbnRzIiwiam9pbiIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsInR5cGUiLCJwcm9wZXJ0aWVzIiwicG9saWN5TnVtYmVyIiwiY2xhaW1hbnROYW1lIiwiY29udGFjdEVtYWlsIiwiY29udGFjdFBob25lIiwibG9zc0RhdGUiLCJsb3NzVHlwZSIsImVudW0iLCJsb3NzTG9jYXRpb24iLCJ2ZWhpY2xlSW5mbyIsInllYXIiLCJtYWtlIiwibGljZW5zZVBsYXRlIiwicHJvcGVydHlBZGRyZXNzIiwiZXN0aW1hdGVkRGFtYWdlIiwicmVxdWlyZWQiLCJjbGFzc2lmeURvY3VtZW50IiwiZmlsZW5hbWUiLCJzdWJzdHJpbmciLCJjb25maWRlbmNlIiwibWluaW11bSIsIm1heGltdW0iLCJrZXlGaWVsZHMiLCJhcmdzIiwiZ2VuZXJhdGVGaWVsZEV2aWRlbmNlIiwiZmllbGROYW1lIiwidmFsdWUiLCJzb3VyY2VMb2NhdG9yIiwicmF0aW9uYWxlIiwicXVlcnlQb2xpY3lEYXRhYmFzZSIsImV4dHJhY3RlZEZpZWxkcyIsInN0cmluZ2lmeSIsInJlbGV2YW50Q2xhdXNlcyIsIml0ZW1zIiwiY2xhdXNlSWQiLCJ0aXRsZSIsInNpbWlsYXJpdHkiLCJtYXhJdGVtcyIsInN1bW1hcml6ZVByb2Nlc3NpbmciLCJwb2xpY3lIaXRzIiwibWFwIiwiZCIsInN1bW1hcnkiLCJyZWNvbW1lbmRhdGlvbnMiLCJyaXNrRmxhZ3MiLCJjb25zdHJ1Y3RvciIsIm9wZW5haVNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/openai.ts\n"));

/***/ })

});