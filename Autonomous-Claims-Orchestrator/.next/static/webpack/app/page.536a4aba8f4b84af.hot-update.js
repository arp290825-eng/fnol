"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/agents/nodes/assemblerAgent.ts":
/*!********************************************!*\
  !*** ./lib/agents/nodes/assemblerAgent.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssemblerAgent: function() { return /* binding */ AssemblerAgent; }\n/* harmony export */ });\nclass AssemblerAgent {\n    async execute(state, config) {\n        const startTime = Date.now();\n        try {\n            // Create the final claim data structure\n            const claimData = await this.assembleClaimData(state);\n            const duration = Date.now() - startTime;\n            return {\n                currentStep: \"Review\",\n                claimData,\n                auditEvents: [\n                    ...state.auditEvents,\n                    {\n                        step: \"assembly\",\n                        timestamp: new Date().toISOString(),\n                        duration,\n                        agent: \"AssemblerAgent\",\n                        status: \"completed\",\n                        details: {\n                            fieldsAssembled: Object.keys(state.extractedFields).length,\n                            documentsProcessed: state.documents.length,\n                            policyHitsIncluded: state.policyHits.length,\n                            totalProcessingTime: Date.now() - state.startTime\n                        }\n                    }\n                ]\n            };\n        } catch (error) {\n            const duration = Date.now() - startTime;\n            return {\n                errors: [\n                    ...state.errors,\n                    \"Assembly failed: \".concat(error)\n                ],\n                auditEvents: [\n                    ...state.auditEvents,\n                    {\n                        step: \"assembly\",\n                        timestamp: new Date().toISOString(),\n                        duration,\n                        agent: \"AssemblerAgent\",\n                        status: \"failed\",\n                        details: {\n                            error: String(error)\n                        }\n                    }\n                ]\n            };\n        }\n    }\n    async assembleClaimData(state) {\n        // Create claim draft\n        const claimDraft = this.createClaimDraft(state.extractedFields, state.documents);\n        // Assemble decision pack\n        const decisionPack = this.createDecisionPack(claimDraft, state.fieldEvidence, state.documents, state.policyHits, state.auditEvents);\n        // Calculate processing metrics\n        const processingMetrics = this.calculateProcessingMetrics(state);\n        return {\n            claimId: this.generateClaimId(),\n            decisionPack: {\n                ...decisionPack,\n                claimDraft,\n                evidence: state.fieldEvidence,\n                documents: state.documents,\n                policyGrounding: state.policyHits,\n                audit: state.auditEvents\n            },\n            auditTrail: state.auditEvents,\n            processingMetrics,\n            createdAt: new Date().toISOString(),\n            status: \"draft\"\n        };\n    }\n    createClaimDraft(extractedFields, documents) {\n        return {\n            id: this.generateDraftId(),\n            policyNumber: this.sanitizePolicyNumber(extractedFields.policyNumber),\n            claimantName: extractedFields.claimantName || \"Unknown\",\n            contactEmail: this.maskEmail(extractedFields.contactEmail),\n            contactPhone: this.maskPhone(extractedFields.contactPhone),\n            lossDate: this.formatDate(extractedFields.lossDate),\n            lossType: extractedFields.lossType || \"Other\",\n            lossLocation: extractedFields.lossLocation || \"Not specified\",\n            description: extractedFields.description || \"Claim details extracted from submitted documents\",\n            estimatedAmount: extractedFields.estimatedDamage || null,\n            // Vehicle-specific fields\n            vehicleInfo: extractedFields.vehicleInfo || null,\n            // Property-specific fields  \n            propertyAddress: extractedFields.propertyAddress || null,\n            // Attachments reference\n            attachments: documents.map((doc)=>({\n                    id: doc.id,\n                    name: doc.name,\n                    mimeType: doc.mimeType || \"application/octet-stream\",\n                    type: doc.type,\n                    confidence: doc.confidence\n                })),\n            // Coverage assessment\n            coverageFound: this.assessCoverage(extractedFields),\n            deductible: this.determineDeductible(extractedFields),\n            // Metadata\n            createdAt: new Date().toISOString(),\n            source: \"automated_extraction\",\n            confidence: this.calculateOverallConfidence(extractedFields)\n        };\n    }\n    createDecisionPack(claimDraft, evidence, documents, policyHits, auditEvents) {\n        return {\n            id: this.generateDecisionPackId(),\n            claimDraft,\n            evidence,\n            documents,\n            policyGrounding: policyHits,\n            audit: auditEvents,\n            // Evidence summary\n            evidenceSummary: {\n                totalFields: evidence.length,\n                highConfidenceFields: evidence.filter((e)=>e.confidence >= 0.8).length,\n                lowConfidenceFields: evidence.filter((e)=>e.confidence < 0.6).length,\n                avgConfidence: evidence.reduce((sum, e)=>sum + e.confidence, 0) / evidence.length\n            },\n            // Document analysis\n            documentAnalysis: {\n                totalDocuments: documents.length,\n                documentTypes: [\n                    ...new Set(documents.map((d)=>d.type))\n                ],\n                avgDocumentConfidence: documents.reduce((sum, d)=>sum + d.confidence, 0) / documents.length,\n                missingDocuments: this.identifyMissingDocuments(claimDraft.lossType, documents)\n            },\n            // Policy assessment\n            policyAssessment: {\n                clausesFound: policyHits.length,\n                coverageConfirmed: policyHits.length > 0,\n                topSimilarityScore: policyHits.length > 0 ? Math.max(...policyHits.map((h)=>h.similarity)) : 0,\n                recommendedActions: this.generateRecommendations(claimDraft, policyHits, evidence)\n            },\n            // Processing summary\n            processingSummary: {\n                totalTime: auditEvents.length > 0 ? auditEvents.reduce((sum, e)=>sum + e.duration, 0) : 0,\n                stepsCompleted: auditEvents.filter((e)=>e.status === \"completed\").length,\n                stepsWithErrors: auditEvents.filter((e)=>e.status === \"failed\").length,\n                automationLevel: this.calculateAutomationLevel(evidence)\n            },\n            createdAt: new Date().toISOString()\n        };\n    }\n    calculateProcessingMetrics(state) {\n        const totalTime = Date.now() - state.startTime;\n        const completedSteps = state.auditEvents.filter((e)=>e.status === \"completed\").length;\n        const failedSteps = state.auditEvents.filter((e)=>e.status === \"failed\").length;\n        return {\n            totalProcessingTime: totalTime,\n            averageHandleTime: totalTime / 60000,\n            fieldsAutoPopulated: Object.keys(state.extractedFields).filter((key)=>state.extractedFields[key] !== null && state.extractedFields[key] !== undefined).length,\n            overrideRate: 0,\n            ragHitRate: state.policyHits.length > 0 ? 1 : 0,\n            stepsCompleted: completedSteps,\n            stepsFailed: failedSteps,\n            successRate: completedSteps / (completedSteps + failedSteps)\n        };\n    }\n    // Utility methods\n    generateClaimId() {\n        return \"CLM-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 6).toUpperCase());\n    }\n    generateDraftId() {\n        return \"DRAFT-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 4).toUpperCase());\n    }\n    generateDecisionPackId() {\n        return \"DP-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 8).toUpperCase());\n    }\n    sanitizePolicyNumber(policyNumber) {\n        if (!policyNumber) return \"Unknown\";\n        // Mask policy number for privacy (show only last 3 digits)\n        return policyNumber.length > 3 ? \"*\".repeat(policyNumber.length - 3) + policyNumber.slice(-3) : policyNumber;\n    }\n    maskEmail(email) {\n        if (!email) return \"\";\n        const [username, domain] = email.split(\"@\");\n        if (!domain) return email;\n        const maskedUsername = username.length > 4 ? username.substring(0, 2) + \"*\".repeat(username.length - 4) + username.slice(-2) : username;\n        return \"\".concat(maskedUsername, \"@\").concat(domain);\n    }\n    maskPhone(phone) {\n        if (!phone) return \"\";\n        // Show only last 4 digits\n        const digits = phone.replace(/\\D/g, \"\");\n        return digits.length > 4 ? \"*\".repeat(digits.length - 4) + digits.slice(-4) : phone;\n    }\n    formatDate(dateStr) {\n        if (!dateStr) return \"\";\n        try {\n            const date = new Date(dateStr);\n            return date.toISOString().split(\"T\")[0] // YYYY-MM-DD format\n            ;\n        } catch (e) {\n            return dateStr // Return original if parsing fails\n            ;\n        }\n    }\n    assessCoverage(extractedFields) {\n        // Simple coverage assessment based on policy number presence\n        return !!extractedFields.policyNumber;\n    }\n    determineDeductible(extractedFields) {\n        // Default deductibles based on loss type\n        const lossType = extractedFields.lossType;\n        const defaultDeductibles = {\n            \"Collision\": 500,\n            \"Water\": 1000,\n            \"Wind\": 1000,\n            \"Liability\": 0\n        };\n        return defaultDeductibles[lossType] || undefined;\n    }\n    calculateOverallConfidence(extractedFields) {\n        const fields = Object.values(extractedFields).filter((v)=>v !== null && v !== undefined);\n        const requiredFields = [\n            \"policyNumber\",\n            \"claimantName\",\n            \"lossDate\",\n            \"lossType\"\n        ];\n        const presentRequired = requiredFields.filter((field)=>extractedFields[field]).length;\n        return presentRequired / requiredFields.length * 0.6 + fields.length / 10 * 0.4;\n    }\n    identifyMissingDocuments(lossType, documents) {\n        const presentTypes = new Set(documents.map((d)=>d.type));\n        const expectedDocuments = {\n            \"Collision\": [\n                \"PoliceReport\",\n                \"RepairEstimate\",\n                \"DamagePhoto\"\n            ],\n            \"Water\": [\n                \"DamagePhoto\",\n                \"RepairEstimate\"\n            ],\n            \"Liability\": [\n                \"IncidentReport\",\n                \"MedicalRecord\"\n            ],\n            \"Fire\": [\n                \"DamagePhoto\",\n                \"RepairEstimate\",\n                \"FireReport\"\n            ],\n            \"Theft\": [\n                \"PoliceReport\",\n                \"ItemList\"\n            ]\n        };\n        const expected = expectedDocuments[lossType] || [];\n        return expected.filter((docType)=>!presentTypes.has(docType));\n    }\n    generateRecommendations(claimDraft, policyHits, evidence) {\n        const recommendations = [];\n        // Coverage recommendations\n        if (policyHits.length === 0) {\n            recommendations.push(\"No matching policy clauses found - review coverage manually\");\n        } else if (policyHits[0].similarity < 0.8) {\n            recommendations.push(\"Low policy match confidence - adjuster review recommended\");\n        }\n        // Evidence recommendations\n        const lowConfidenceFields = evidence.filter((e)=>e.confidence < 0.6);\n        if (lowConfidenceFields.length > 0) {\n            recommendations.push(\"\".concat(lowConfidenceFields.length, \" fields need manual verification\"));\n        }\n        // Amount recommendations\n        if (claimDraft.estimatedAmount && claimDraft.estimatedAmount > 10000) {\n            recommendations.push(\"High-value claim - senior adjuster review required\");\n        }\n        // Document recommendations\n        if (!claimDraft.attachments.some((a)=>a.type === \"DamagePhoto\")) {\n            recommendations.push(\"Damage photos recommended for claim validation\");\n        }\n        return recommendations;\n    }\n    calculateAutomationLevel(evidence) {\n        const highConfidenceFields = evidence.filter((e)=>e.confidence >= 0.8).length;\n        return evidence.length > 0 ? highConfidenceFields / evidence.length : 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hZ2VudHMvbm9kZXMvYXNzZW1ibGVyQWdlbnQudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUdPLE1BQU1BO0lBQ1gsTUFBTUMsUUFBUUMsS0FBaUIsRUFBRUMsTUFBbUIsRUFBZ0M7UUFDbEYsTUFBTUMsWUFBWUMsS0FBS0MsR0FBRztRQUUxQixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU1DLFlBQVksTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDTjtZQUUvQyxNQUFNTyxXQUFXSixLQUFLQyxHQUFHLEtBQUtGO1lBRTlCLE9BQU87Z0JBQ0xNLGFBQWE7Z0JBQ2JIO2dCQUNBSSxhQUFhO3VCQUFJVCxNQUFNUyxXQUFXO29CQUFFO3dCQUNsQ0MsTUFBTTt3QkFDTkMsV0FBVyxJQUFJUixPQUFPUyxXQUFXO3dCQUNqQ0w7d0JBQ0FNLE9BQU87d0JBQ1BDLFFBQVE7d0JBQ1JDLFNBQVM7NEJBQ1BDLGlCQUFpQkMsT0FBT0MsSUFBSSxDQUFDbEIsTUFBTW1CLGVBQWUsRUFBRUMsTUFBTTs0QkFDMURDLG9CQUFvQnJCLE1BQU1zQixTQUFTLENBQUNGLE1BQU07NEJBQzFDRyxvQkFBb0J2QixNQUFNd0IsVUFBVSxDQUFDSixNQUFNOzRCQUMzQ0sscUJBQXFCdEIsS0FBS0MsR0FBRyxLQUFLSixNQUFNRSxTQUFTO3dCQUNuRDtvQkFDRjtpQkFBRTtZQUNKO1FBQ0YsRUFBRSxPQUFPd0IsT0FBTztZQUNkLE1BQU1uQixXQUFXSixLQUFLQyxHQUFHLEtBQUtGO1lBRTlCLE9BQU87Z0JBQ0x5QixRQUFRO3VCQUFJM0IsTUFBTTJCLE1BQU07b0JBQUcsb0JBQXlCLE9BQU5EO2lCQUFRO2dCQUN0RGpCLGFBQWE7dUJBQUlULE1BQU1TLFdBQVc7b0JBQUU7d0JBQ2xDQyxNQUFNO3dCQUNOQyxXQUFXLElBQUlSLE9BQU9TLFdBQVc7d0JBQ2pDTDt3QkFDQU0sT0FBTzt3QkFDUEMsUUFBUTt3QkFDUkMsU0FBUzs0QkFBRVcsT0FBT0Us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QUlTLFdBQVc0QixlQUFlLElBQUk1QixXQUFXNEIsZUFBZSxHQUFHLE9BQU87WUFDcEUwRixnQkFBZ0JDLElBQUksQ0FBQztRQUN2QjtRQUVBLDJCQUEyQjtRQUMzQixJQUFJLENBQUN2SCxXQUFXZ0MsV0FBVyxDQUFDd0YsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFcEYsSUFBSSxLQUFLLGdCQUFnQjtZQUMvRGlGLGdCQUFnQkMsSUFBSSxDQUFDO1FBQ3ZCO1FBRUEsT0FBT0Q7SUFDVDtJQUVReEMseUJBQXlCckUsUUFBZSxFQUFVO1FBQ3hELE1BQU11Qyx1QkFBdUJ2QyxTQUFTd0MsTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFWixVQUFVLElBQUksS0FBSy9DLE1BQU07UUFDN0UsT0FBT2tCLFNBQVNsQixNQUFNLEdBQUcsSUFBSXlELHVCQUF1QnZDLFNBQVNsQixNQUFNLEdBQUc7SUFDeEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvYWdlbnRzL25vZGVzL2Fzc2VtYmxlckFnZW50LnRzPzhiNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWdlbnRTdGF0ZSwgQWdlbnRDb25maWcgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IENsYWltRGF0YSwgRGVjaXNpb25QYWNrLCBDbGFpbURyYWZ0IH0gZnJvbSAnQC90eXBlcy9jbGFpbXMnXG5cbmV4cG9ydCBjbGFzcyBBc3NlbWJsZXJBZ2VudCB7XG4gIGFzeW5jIGV4ZWN1dGUoc3RhdGU6IEFnZW50U3RhdGUsIGNvbmZpZzogQWdlbnRDb25maWcpOiBQcm9taXNlPFBhcnRpYWw8QWdlbnRTdGF0ZT4+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgZmluYWwgY2xhaW0gZGF0YSBzdHJ1Y3R1cmVcbiAgICAgIGNvbnN0IGNsYWltRGF0YSA9IGF3YWl0IHRoaXMuYXNzZW1ibGVDbGFpbURhdGEoc3RhdGUpXG4gICAgICBcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50U3RlcDogJ1JldmlldycsXG4gICAgICAgIGNsYWltRGF0YSxcbiAgICAgICAgYXVkaXRFdmVudHM6IFsuLi5zdGF0ZS5hdWRpdEV2ZW50cywge1xuICAgICAgICAgIHN0ZXA6ICdhc3NlbWJseScsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgYWdlbnQ6ICdBc3NlbWJsZXJBZ2VudCcsXG4gICAgICAgICAgc3RhdHVzOiAnY29tcGxldGVkJyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBmaWVsZHNBc3NlbWJsZWQ6IE9iamVjdC5rZXlzKHN0YXRlLmV4dHJhY3RlZEZpZWxkcykubGVuZ3RoLFxuICAgICAgICAgICAgZG9jdW1lbnRzUHJvY2Vzc2VkOiBzdGF0ZS5kb2N1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgcG9saWN5SGl0c0luY2x1ZGVkOiBzdGF0ZS5wb2xpY3lIaXRzLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUHJvY2Vzc2luZ1RpbWU6IERhdGUubm93KCkgLSBzdGF0ZS5zdGFydFRpbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZVxuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcnM6IFsuLi5zdGF0ZS5lcnJvcnMsIGBBc3NlbWJseSBmYWlsZWQ6ICR7ZXJyb3J9YF0sXG4gICAgICAgIGF1ZGl0RXZlbnRzOiBbLi4uc3RhdGUuYXVkaXRFdmVudHMsIHtcbiAgICAgICAgICBzdGVwOiAnYXNzZW1ibHknLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgIGFnZW50OiAnQXNzZW1ibGVyQWdlbnQnLFxuICAgICAgICAgIHN0YXR1czogJ2ZhaWxlZCcsXG4gICAgICAgICAgZGV0YWlsczogeyBlcnJvcjogU3RyaW5nKGVycm9yKSB9XG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhc3NlbWJsZUNsYWltRGF0YShzdGF0ZTogQWdlbnRTdGF0ZSk6IFByb21pc2U8Q2xhaW1EYXRhPiB7XG4gICAgLy8gQ3JlYXRlIGNsYWltIGRyYWZ0XG4gICAgY29uc3QgY2xhaW1EcmFmdCA9IHRoaXMuY3JlYXRlQ2xhaW1EcmFmdChzdGF0ZS5leHRyYWN0ZWRGaWVsZHMsIHN0YXRlLmRvY3VtZW50cylcbiAgICBcbiAgICAvLyBBc3NlbWJsZSBkZWNpc2lvbiBwYWNrXG4gICAgY29uc3QgZGVjaXNpb25QYWNrID0gdGhpcy5jcmVhdGVEZWNpc2lvblBhY2soXG4gICAgICBjbGFpbURyYWZ0LFxuICAgICAgc3RhdGUuZmllbGRFdmlkZW5jZSxcbiAgICAgIHN0YXRlLmRvY3VtZW50cyxcbiAgICAgIHN0YXRlLnBvbGljeUhpdHMsXG4gICAgICBzdGF0ZS5hdWRpdEV2ZW50c1xuICAgIClcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcHJvY2Vzc2luZyBtZXRyaWNzXG4gICAgY29uc3QgcHJvY2Vzc2luZ01ldHJpY3MgPSB0aGlzLmNhbGN1bGF0ZVByb2Nlc3NpbmdNZXRyaWNzKHN0YXRlKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBjbGFpbUlkOiB0aGlzLmdlbmVyYXRlQ2xhaW1JZCgpLFxuICAgICAgZGVjaXNpb25QYWNrOiB7XG4gICAgICAgIC4uLmRlY2lzaW9uUGFjayxcbiAgICAgICAgY2xhaW1EcmFmdCxcbiAgICAgICAgZXZpZGVuY2U6IHN0YXRlLmZpZWxkRXZpZGVuY2UsXG4gICAgICAgIGRvY3VtZW50czogc3RhdGUuZG9jdW1lbnRzLFxuICAgICAgICBwb2xpY3lHcm91bmRpbmc6IHN0YXRlLnBvbGljeUhpdHMsXG4gICAgICAgIGF1ZGl0OiBzdGF0ZS5hdWRpdEV2ZW50c1xuICAgICAgfSxcbiAgICAgIGF1ZGl0VHJhaWw6IHN0YXRlLmF1ZGl0RXZlbnRzLFxuICAgICAgcHJvY2Vzc2luZ01ldHJpY3MsXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHN0YXR1czogJ2RyYWZ0J1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQ2xhaW1EcmFmdChleHRyYWN0ZWRGaWVsZHM6IFJlY29yZDxzdHJpbmcsIGFueT4sIGRvY3VtZW50czogYW55W10pOiBDbGFpbURyYWZ0IHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVEcmFmdElkKCksXG4gICAgICBwb2xpY3lOdW1iZXI6IHRoaXMuc2FuaXRpemVQb2xpY3lOdW1iZXIoZXh0cmFjdGVkRmllbGRzLnBvbGljeU51bWJlciksXG4gICAgICBjbGFpbWFudE5hbWU6IGV4dHJhY3RlZEZpZWxkcy5jbGFpbWFudE5hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgY29udGFjdEVtYWlsOiB0aGlzLm1hc2tFbWFpbChleHRyYWN0ZWRGaWVsZHMuY29udGFjdEVtYWlsKSxcbiAgICAgIGNvbnRhY3RQaG9uZTogdGhpcy5tYXNrUGhvbmUoZXh0cmFjdGVkRmllbGRzLmNvbnRhY3RQaG9uZSksXG4gICAgICBsb3NzRGF0ZTogdGhpcy5mb3JtYXREYXRlKGV4dHJhY3RlZEZpZWxkcy5sb3NzRGF0ZSksXG4gICAgICBsb3NzVHlwZTogZXh0cmFjdGVkRmllbGRzLmxvc3NUeXBlIHx8ICdPdGhlcicsXG4gICAgICBsb3NzTG9jYXRpb246IGV4dHJhY3RlZEZpZWxkcy5sb3NzTG9jYXRpb24gfHwgJ05vdCBzcGVjaWZpZWQnLFxuICAgICAgZGVzY3JpcHRpb246IGV4dHJhY3RlZEZpZWxkcy5kZXNjcmlwdGlvbiB8fCAnQ2xhaW0gZGV0YWlscyBleHRyYWN0ZWQgZnJvbSBzdWJtaXR0ZWQgZG9jdW1lbnRzJyxcbiAgICAgIGVzdGltYXRlZEFtb3VudDogZXh0cmFjdGVkRmllbGRzLmVzdGltYXRlZERhbWFnZSB8fCBudWxsLFxuICAgICAgXG4gICAgICAvLyBWZWhpY2xlLXNwZWNpZmljIGZpZWxkc1xuICAgICAgdmVoaWNsZUluZm86IGV4dHJhY3RlZEZpZWxkcy52ZWhpY2xlSW5mbyB8fCBudWxsLFxuICAgICAgXG4gICAgICAvLyBQcm9wZXJ0eS1zcGVjaWZpYyBmaWVsZHMgIFxuICAgICAgcHJvcGVydHlBZGRyZXNzOiBleHRyYWN0ZWRGaWVsZHMucHJvcGVydHlBZGRyZXNzIHx8IG51bGwsXG4gICAgICBcbiAgICAgIC8vIEF0dGFjaG1lbnRzIHJlZmVyZW5jZVxuICAgICAgYXR0YWNobWVudHM6IGRvY3VtZW50cy5tYXAoZG9jID0+ICh7XG4gICAgICAgIGlkOiBkb2MuaWQsXG4gICAgICAgIG5hbWU6IGRvYy5uYW1lLFxuICAgICAgICBtaW1lVHlwZTogZG9jLm1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICB0eXBlOiBkb2MudHlwZSxcbiAgICAgICAgY29uZmlkZW5jZTogZG9jLmNvbmZpZGVuY2VcbiAgICAgIH0pKSxcbiAgICAgIFxuICAgICAgLy8gQ292ZXJhZ2UgYXNzZXNzbWVudFxuICAgICAgY292ZXJhZ2VGb3VuZDogdGhpcy5hc3Nlc3NDb3ZlcmFnZShleHRyYWN0ZWRGaWVsZHMpLFxuICAgICAgZGVkdWN0aWJsZTogdGhpcy5kZXRlcm1pbmVEZWR1Y3RpYmxlKGV4dHJhY3RlZEZpZWxkcyksXG4gICAgICBcbiAgICAgIC8vIE1ldGFkYXRhXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHNvdXJjZTogJ2F1dG9tYXRlZF9leHRyYWN0aW9uJyxcbiAgICAgIGNvbmZpZGVuY2U6IHRoaXMuY2FsY3VsYXRlT3ZlcmFsbENvbmZpZGVuY2UoZXh0cmFjdGVkRmllbGRzKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGVjaXNpb25QYWNrKFxuICAgIGNsYWltRHJhZnQ6IENsYWltRHJhZnQsXG4gICAgZXZpZGVuY2U6IGFueVtdLFxuICAgIGRvY3VtZW50czogYW55W10sXG4gICAgcG9saWN5SGl0czogYW55W10sXG4gICAgYXVkaXRFdmVudHM6IGFueVtdXG4gICk6IERlY2lzaW9uUGFjayB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiB0aGlzLmdlbmVyYXRlRGVjaXNpb25QYWNrSWQoKSxcbiAgICAgIGNsYWltRHJhZnQsXG4gICAgICBldmlkZW5jZSxcbiAgICAgIGRvY3VtZW50cyxcbiAgICAgIHBvbGljeUdyb3VuZGluZzogcG9saWN5SGl0cyxcbiAgICAgIGF1ZGl0OiBhdWRpdEV2ZW50cyxcbiAgICAgIFxuICAgICAgLy8gRXZpZGVuY2Ugc3VtbWFyeVxuICAgICAgZXZpZGVuY2VTdW1tYXJ5OiB7XG4gICAgICAgIHRvdGFsRmllbGRzOiBldmlkZW5jZS5sZW5ndGgsXG4gICAgICAgIGhpZ2hDb25maWRlbmNlRmllbGRzOiBldmlkZW5jZS5maWx0ZXIoZSA9PiBlLmNvbmZpZGVuY2UgPj0gMC44KS5sZW5ndGgsXG4gICAgICAgIGxvd0NvbmZpZGVuY2VGaWVsZHM6IGV2aWRlbmNlLmZpbHRlcihlID0+IGUuY29uZmlkZW5jZSA8IDAuNikubGVuZ3RoLFxuICAgICAgICBhdmdDb25maWRlbmNlOiBldmlkZW5jZS5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgZS5jb25maWRlbmNlLCAwKSAvIGV2aWRlbmNlLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gRG9jdW1lbnQgYW5hbHlzaXNcbiAgICAgIGRvY3VtZW50QW5hbHlzaXM6IHtcbiAgICAgICAgdG90YWxEb2N1bWVudHM6IGRvY3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRvY3VtZW50VHlwZXM6IFsuLi5uZXcgU2V0KGRvY3VtZW50cy5tYXAoZCA9PiBkLnR5cGUpKV0sXG4gICAgICAgIGF2Z0RvY3VtZW50Q29uZmlkZW5jZTogZG9jdW1lbnRzLnJlZHVjZSgoc3VtLCBkKSA9PiBzdW0gKyBkLmNvbmZpZGVuY2UsIDApIC8gZG9jdW1lbnRzLmxlbmd0aCxcbiAgICAgICAgbWlzc2luZ0RvY3VtZW50czogdGhpcy5pZGVudGlmeU1pc3NpbmdEb2N1bWVudHMoY2xhaW1EcmFmdC5sb3NzVHlwZSwgZG9jdW1lbnRzKVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gUG9saWN5IGFzc2Vzc21lbnRcbiAgICAgIHBvbGljeUFzc2Vzc21lbnQ6IHtcbiAgICAgICAgY2xhdXNlc0ZvdW5kOiBwb2xpY3lIaXRzLmxlbmd0aCxcbiAgICAgICAgY292ZXJhZ2VDb25maXJtZWQ6IHBvbGljeUhpdHMubGVuZ3RoID4gMCxcbiAgICAgICAgdG9wU2ltaWxhcml0eVNjb3JlOiBwb2xpY3lIaXRzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5wb2xpY3lIaXRzLm1hcChoID0+IGguc2ltaWxhcml0eSkpIDogMCxcbiAgICAgICAgcmVjb21tZW5kZWRBY3Rpb25zOiB0aGlzLmdlbmVyYXRlUmVjb21tZW5kYXRpb25zKGNsYWltRHJhZnQsIHBvbGljeUhpdHMsIGV2aWRlbmNlKVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gUHJvY2Vzc2luZyBzdW1tYXJ5XG4gICAgICBwcm9jZXNzaW5nU3VtbWFyeToge1xuICAgICAgICB0b3RhbFRpbWU6IGF1ZGl0RXZlbnRzLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgICBhdWRpdEV2ZW50cy5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgZS5kdXJhdGlvbiwgMCkgOiAwLFxuICAgICAgICBzdGVwc0NvbXBsZXRlZDogYXVkaXRFdmVudHMuZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKS5sZW5ndGgsXG4gICAgICAgIHN0ZXBzV2l0aEVycm9yczogYXVkaXRFdmVudHMuZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdmYWlsZWQnKS5sZW5ndGgsXG4gICAgICAgIGF1dG9tYXRpb25MZXZlbDogdGhpcy5jYWxjdWxhdGVBdXRvbWF0aW9uTGV2ZWwoZXZpZGVuY2UpXG4gICAgICB9LFxuICAgICAgXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUHJvY2Vzc2luZ01ldHJpY3Moc3RhdGU6IEFnZW50U3RhdGUpOiBhbnkge1xuICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGF0ZS5zdGFydFRpbWVcbiAgICBjb25zdCBjb21wbGV0ZWRTdGVwcyA9IHN0YXRlLmF1ZGl0RXZlbnRzLmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAnY29tcGxldGVkJykubGVuZ3RoXG4gICAgY29uc3QgZmFpbGVkU3RlcHMgPSBzdGF0ZS5hdWRpdEV2ZW50cy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ2ZhaWxlZCcpLmxlbmd0aFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFByb2Nlc3NpbmdUaW1lOiB0b3RhbFRpbWUsXG4gICAgICBhdmVyYWdlSGFuZGxlVGltZTogdG90YWxUaW1lIC8gNjAwMDAsIC8vIGluIG1pbnV0ZXNcbiAgICAgIGZpZWxkc0F1dG9Qb3B1bGF0ZWQ6IE9iamVjdC5rZXlzKHN0YXRlLmV4dHJhY3RlZEZpZWxkcykuZmlsdGVyKGtleSA9PiBcbiAgICAgICAgc3RhdGUuZXh0cmFjdGVkRmllbGRzW2tleV0gIT09IG51bGwgJiYgc3RhdGUuZXh0cmFjdGVkRmllbGRzW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICAgKS5sZW5ndGgsXG4gICAgICBvdmVycmlkZVJhdGU6IDAsIC8vIFdvdWxkIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gbWFudWFsIGNvcnJlY3Rpb25zXG4gICAgICByYWdIaXRSYXRlOiBzdGF0ZS5wb2xpY3lIaXRzLmxlbmd0aCA+IDAgPyAxIDogMCxcbiAgICAgIHN0ZXBzQ29tcGxldGVkOiBjb21wbGV0ZWRTdGVwcyxcbiAgICAgIHN0ZXBzRmFpbGVkOiBmYWlsZWRTdGVwcyxcbiAgICAgIHN1Y2Nlc3NSYXRlOiBjb21wbGV0ZWRTdGVwcyAvIChjb21wbGV0ZWRTdGVwcyArIGZhaWxlZFN0ZXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBwcml2YXRlIGdlbmVyYXRlQ2xhaW1JZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgQ0xNLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNikudG9VcHBlckNhc2UoKX1gXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlRHJhZnRJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgRFJBRlQtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA0KS50b1VwcGVyQ2FzZSgpfWBcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVEZWNpc2lvblBhY2tJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgRFAtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KS50b1VwcGVyQ2FzZSgpfWBcbiAgfVxuXG4gIHByaXZhdGUgc2FuaXRpemVQb2xpY3lOdW1iZXIocG9saWN5TnVtYmVyOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nIHtcbiAgICBpZiAoIXBvbGljeU51bWJlcikgcmV0dXJuICdVbmtub3duJ1xuICAgIC8vIE1hc2sgcG9saWN5IG51bWJlciBmb3IgcHJpdmFjeSAoc2hvdyBvbmx5IGxhc3QgMyBkaWdpdHMpXG4gICAgcmV0dXJuIHBvbGljeU51bWJlci5sZW5ndGggPiAzID8gXG4gICAgICAnKicucmVwZWF0KHBvbGljeU51bWJlci5sZW5ndGggLSAzKSArIHBvbGljeU51bWJlci5zbGljZSgtMykgOlxuICAgICAgcG9saWN5TnVtYmVyXG4gIH1cblxuICBwcml2YXRlIG1hc2tFbWFpbChlbWFpbDogc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgaWYgKCFlbWFpbCkgcmV0dXJuICcnXG4gICAgY29uc3QgW3VzZXJuYW1lLCBkb21haW5dID0gZW1haWwuc3BsaXQoJ0AnKVxuICAgIGlmICghZG9tYWluKSByZXR1cm4gZW1haWxcbiAgICBcbiAgICBjb25zdCBtYXNrZWRVc2VybmFtZSA9IHVzZXJuYW1lLmxlbmd0aCA+IDQgP1xuICAgICAgdXNlcm5hbWUuc3Vic3RyaW5nKDAsIDIpICsgJyonLnJlcGVhdCh1c2VybmFtZS5sZW5ndGggLSA0KSArIHVzZXJuYW1lLnNsaWNlKC0yKSA6XG4gICAgICB1c2VybmFtZVxuICAgIFxuICAgIHJldHVybiBgJHttYXNrZWRVc2VybmFtZX1AJHtkb21haW59YFxuICB9XG5cbiAgcHJpdmF0ZSBtYXNrUGhvbmUocGhvbmU6IHN0cmluZyB8IG51bGwpOiBzdHJpbmcge1xuICAgIGlmICghcGhvbmUpIHJldHVybiAnJ1xuICAgIC8vIFNob3cgb25seSBsYXN0IDQgZGlnaXRzXG4gICAgY29uc3QgZGlnaXRzID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKVxuICAgIHJldHVybiBkaWdpdHMubGVuZ3RoID4gNCA/IFxuICAgICAgJyonLnJlcGVhdChkaWdpdHMubGVuZ3RoIC0gNCkgKyBkaWdpdHMuc2xpY2UoLTQpIDpcbiAgICAgIHBob25lXG4gIH1cblxuICBwcml2YXRlIGZvcm1hdERhdGUoZGF0ZVN0cjogc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgaWYgKCFkYXRlU3RyKSByZXR1cm4gJydcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpXG4gICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gLy8gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBkYXRlU3RyIC8vIFJldHVybiBvcmlnaW5hbCBpZiBwYXJzaW5nIGZhaWxzXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3Nlc3NDb3ZlcmFnZShleHRyYWN0ZWRGaWVsZHM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBib29sZWFuIHtcbiAgICAvLyBTaW1wbGUgY292ZXJhZ2UgYXNzZXNzbWVudCBiYXNlZCBvbiBwb2xpY3kgbnVtYmVyIHByZXNlbmNlXG4gICAgcmV0dXJuICEhZXh0cmFjdGVkRmllbGRzLnBvbGljeU51bWJlclxuICB9XG5cbiAgcHJpdmF0ZSBkZXRlcm1pbmVEZWR1Y3RpYmxlKGV4dHJhY3RlZEZpZWxkczogUmVjb3JkPHN0cmluZywgYW55Pik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgLy8gRGVmYXVsdCBkZWR1Y3RpYmxlcyBiYXNlZCBvbiBsb3NzIHR5cGVcbiAgICBjb25zdCBsb3NzVHlwZSA9IGV4dHJhY3RlZEZpZWxkcy5sb3NzVHlwZVxuICAgIGNvbnN0IGRlZmF1bHREZWR1Y3RpYmxlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgICdDb2xsaXNpb24nOiA1MDAsXG4gICAgICAnV2F0ZXInOiAxMDAwLFxuICAgICAgJ1dpbmQnOiAxMDAwLFxuICAgICAgJ0xpYWJpbGl0eSc6IDBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZmF1bHREZWR1Y3RpYmxlc1tsb3NzVHlwZV0gfHwgdW5kZWZpbmVkXG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU92ZXJhbGxDb25maWRlbmNlKGV4dHJhY3RlZEZpZWxkczogUmVjb3JkPHN0cmluZywgYW55Pik6IG51bWJlciB7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LnZhbHVlcyhleHRyYWN0ZWRGaWVsZHMpLmZpbHRlcih2ID0+IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkKVxuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydwb2xpY3lOdW1iZXInLCAnY2xhaW1hbnROYW1lJywgJ2xvc3NEYXRlJywgJ2xvc3NUeXBlJ11cbiAgICBjb25zdCBwcmVzZW50UmVxdWlyZWQgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gZXh0cmFjdGVkRmllbGRzW2ZpZWxkXSkubGVuZ3RoXG4gICAgXG4gICAgcmV0dXJuIChwcmVzZW50UmVxdWlyZWQgLyByZXF1aXJlZEZpZWxkcy5sZW5ndGgpICogMC42ICsgKGZpZWxkcy5sZW5ndGggLyAxMCkgKiAwLjRcbiAgfVxuXG4gIHByaXZhdGUgaWRlbnRpZnlNaXNzaW5nRG9jdW1lbnRzKGxvc3NUeXBlOiBzdHJpbmcsIGRvY3VtZW50czogYW55W10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcHJlc2VudFR5cGVzID0gbmV3IFNldChkb2N1bWVudHMubWFwKGQgPT4gZC50eXBlKSlcbiAgICBjb25zdCBleHBlY3RlZERvY3VtZW50czogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICAgICAgJ0NvbGxpc2lvbic6IFsnUG9saWNlUmVwb3J0JywgJ1JlcGFpckVzdGltYXRlJywgJ0RhbWFnZVBob3RvJ10sXG4gICAgICAnV2F0ZXInOiBbJ0RhbWFnZVBob3RvJywgJ1JlcGFpckVzdGltYXRlJ10sXG4gICAgICAnTGlhYmlsaXR5JzogWydJbmNpZGVudFJlcG9ydCcsICdNZWRpY2FsUmVjb3JkJ10sXG4gICAgICAnRmlyZSc6IFsnRGFtYWdlUGhvdG8nLCAnUmVwYWlyRXN0aW1hdGUnLCAnRmlyZVJlcG9ydCddLFxuICAgICAgJ1RoZWZ0JzogWydQb2xpY2VSZXBvcnQnLCAnSXRlbUxpc3QnXVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBleHBlY3RlZCA9IGV4cGVjdGVkRG9jdW1lbnRzW2xvc3NUeXBlXSB8fCBbXVxuICAgIHJldHVybiBleHBlY3RlZC5maWx0ZXIoZG9jVHlwZSA9PiAhcHJlc2VudFR5cGVzLmhhcyhkb2NUeXBlKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoXG4gICAgY2xhaW1EcmFmdDogQ2xhaW1EcmFmdCwgXG4gICAgcG9saWN5SGl0czogYW55W10sIFxuICAgIGV2aWRlbmNlOiBhbnlbXVxuICApOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gW11cbiAgICBcbiAgICAvLyBDb3ZlcmFnZSByZWNvbW1lbmRhdGlvbnNcbiAgICBpZiAocG9saWN5SGl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdObyBtYXRjaGluZyBwb2xpY3kgY2xhdXNlcyBmb3VuZCAtIHJldmlldyBjb3ZlcmFnZSBtYW51YWxseScpXG4gICAgfSBlbHNlIGlmIChwb2xpY3lIaXRzWzBdLnNpbWlsYXJpdHkgPCAwLjgpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdMb3cgcG9saWN5IG1hdGNoIGNvbmZpZGVuY2UgLSBhZGp1c3RlciByZXZpZXcgcmVjb21tZW5kZWQnKVxuICAgIH1cbiAgICBcbiAgICAvLyBFdmlkZW5jZSByZWNvbW1lbmRhdGlvbnNcbiAgICBjb25zdCBsb3dDb25maWRlbmNlRmllbGRzID0gZXZpZGVuY2UuZmlsdGVyKGUgPT4gZS5jb25maWRlbmNlIDwgMC42KVxuICAgIGlmIChsb3dDb25maWRlbmNlRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKGAke2xvd0NvbmZpZGVuY2VGaWVsZHMubGVuZ3RofSBmaWVsZHMgbmVlZCBtYW51YWwgdmVyaWZpY2F0aW9uYClcbiAgICB9XG4gICAgXG4gICAgLy8gQW1vdW50IHJlY29tbWVuZGF0aW9uc1xuICAgIGlmIChjbGFpbURyYWZ0LmVzdGltYXRlZEFtb3VudCAmJiBjbGFpbURyYWZ0LmVzdGltYXRlZEFtb3VudCA+IDEwMDAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnSGlnaC12YWx1ZSBjbGFpbSAtIHNlbmlvciBhZGp1c3RlciByZXZpZXcgcmVxdWlyZWQnKVxuICAgIH1cbiAgICBcbiAgICAvLyBEb2N1bWVudCByZWNvbW1lbmRhdGlvbnNcbiAgICBpZiAoIWNsYWltRHJhZnQuYXR0YWNobWVudHMuc29tZShhID0+IGEudHlwZSA9PT0gJ0RhbWFnZVBob3RvJykpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdEYW1hZ2UgcGhvdG9zIHJlY29tbWVuZGVkIGZvciBjbGFpbSB2YWxpZGF0aW9uJylcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlY29tbWVuZGF0aW9uc1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBdXRvbWF0aW9uTGV2ZWwoZXZpZGVuY2U6IGFueVtdKTogbnVtYmVyIHtcbiAgICBjb25zdCBoaWdoQ29uZmlkZW5jZUZpZWxkcyA9IGV2aWRlbmNlLmZpbHRlcihlID0+IGUuY29uZmlkZW5jZSA+PSAwLjgpLmxlbmd0aFxuICAgIHJldHVybiBldmlkZW5jZS5sZW5ndGggPiAwID8gaGlnaENvbmZpZGVuY2VGaWVsZHMgLyBldmlkZW5jZS5sZW5ndGggOiAwXG4gIH1cbn0iXSwibmFtZXMiOlsiQXNzZW1ibGVyQWdlbnQiLCJleGVjdXRlIiwic3RhdGUiLCJjb25maWciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY2xhaW1EYXRhIiwiYXNzZW1ibGVDbGFpbURhdGEiLCJkdXJhdGlvbiIsImN1cnJlbnRTdGVwIiwiYXVkaXRFdmVudHMiLCJzdGVwIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJhZ2VudCIsInN0YXR1cyIsImRldGFpbHMiLCJmaWVsZHNBc3NlbWJsZWQiLCJPYmplY3QiLCJrZXlzIiwiZXh0cmFjdGVkRmllbGRzIiwibGVuZ3RoIiwiZG9jdW1lbnRzUHJvY2Vzc2VkIiwiZG9jdW1lbnRzIiwicG9saWN5SGl0c0luY2x1ZGVkIiwicG9saWN5SGl0cyIsInRvdGFsUHJvY2Vzc2luZ1RpbWUiLCJlcnJvciIsImVycm9ycyIsIlN0cmluZyIsImNsYWltRHJhZnQiLCJjcmVhdGVDbGFpbURyYWZ0IiwiZGVjaXNpb25QYWNrIiwiY3JlYXRlRGVjaXNpb25QYWNrIiwiZmllbGRFdmlkZW5jZSIsInByb2Nlc3NpbmdNZXRyaWNzIiwiY2FsY3VsYXRlUHJvY2Vzc2luZ01ldHJpY3MiLCJjbGFpbUlkIiwiZ2VuZXJhdGVDbGFpbUlkIiwiZXZpZGVuY2UiLCJwb2xpY3lHcm91bmRpbmciLCJhdWRpdCIsImF1ZGl0VHJhaWwiLCJjcmVhdGVkQXQiLCJpZCIsImdlbmVyYXRlRHJhZnRJZCIsInBvbGljeU51bWJlciIsInNhbml0aXplUG9saWN5TnVtYmVyIiwiY2xhaW1hbnROYW1lIiwiY29udGFjdEVtYWlsIiwibWFza0VtYWlsIiwiY29udGFjdFBob25lIiwibWFza1Bob25lIiwibG9zc0RhdGUiLCJmb3JtYXREYXRlIiwibG9zc1R5cGUiLCJsb3NzTG9jYXRpb24iLCJkZXNjcmlwdGlvbiIsImVzdGltYXRlZEFtb3VudCIsImVzdGltYXRlZERhbWFnZSIsInZlaGljbGVJbmZvIiwicHJvcGVydHlBZGRyZXNzIiwiYXR0YWNobWVudHMiLCJtYXAiLCJkb2MiLCJuYW1lIiwibWltZVR5cGUiLCJ0eXBlIiwiY29uZmlkZW5jZSIsImNvdmVyYWdlRm91bmQiLCJhc3Nlc3NDb3ZlcmFnZSIsImRlZHVjdGlibGUiLCJkZXRlcm1pbmVEZWR1Y3RpYmxlIiwic291cmNlIiwiY2FsY3VsYXRlT3ZlcmFsbENvbmZpZGVuY2UiLCJnZW5lcmF0ZURlY2lzaW9uUGFja0lkIiwiZXZpZGVuY2VTdW1tYXJ5IiwidG90YWxGaWVsZHMiLCJoaWdoQ29uZmlkZW5jZUZpZWxkcyIsImZpbHRlciIsImUiLCJsb3dDb25maWRlbmNlRmllbGRzIiwiYXZnQ29uZmlkZW5jZSIsInJlZHVjZSIsInN1bSIsImRvY3VtZW50QW5hbHlzaXMiLCJ0b3RhbERvY3VtZW50cyIsImRvY3VtZW50VHlwZXMiLCJTZXQiLCJkIiwiYXZnRG9jdW1lbnRDb25maWRlbmNlIiwibWlzc2luZ0RvY3VtZW50cyIsImlkZW50aWZ5TWlzc2luZ0RvY3VtZW50cyIsInBvbGljeUFzc2Vzc21lbnQiLCJjbGF1c2VzRm91bmQiLCJjb3ZlcmFnZUNvbmZpcm1lZCIsInRvcFNpbWlsYXJpdHlTY29yZSIsIk1hdGgiLCJtYXgiLCJoIiwic2ltaWxhcml0eSIsInJlY29tbWVuZGVkQWN0aW9ucyIsImdlbmVyYXRlUmVjb21tZW5kYXRpb25zIiwicHJvY2Vzc2luZ1N1bW1hcnkiLCJ0b3RhbFRpbWUiLCJzdGVwc0NvbXBsZXRlZCIsInN0ZXBzV2l0aEVycm9ycyIsImF1dG9tYXRpb25MZXZlbCIsImNhbGN1bGF0ZUF1dG9tYXRpb25MZXZlbCIsImNvbXBsZXRlZFN0ZXBzIiwiZmFpbGVkU3RlcHMiLCJhdmVyYWdlSGFuZGxlVGltZSIsImZpZWxkc0F1dG9Qb3B1bGF0ZWQiLCJrZXkiLCJ1bmRlZmluZWQiLCJvdmVycmlkZVJhdGUiLCJyYWdIaXRSYXRlIiwic3RlcHNGYWlsZWQiLCJzdWNjZXNzUmF0ZSIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidG9VcHBlckNhc2UiLCJyZXBlYXQiLCJzbGljZSIsImVtYWlsIiwidXNlcm5hbWUiLCJkb21haW4iLCJzcGxpdCIsIm1hc2tlZFVzZXJuYW1lIiwic3Vic3RyaW5nIiwicGhvbmUiLCJkaWdpdHMiLCJyZXBsYWNlIiwiZGF0ZVN0ciIsImRhdGUiLCJkZWZhdWx0RGVkdWN0aWJsZXMiLCJmaWVsZHMiLCJ2YWx1ZXMiLCJ2IiwicmVxdWlyZWRGaWVsZHMiLCJwcmVzZW50UmVxdWlyZWQiLCJmaWVsZCIsInByZXNlbnRUeXBlcyIsImV4cGVjdGVkRG9jdW1lbnRzIiwiZXhwZWN0ZWQiLCJkb2NUeXBlIiwiaGFzIiwicmVjb21tZW5kYXRpb25zIiwicHVzaCIsInNvbWUiLCJhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/agents/nodes/assemblerAgent.ts\n"));

/***/ })

});