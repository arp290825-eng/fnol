"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/agents/nodes/assemblerAgent.ts":
/*!********************************************!*\
  !*** ./lib/agents/nodes/assemblerAgent.ts ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AssemblerAgent: function() { return /* binding */ AssemblerAgent; }\n/* harmony export */ });\nclass AssemblerAgent {\n    async execute(state, config) {\n        const startTime = Date.now();\n        try {\n            // Create the final claim data structure\n            const claimData = await this.assembleClaimData(state);\n            const duration = Date.now() - startTime;\n            return {\n                currentStep: \"Review\",\n                claimData,\n                auditEvents: [\n                    ...state.auditEvents,\n                    {\n                        step: \"assembly\",\n                        timestamp: new Date().toISOString(),\n                        duration,\n                        agent: \"AssemblerAgent\",\n                        status: \"completed\",\n                        details: {\n                            fieldsAssembled: Object.keys(state.extractedFields).length,\n                            documentsProcessed: state.documents.length,\n                            policyHitsIncluded: state.policyHits.length,\n                            totalProcessingTime: Date.now() - state.startTime\n                        }\n                    }\n                ]\n            };\n        } catch (error) {\n            const duration = Date.now() - startTime;\n            return {\n                errors: [\n                    ...state.errors,\n                    \"Assembly failed: \".concat(error)\n                ],\n                auditEvents: [\n                    ...state.auditEvents,\n                    {\n                        step: \"assembly\",\n                        timestamp: new Date().toISOString(),\n                        duration,\n                        agent: \"AssemblerAgent\",\n                        status: \"failed\",\n                        details: {\n                            error: String(error)\n                        }\n                    }\n                ]\n            };\n        }\n    }\n    async assembleClaimData(state) {\n        // Create claim draft\n        const claimDraft = this.createClaimDraft(state.extractedFields, state.documents);\n        // Assemble decision pack\n        const decisionPack = this.createDecisionPack(claimDraft, state.fieldEvidence, state.documents, state.policyHits, state.auditEvents);\n        // Calculate processing metrics\n        const processingMetrics = this.calculateProcessingMetrics(state);\n        return {\n            claimId: this.generateClaimId(),\n            decisionPack: {\n                ...decisionPack,\n                claimDraft,\n                evidence: state.fieldEvidence,\n                documents: state.documents,\n                policyGrounding: state.policyHits,\n                audit: state.auditEvents\n            },\n            auditTrail: state.auditEvents,\n            processingMetrics,\n            createdAt: new Date().toISOString(),\n            status: \"draft\"\n        };\n    }\n    createClaimDraft(extractedFields, documents) {\n        return {\n            id: this.generateDraftId(),\n            policyNumber: this.sanitizePolicyNumber(extractedFields.policyNumber),\n            claimantName: extractedFields.claimantName || \"Unknown\",\n            contactEmail: this.maskEmail(extractedFields.contactEmail),\n            contactPhone: this.maskPhone(extractedFields.contactPhone),\n            lossDate: this.formatDate(extractedFields.lossDate),\n            lossType: extractedFields.lossType || \"Other\",\n            lossLocation: extractedFields.lossLocation || \"Not specified\",\n            description: extractedFields.description || \"Claim details extracted from submitted documents\",\n            estimatedAmount: extractedFields.estimatedDamage || null,\n            // Vehicle-specific fields\n            vehicleInfo: extractedFields.vehicleInfo || null,\n            // Property-specific fields  \n            propertyAddress: extractedFields.propertyAddress || null,\n            // Attachments reference\n            attachments: documents.map((doc)=>({\n                    id: doc.id,\n                    name: doc.name,\n                    mimeType: doc.mimeType || \"application/octet-stream\",\n                    type: doc.type,\n                    confidence: doc.confidence\n                })),\n            // Coverage assessment\n            coverageFound: this.assessCoverage(extractedFields),\n            deductible: this.determineDeductible(extractedFields),\n            // Metadata\n            createdAt: new Date().toISOString(),\n            source: \"automated_extraction\",\n            confidence: this.calculateOverallConfidence(extractedFields)\n        };\n    }\n    createDecisionPack(claimDraft, evidence, documents, policyHits, auditEvents) {\n        return {\n            id: this.generateDecisionPackId(),\n            claimDraft,\n            // Evidence summary\n            evidenceSummary: {\n                totalFields: evidence.length,\n                highConfidenceFields: evidence.filter((e)=>e.confidence >= 0.8).length,\n                lowConfidenceFields: evidence.filter((e)=>e.confidence < 0.6).length,\n                avgConfidence: evidence.reduce((sum, e)=>sum + e.confidence, 0) / evidence.length\n            },\n            // Document analysis\n            documentAnalysis: {\n                totalDocuments: documents.length,\n                documentTypes: [\n                    ...new Set(documents.map((d)=>d.type))\n                ],\n                avgDocumentConfidence: documents.reduce((sum, d)=>sum + d.confidence, 0) / documents.length,\n                missingDocuments: this.identifyMissingDocuments(claimDraft.lossType, documents)\n            },\n            // Policy assessment\n            policyAssessment: {\n                clausesFound: policyHits.length,\n                coverageConfirmed: policyHits.length > 0,\n                topSimilarityScore: policyHits.length > 0 ? Math.max(...policyHits.map((h)=>h.similarity)) : 0,\n                recommendedActions: this.generateRecommendations(claimDraft, policyHits, evidence)\n            },\n            // Processing summary\n            processingSummary: {\n                totalTime: auditEvents.length > 0 ? auditEvents.reduce((sum, e)=>sum + e.duration, 0) : 0,\n                stepsCompleted: auditEvents.filter((e)=>e.status === \"completed\").length,\n                stepsWithErrors: auditEvents.filter((e)=>e.status === \"failed\").length,\n                automationLevel: this.calculateAutomationLevel(evidence)\n            },\n            createdAt: new Date().toISOString()\n        };\n    }\n    calculateProcessingMetrics(state) {\n        const totalTime = Date.now() - state.startTime;\n        const completedSteps = state.auditEvents.filter((e)=>e.status === \"completed\").length;\n        const failedSteps = state.auditEvents.filter((e)=>e.status === \"failed\").length;\n        return {\n            totalProcessingTime: totalTime,\n            averageHandleTime: totalTime / 60000,\n            fieldsAutoPopulated: Object.keys(state.extractedFields).filter((key)=>state.extractedFields[key] !== null && state.extractedFields[key] !== undefined).length,\n            overrideRate: 0,\n            ragHitRate: state.policyHits.length > 0 ? 1 : 0,\n            stepsCompleted: completedSteps,\n            stepsFailed: failedSteps,\n            successRate: completedSteps / (completedSteps + failedSteps)\n        };\n    }\n    // Utility methods\n    generateClaimId() {\n        return \"CLM-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 6).toUpperCase());\n    }\n    generateDraftId() {\n        return \"DRAFT-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 4).toUpperCase());\n    }\n    generateDecisionPackId() {\n        return \"DP-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substr(2, 8).toUpperCase());\n    }\n    sanitizePolicyNumber(policyNumber) {\n        if (!policyNumber) return \"Unknown\";\n        // Mask policy number for privacy (show only last 3 digits)\n        return policyNumber.length > 3 ? \"*\".repeat(policyNumber.length - 3) + policyNumber.slice(-3) : policyNumber;\n    }\n    maskEmail(email) {\n        if (!email) return \"\";\n        const [username, domain] = email.split(\"@\");\n        if (!domain) return email;\n        const maskedUsername = username.length > 4 ? username.substring(0, 2) + \"*\".repeat(username.length - 4) + username.slice(-2) : username;\n        return \"\".concat(maskedUsername, \"@\").concat(domain);\n    }\n    maskPhone(phone) {\n        if (!phone) return \"\";\n        // Show only last 4 digits\n        const digits = phone.replace(/\\D/g, \"\");\n        return digits.length > 4 ? \"*\".repeat(digits.length - 4) + digits.slice(-4) : phone;\n    }\n    formatDate(dateStr) {\n        if (!dateStr) return \"\";\n        try {\n            const date = new Date(dateStr);\n            return date.toISOString().split(\"T\")[0] // YYYY-MM-DD format\n            ;\n        } catch (e) {\n            return dateStr // Return original if parsing fails\n            ;\n        }\n    }\n    assessCoverage(extractedFields) {\n        // Simple coverage assessment based on policy number presence\n        return !!extractedFields.policyNumber;\n    }\n    determineDeductible(extractedFields) {\n        // Default deductibles based on loss type\n        const lossType = extractedFields.lossType;\n        const defaultDeductibles = {\n            \"Collision\": 500,\n            \"Water\": 1000,\n            \"Wind\": 1000,\n            \"Liability\": 0\n        };\n        return defaultDeductibles[lossType] || undefined;\n    }\n    calculateOverallConfidence(extractedFields) {\n        const fields = Object.values(extractedFields).filter((v)=>v !== null && v !== undefined);\n        const requiredFields = [\n            \"policyNumber\",\n            \"claimantName\",\n            \"lossDate\",\n            \"lossType\"\n        ];\n        const presentRequired = requiredFields.filter((field)=>extractedFields[field]).length;\n        return presentRequired / requiredFields.length * 0.6 + fields.length / 10 * 0.4;\n    }\n    identifyMissingDocuments(lossType, documents) {\n        const presentTypes = new Set(documents.map((d)=>d.type));\n        const expectedDocuments = {\n            \"Collision\": [\n                \"PoliceReport\",\n                \"RepairEstimate\",\n                \"DamagePhoto\"\n            ],\n            \"Water\": [\n                \"DamagePhoto\",\n                \"RepairEstimate\"\n            ],\n            \"Liability\": [\n                \"IncidentReport\",\n                \"MedicalRecord\"\n            ],\n            \"Fire\": [\n                \"DamagePhoto\",\n                \"RepairEstimate\",\n                \"FireReport\"\n            ],\n            \"Theft\": [\n                \"PoliceReport\",\n                \"ItemList\"\n            ]\n        };\n        const expected = expectedDocuments[lossType] || [];\n        return expected.filter((docType)=>!presentTypes.has(docType));\n    }\n    generateRecommendations(claimDraft, policyHits, evidence) {\n        const recommendations = [];\n        // Coverage recommendations\n        if (policyHits.length === 0) {\n            recommendations.push(\"No matching policy clauses found - review coverage manually\");\n        } else if (policyHits[0].similarity < 0.8) {\n            recommendations.push(\"Low policy match confidence - adjuster review recommended\");\n        }\n        // Evidence recommendations\n        const lowConfidenceFields = evidence.filter((e)=>e.confidence < 0.6);\n        if (lowConfidenceFields.length > 0) {\n            recommendations.push(\"\".concat(lowConfidenceFields.length, \" fields need manual verification\"));\n        }\n        // Amount recommendations\n        if (claimDraft.estimatedAmount && claimDraft.estimatedAmount > 10000) {\n            recommendations.push(\"High-value claim - senior adjuster review required\");\n        }\n        // Document recommendations\n        if (!claimDraft.attachments.some((a)=>a.type === \"DamagePhoto\")) {\n            recommendations.push(\"Damage photos recommended for claim validation\");\n        }\n        return recommendations;\n    }\n    calculateAutomationLevel(evidence) {\n        const highConfidenceFields = evidence.filter((e)=>e.confidence >= 0.8).length;\n        return evidence.length > 0 ? highConfidenceFields / evidence.length : 0;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hZ2VudHMvbm9kZXMvYXNzZW1ibGVyQWdlbnQudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUdPLE1BQU1BO0lBQ1gsTUFBTUMsUUFBUUMsS0FBaUIsRUFBRUMsTUFBbUIsRUFBZ0M7UUFDbEYsTUFBTUMsWUFBWUMsS0FBS0MsR0FBRztRQUUxQixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU1DLFlBQVksTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDTjtZQUUvQyxNQUFNTyxXQUFXSixLQUFLQyxHQUFHLEtBQUtGO1lBRTlCLE9BQU87Z0JBQ0xNLGFBQWE7Z0JBQ2JIO2dCQUNBSSxhQUFhO3VCQUFJVCxNQUFNUyxXQUFXO29CQUFFO3dCQUNsQ0MsTUFBTTt3QkFDTkMsV0FBVyxJQUFJUixPQUFPUyxXQUFXO3dCQUNqQ0w7d0JBQ0FNLE9BQU87d0JBQ1BDLFFBQVE7d0JBQ1JDLFNBQVM7NEJBQ1BDLGlCQUFpQkMsT0FBT0MsSUFBSSxDQUFDbEIsTUFBTW1CLGVBQWUsRUFBRUMsTUFBTTs0QkFDMURDLG9CQUFvQnJCLE1BQU1zQixTQUFTLENBQUNGLE1BQU07NEJBQzFDRyxvQkFBb0J2QixNQUFNd0IsVUFBVSxDQUFDSixNQUFNOzRCQUMzQ0sscUJBQXFCdEIsS0FBS0MsR0FBRyxLQUFLSixNQUFNRSxTQUFTO3dCQUNuRDtvQkFDRjtpQkFBRTtZQUNKO1FBQ0YsRUFBRSxPQUFPd0IsT0FBTztZQUNkLE1BQU1uQixXQUFXSixLQUFLQyxHQUFHLEtBQUtGO1lBRTlCLE9BQU87Z0JBQ0x5QixRQUFRO3VCQUFJM0IsTUFBTTJCLE1BQU07b0JBQUcsb0JBQXlCLE9BQU5EO2lCQUFRO2dCQUN0RGpCLGFBQWE7dUJBQUlULE1BQU1TLFdBQVc7b0JBQUU7d0JBQ2xDQyxNQUFNO3dCQUNOQyxXQUFXLElBQUlSLE9BQU9TLFdBQVc7d0JBQ2pDTDt3QkFDQU0sT0FBTzt3QkFDUEMsUUFBUTt3QkFDUkMsU0FBUzs0QkFBRVcsT0FBT0Us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TztZQUNwRTBGLGdCQUFnQkMsSUFBSSxDQUFDO1FBQ3ZCO1FBRUEsMkJBQTJCO1FBQzNCLElBQUksQ0FBQ3ZILFdBQVdnQyxXQUFXLENBQUN3RixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVwRixJQUFJLEtBQUssZ0JBQWdCO1lBQy9EaUYsZ0JBQWdCQyxJQUFJLENBQUM7UUFDdkI7UUFFQSxPQUFPRDtJQUNUO0lBRVF4Qyx5QkFBeUJyRSxRQUFlLEVBQVU7UUFDeEQsTUFBTXVDLHVCQUF1QnZDLFNBQVN3QyxNQUFNLENBQUNDLENBQUFBLElBQUtBLEVBQUVaLFVBQVUsSUFBSSxLQUFLL0MsTUFBTTtRQUM3RSxPQUFPa0IsU0FBU2xCLE1BQU0sR0FBRyxJQUFJeUQsdUJBQXVCdkMsU0FBU2xCLE1BQU0sR0FBRztJQUN4RTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hZ2VudHMvbm9kZXMvYXNzZW1ibGVyQWdlbnQudHM/OGI3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZ2VudFN0YXRlLCBBZ2VudENvbmZpZyB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgQ2xhaW1EYXRhLCBEZWNpc2lvblBhY2ssIENsYWltRHJhZnQgfSBmcm9tICdAL3R5cGVzL2NsYWltcydcblxuZXhwb3J0IGNsYXNzIEFzc2VtYmxlckFnZW50IHtcbiAgYXN5bmMgZXhlY3V0ZShzdGF0ZTogQWdlbnRTdGF0ZSwgY29uZmlnOiBBZ2VudENvbmZpZyk6IFByb21pc2U8UGFydGlhbDxBZ2VudFN0YXRlPj4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBmaW5hbCBjbGFpbSBkYXRhIHN0cnVjdHVyZVxuICAgICAgY29uc3QgY2xhaW1EYXRhID0gYXdhaXQgdGhpcy5hc3NlbWJsZUNsYWltRGF0YShzdGF0ZSlcbiAgICAgIFxuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnRTdGVwOiAnUmV2aWV3JyxcbiAgICAgICAgY2xhaW1EYXRhLFxuICAgICAgICBhdWRpdEV2ZW50czogWy4uLnN0YXRlLmF1ZGl0RXZlbnRzLCB7XG4gICAgICAgICAgc3RlcDogJ2Fzc2VtYmx5JyxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBhZ2VudDogJ0Fzc2VtYmxlckFnZW50JyxcbiAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIGZpZWxkc0Fzc2VtYmxlZDogT2JqZWN0LmtleXMoc3RhdGUuZXh0cmFjdGVkRmllbGRzKS5sZW5ndGgsXG4gICAgICAgICAgICBkb2N1bWVudHNQcm9jZXNzZWQ6IHN0YXRlLmRvY3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBwb2xpY3lIaXRzSW5jbHVkZWQ6IHN0YXRlLnBvbGljeUhpdHMubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQcm9jZXNzaW5nVGltZTogRGF0ZS5ub3coKSAtIHN0YXRlLnN0YXJ0VGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lXG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yczogWy4uLnN0YXRlLmVycm9ycywgYEFzc2VtYmx5IGZhaWxlZDogJHtlcnJvcn1gXSxcbiAgICAgICAgYXVkaXRFdmVudHM6IFsuLi5zdGF0ZS5hdWRpdEV2ZW50cywge1xuICAgICAgICAgIHN0ZXA6ICdhc3NlbWJseScsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgYWdlbnQ6ICdBc3NlbWJsZXJBZ2VudCcsXG4gICAgICAgICAgc3RhdHVzOiAnZmFpbGVkJyxcbiAgICAgICAgICBkZXRhaWxzOiB7IGVycm9yOiBTdHJpbmcoZXJyb3IpIH1cbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGFzc2VtYmxlQ2xhaW1EYXRhKHN0YXRlOiBBZ2VudFN0YXRlKTogUHJvbWlzZTxDbGFpbURhdGE+IHtcbiAgICAvLyBDcmVhdGUgY2xhaW0gZHJhZnRcbiAgICBjb25zdCBjbGFpbURyYWZ0ID0gdGhpcy5jcmVhdGVDbGFpbURyYWZ0KHN0YXRlLmV4dHJhY3RlZEZpZWxkcywgc3RhdGUuZG9jdW1lbnRzKVxuICAgIFxuICAgIC8vIEFzc2VtYmxlIGRlY2lzaW9uIHBhY2tcbiAgICBjb25zdCBkZWNpc2lvblBhY2sgPSB0aGlzLmNyZWF0ZURlY2lzaW9uUGFjayhcbiAgICAgIGNsYWltRHJhZnQsXG4gICAgICBzdGF0ZS5maWVsZEV2aWRlbmNlLFxuICAgICAgc3RhdGUuZG9jdW1lbnRzLFxuICAgICAgc3RhdGUucG9saWN5SGl0cyxcbiAgICAgIHN0YXRlLmF1ZGl0RXZlbnRzXG4gICAgKVxuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwcm9jZXNzaW5nIG1ldHJpY3NcbiAgICBjb25zdCBwcm9jZXNzaW5nTWV0cmljcyA9IHRoaXMuY2FsY3VsYXRlUHJvY2Vzc2luZ01ldHJpY3Moc3RhdGUpXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYWltSWQ6IHRoaXMuZ2VuZXJhdGVDbGFpbUlkKCksXG4gICAgICBkZWNpc2lvblBhY2s6IHtcbiAgICAgICAgLi4uZGVjaXNpb25QYWNrLFxuICAgICAgICBjbGFpbURyYWZ0LFxuICAgICAgICBldmlkZW5jZTogc3RhdGUuZmllbGRFdmlkZW5jZSxcbiAgICAgICAgZG9jdW1lbnRzOiBzdGF0ZS5kb2N1bWVudHMsXG4gICAgICAgIHBvbGljeUdyb3VuZGluZzogc3RhdGUucG9saWN5SGl0cyxcbiAgICAgICAgYXVkaXQ6IHN0YXRlLmF1ZGl0RXZlbnRzXG4gICAgICB9LFxuICAgICAgYXVkaXRUcmFpbDogc3RhdGUuYXVkaXRFdmVudHMsXG4gICAgICBwcm9jZXNzaW5nTWV0cmljcyxcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgc3RhdHVzOiAnZHJhZnQnXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDbGFpbURyYWZ0KGV4dHJhY3RlZEZpZWxkczogUmVjb3JkPHN0cmluZywgYW55PiwgZG9jdW1lbnRzOiBhbnlbXSk6IENsYWltRHJhZnQge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5nZW5lcmF0ZURyYWZ0SWQoKSxcbiAgICAgIHBvbGljeU51bWJlcjogdGhpcy5zYW5pdGl6ZVBvbGljeU51bWJlcihleHRyYWN0ZWRGaWVsZHMucG9saWN5TnVtYmVyKSxcbiAgICAgIGNsYWltYW50TmFtZTogZXh0cmFjdGVkRmllbGRzLmNsYWltYW50TmFtZSB8fCAnVW5rbm93bicsXG4gICAgICBjb250YWN0RW1haWw6IHRoaXMubWFza0VtYWlsKGV4dHJhY3RlZEZpZWxkcy5jb250YWN0RW1haWwpLFxuICAgICAgY29udGFjdFBob25lOiB0aGlzLm1hc2tQaG9uZShleHRyYWN0ZWRGaWVsZHMuY29udGFjdFBob25lKSxcbiAgICAgIGxvc3NEYXRlOiB0aGlzLmZvcm1hdERhdGUoZXh0cmFjdGVkRmllbGRzLmxvc3NEYXRlKSxcbiAgICAgIGxvc3NUeXBlOiBleHRyYWN0ZWRGaWVsZHMubG9zc1R5cGUgfHwgJ090aGVyJyxcbiAgICAgIGxvc3NMb2NhdGlvbjogZXh0cmFjdGVkRmllbGRzLmxvc3NMb2NhdGlvbiB8fCAnTm90IHNwZWNpZmllZCcsXG4gICAgICBkZXNjcmlwdGlvbjogZXh0cmFjdGVkRmllbGRzLmRlc2NyaXB0aW9uIHx8ICdDbGFpbSBkZXRhaWxzIGV4dHJhY3RlZCBmcm9tIHN1Ym1pdHRlZCBkb2N1bWVudHMnLFxuICAgICAgZXN0aW1hdGVkQW1vdW50OiBleHRyYWN0ZWRGaWVsZHMuZXN0aW1hdGVkRGFtYWdlIHx8IG51bGwsXG4gICAgICBcbiAgICAgIC8vIFZlaGljbGUtc3BlY2lmaWMgZmllbGRzXG4gICAgICB2ZWhpY2xlSW5mbzogZXh0cmFjdGVkRmllbGRzLnZlaGljbGVJbmZvIHx8IG51bGwsXG4gICAgICBcbiAgICAgIC8vIFByb3BlcnR5LXNwZWNpZmljIGZpZWxkcyAgXG4gICAgICBwcm9wZXJ0eUFkZHJlc3M6IGV4dHJhY3RlZEZpZWxkcy5wcm9wZXJ0eUFkZHJlc3MgfHwgbnVsbCxcbiAgICAgIFxuICAgICAgLy8gQXR0YWNobWVudHMgcmVmZXJlbmNlXG4gICAgICBhdHRhY2htZW50czogZG9jdW1lbnRzLm1hcChkb2MgPT4gKHtcbiAgICAgICAgaWQ6IGRvYy5pZCxcbiAgICAgICAgbmFtZTogZG9jLm5hbWUsXG4gICAgICAgIG1pbWVUeXBlOiBkb2MubWltZVR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgIHR5cGU6IGRvYy50eXBlLFxuICAgICAgICBjb25maWRlbmNlOiBkb2MuY29uZmlkZW5jZVxuICAgICAgfSkpLFxuICAgICAgXG4gICAgICAvLyBDb3ZlcmFnZSBhc3Nlc3NtZW50XG4gICAgICBjb3ZlcmFnZUZvdW5kOiB0aGlzLmFzc2Vzc0NvdmVyYWdlKGV4dHJhY3RlZEZpZWxkcyksXG4gICAgICBkZWR1Y3RpYmxlOiB0aGlzLmRldGVybWluZURlZHVjdGlibGUoZXh0cmFjdGVkRmllbGRzKSxcbiAgICAgIFxuICAgICAgLy8gTWV0YWRhdGFcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgc291cmNlOiAnYXV0b21hdGVkX2V4dHJhY3Rpb24nLFxuICAgICAgY29uZmlkZW5jZTogdGhpcy5jYWxjdWxhdGVPdmVyYWxsQ29uZmlkZW5jZShleHRyYWN0ZWRGaWVsZHMpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEZWNpc2lvblBhY2soXG4gICAgY2xhaW1EcmFmdDogQ2xhaW1EcmFmdCxcbiAgICBldmlkZW5jZTogYW55W10sXG4gICAgZG9jdW1lbnRzOiBhbnlbXSxcbiAgICBwb2xpY3lIaXRzOiBhbnlbXSxcbiAgICBhdWRpdEV2ZW50czogYW55W11cbiAgKTogRGVjaXNpb25QYWNrIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVEZWNpc2lvblBhY2tJZCgpLFxuICAgICAgY2xhaW1EcmFmdCxcbiAgICAgIFxuICAgICAgLy8gRXZpZGVuY2Ugc3VtbWFyeVxuICAgICAgZXZpZGVuY2VTdW1tYXJ5OiB7XG4gICAgICAgIHRvdGFsRmllbGRzOiBldmlkZW5jZS5sZW5ndGgsXG4gICAgICAgIGhpZ2hDb25maWRlbmNlRmllbGRzOiBldmlkZW5jZS5maWx0ZXIoZSA9PiBlLmNvbmZpZGVuY2UgPj0gMC44KS5sZW5ndGgsXG4gICAgICAgIGxvd0NvbmZpZGVuY2VGaWVsZHM6IGV2aWRlbmNlLmZpbHRlcihlID0+IGUuY29uZmlkZW5jZSA8IDAuNikubGVuZ3RoLFxuICAgICAgICBhdmdDb25maWRlbmNlOiBldmlkZW5jZS5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgZS5jb25maWRlbmNlLCAwKSAvIGV2aWRlbmNlLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gRG9jdW1lbnQgYW5hbHlzaXNcbiAgICAgIGRvY3VtZW50QW5hbHlzaXM6IHtcbiAgICAgICAgdG90YWxEb2N1bWVudHM6IGRvY3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRvY3VtZW50VHlwZXM6IFsuLi5uZXcgU2V0KGRvY3VtZW50cy5tYXAoZCA9PiBkLnR5cGUpKV0sXG4gICAgICAgIGF2Z0RvY3VtZW50Q29uZmlkZW5jZTogZG9jdW1lbnRzLnJlZHVjZSgoc3VtLCBkKSA9PiBzdW0gKyBkLmNvbmZpZGVuY2UsIDApIC8gZG9jdW1lbnRzLmxlbmd0aCxcbiAgICAgICAgbWlzc2luZ0RvY3VtZW50czogdGhpcy5pZGVudGlmeU1pc3NpbmdEb2N1bWVudHMoY2xhaW1EcmFmdC5sb3NzVHlwZSwgZG9jdW1lbnRzKVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gUG9saWN5IGFzc2Vzc21lbnRcbiAgICAgIHBvbGljeUFzc2Vzc21lbnQ6IHtcbiAgICAgICAgY2xhdXNlc0ZvdW5kOiBwb2xpY3lIaXRzLmxlbmd0aCxcbiAgICAgICAgY292ZXJhZ2VDb25maXJtZWQ6IHBvbGljeUhpdHMubGVuZ3RoID4gMCxcbiAgICAgICAgdG9wU2ltaWxhcml0eVNjb3JlOiBwb2xpY3lIaXRzLmxlbmd0aCA+IDAgPyBNYXRoLm1heCguLi5wb2xpY3lIaXRzLm1hcChoID0+IGguc2ltaWxhcml0eSkpIDogMCxcbiAgICAgICAgcmVjb21tZW5kZWRBY3Rpb25zOiB0aGlzLmdlbmVyYXRlUmVjb21tZW5kYXRpb25zKGNsYWltRHJhZnQsIHBvbGljeUhpdHMsIGV2aWRlbmNlKVxuICAgICAgfSxcbiAgICAgIFxuICAgICAgLy8gUHJvY2Vzc2luZyBzdW1tYXJ5XG4gICAgICBwcm9jZXNzaW5nU3VtbWFyeToge1xuICAgICAgICB0b3RhbFRpbWU6IGF1ZGl0RXZlbnRzLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgICBhdWRpdEV2ZW50cy5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgZS5kdXJhdGlvbiwgMCkgOiAwLFxuICAgICAgICBzdGVwc0NvbXBsZXRlZDogYXVkaXRFdmVudHMuZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKS5sZW5ndGgsXG4gICAgICAgIHN0ZXBzV2l0aEVycm9yczogYXVkaXRFdmVudHMuZmlsdGVyKGUgPT4gZS5zdGF0dXMgPT09ICdmYWlsZWQnKS5sZW5ndGgsXG4gICAgICAgIGF1dG9tYXRpb25MZXZlbDogdGhpcy5jYWxjdWxhdGVBdXRvbWF0aW9uTGV2ZWwoZXZpZGVuY2UpXG4gICAgICB9LFxuICAgICAgXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUHJvY2Vzc2luZ01ldHJpY3Moc3RhdGU6IEFnZW50U3RhdGUpOiBhbnkge1xuICAgIGNvbnN0IHRvdGFsVGltZSA9IERhdGUubm93KCkgLSBzdGF0ZS5zdGFydFRpbWVcbiAgICBjb25zdCBjb21wbGV0ZWRTdGVwcyA9IHN0YXRlLmF1ZGl0RXZlbnRzLmZpbHRlcihlID0+IGUuc3RhdHVzID09PSAnY29tcGxldGVkJykubGVuZ3RoXG4gICAgY29uc3QgZmFpbGVkU3RlcHMgPSBzdGF0ZS5hdWRpdEV2ZW50cy5maWx0ZXIoZSA9PiBlLnN0YXR1cyA9PT0gJ2ZhaWxlZCcpLmxlbmd0aFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbFByb2Nlc3NpbmdUaW1lOiB0b3RhbFRpbWUsXG4gICAgICBhdmVyYWdlSGFuZGxlVGltZTogdG90YWxUaW1lIC8gNjAwMDAsIC8vIGluIG1pbnV0ZXNcbiAgICAgIGZpZWxkc0F1dG9Qb3B1bGF0ZWQ6IE9iamVjdC5rZXlzKHN0YXRlLmV4dHJhY3RlZEZpZWxkcykuZmlsdGVyKGtleSA9PiBcbiAgICAgICAgc3RhdGUuZXh0cmFjdGVkRmllbGRzW2tleV0gIT09IG51bGwgJiYgc3RhdGUuZXh0cmFjdGVkRmllbGRzW2tleV0gIT09IHVuZGVmaW5lZFxuICAgICAgKS5sZW5ndGgsXG4gICAgICBvdmVycmlkZVJhdGU6IDAsIC8vIFdvdWxkIGJlIGNhbGN1bGF0ZWQgYmFzZWQgb24gbWFudWFsIGNvcnJlY3Rpb25zXG4gICAgICByYWdIaXRSYXRlOiBzdGF0ZS5wb2xpY3lIaXRzLmxlbmd0aCA+IDAgPyAxIDogMCxcbiAgICAgIHN0ZXBzQ29tcGxldGVkOiBjb21wbGV0ZWRTdGVwcyxcbiAgICAgIHN0ZXBzRmFpbGVkOiBmYWlsZWRTdGVwcyxcbiAgICAgIHN1Y2Nlc3NSYXRlOiBjb21wbGV0ZWRTdGVwcyAvIChjb21wbGV0ZWRTdGVwcyArIGZhaWxlZFN0ZXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBwcml2YXRlIGdlbmVyYXRlQ2xhaW1JZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgQ0xNLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNikudG9VcHBlckNhc2UoKX1gXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlRHJhZnRJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgRFJBRlQtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA0KS50b1VwcGVyQ2FzZSgpfWBcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVEZWNpc2lvblBhY2tJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgRFAtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA4KS50b1VwcGVyQ2FzZSgpfWBcbiAgfVxuXG4gIHByaXZhdGUgc2FuaXRpemVQb2xpY3lOdW1iZXIocG9saWN5TnVtYmVyOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nIHtcbiAgICBpZiAoIXBvbGljeU51bWJlcikgcmV0dXJuICdVbmtub3duJ1xuICAgIC8vIE1hc2sgcG9saWN5IG51bWJlciBmb3IgcHJpdmFjeSAoc2hvdyBvbmx5IGxhc3QgMyBkaWdpdHMpXG4gICAgcmV0dXJuIHBvbGljeU51bWJlci5sZW5ndGggPiAzID8gXG4gICAgICAnKicucmVwZWF0KHBvbGljeU51bWJlci5sZW5ndGggLSAzKSArIHBvbGljeU51bWJlci5zbGljZSgtMykgOlxuICAgICAgcG9saWN5TnVtYmVyXG4gIH1cblxuICBwcml2YXRlIG1hc2tFbWFpbChlbWFpbDogc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgaWYgKCFlbWFpbCkgcmV0dXJuICcnXG4gICAgY29uc3QgW3VzZXJuYW1lLCBkb21haW5dID0gZW1haWwuc3BsaXQoJ0AnKVxuICAgIGlmICghZG9tYWluKSByZXR1cm4gZW1haWxcbiAgICBcbiAgICBjb25zdCBtYXNrZWRVc2VybmFtZSA9IHVzZXJuYW1lLmxlbmd0aCA+IDQgP1xuICAgICAgdXNlcm5hbWUuc3Vic3RyaW5nKDAsIDIpICsgJyonLnJlcGVhdCh1c2VybmFtZS5sZW5ndGggLSA0KSArIHVzZXJuYW1lLnNsaWNlKC0yKSA6XG4gICAgICB1c2VybmFtZVxuICAgIFxuICAgIHJldHVybiBgJHttYXNrZWRVc2VybmFtZX1AJHtkb21haW59YFxuICB9XG5cbiAgcHJpdmF0ZSBtYXNrUGhvbmUocGhvbmU6IHN0cmluZyB8IG51bGwpOiBzdHJpbmcge1xuICAgIGlmICghcGhvbmUpIHJldHVybiAnJ1xuICAgIC8vIFNob3cgb25seSBsYXN0IDQgZGlnaXRzXG4gICAgY29uc3QgZGlnaXRzID0gcGhvbmUucmVwbGFjZSgvXFxEL2csICcnKVxuICAgIHJldHVybiBkaWdpdHMubGVuZ3RoID4gNCA/IFxuICAgICAgJyonLnJlcGVhdChkaWdpdHMubGVuZ3RoIC0gNCkgKyBkaWdpdHMuc2xpY2UoLTQpIDpcbiAgICAgIHBob25lXG4gIH1cblxuICBwcml2YXRlIGZvcm1hdERhdGUoZGF0ZVN0cjogc3RyaW5nIHwgbnVsbCk6IHN0cmluZyB7XG4gICAgaWYgKCFkYXRlU3RyKSByZXR1cm4gJydcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpXG4gICAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0gLy8gWVlZWS1NTS1ERCBmb3JtYXRcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBkYXRlU3RyIC8vIFJldHVybiBvcmlnaW5hbCBpZiBwYXJzaW5nIGZhaWxzXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3Nlc3NDb3ZlcmFnZShleHRyYWN0ZWRGaWVsZHM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBib29sZWFuIHtcbiAgICAvLyBTaW1wbGUgY292ZXJhZ2UgYXNzZXNzbWVudCBiYXNlZCBvbiBwb2xpY3kgbnVtYmVyIHByZXNlbmNlXG4gICAgcmV0dXJuICEhZXh0cmFjdGVkRmllbGRzLnBvbGljeU51bWJlclxuICB9XG5cbiAgcHJpdmF0ZSBkZXRlcm1pbmVEZWR1Y3RpYmxlKGV4dHJhY3RlZEZpZWxkczogUmVjb3JkPHN0cmluZywgYW55Pik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgLy8gRGVmYXVsdCBkZWR1Y3RpYmxlcyBiYXNlZCBvbiBsb3NzIHR5cGVcbiAgICBjb25zdCBsb3NzVHlwZSA9IGV4dHJhY3RlZEZpZWxkcy5sb3NzVHlwZVxuICAgIGNvbnN0IGRlZmF1bHREZWR1Y3RpYmxlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgICdDb2xsaXNpb24nOiA1MDAsXG4gICAgICAnV2F0ZXInOiAxMDAwLFxuICAgICAgJ1dpbmQnOiAxMDAwLFxuICAgICAgJ0xpYWJpbGl0eSc6IDBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZmF1bHREZWR1Y3RpYmxlc1tsb3NzVHlwZV0gfHwgdW5kZWZpbmVkXG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZU92ZXJhbGxDb25maWRlbmNlKGV4dHJhY3RlZEZpZWxkczogUmVjb3JkPHN0cmluZywgYW55Pik6IG51bWJlciB7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LnZhbHVlcyhleHRyYWN0ZWRGaWVsZHMpLmZpbHRlcih2ID0+IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkKVxuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gWydwb2xpY3lOdW1iZXInLCAnY2xhaW1hbnROYW1lJywgJ2xvc3NEYXRlJywgJ2xvc3NUeXBlJ11cbiAgICBjb25zdCBwcmVzZW50UmVxdWlyZWQgPSByZXF1aXJlZEZpZWxkcy5maWx0ZXIoZmllbGQgPT4gZXh0cmFjdGVkRmllbGRzW2ZpZWxkXSkubGVuZ3RoXG4gICAgXG4gICAgcmV0dXJuIChwcmVzZW50UmVxdWlyZWQgLyByZXF1aXJlZEZpZWxkcy5sZW5ndGgpICogMC42ICsgKGZpZWxkcy5sZW5ndGggLyAxMCkgKiAwLjRcbiAgfVxuXG4gIHByaXZhdGUgaWRlbnRpZnlNaXNzaW5nRG9jdW1lbnRzKGxvc3NUeXBlOiBzdHJpbmcsIGRvY3VtZW50czogYW55W10pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcHJlc2VudFR5cGVzID0gbmV3IFNldChkb2N1bWVudHMubWFwKGQgPT4gZC50eXBlKSlcbiAgICBjb25zdCBleHBlY3RlZERvY3VtZW50czogUmVjb3JkPHN0cmluZywgc3RyaW5nW10+ID0ge1xuICAgICAgJ0NvbGxpc2lvbic6IFsnUG9saWNlUmVwb3J0JywgJ1JlcGFpckVzdGltYXRlJywgJ0RhbWFnZVBob3RvJ10sXG4gICAgICAnV2F0ZXInOiBbJ0RhbWFnZVBob3RvJywgJ1JlcGFpckVzdGltYXRlJ10sXG4gICAgICAnTGlhYmlsaXR5JzogWydJbmNpZGVudFJlcG9ydCcsICdNZWRpY2FsUmVjb3JkJ10sXG4gICAgICAnRmlyZSc6IFsnRGFtYWdlUGhvdG8nLCAnUmVwYWlyRXN0aW1hdGUnLCAnRmlyZVJlcG9ydCddLFxuICAgICAgJ1RoZWZ0JzogWydQb2xpY2VSZXBvcnQnLCAnSXRlbUxpc3QnXVxuICAgIH1cbiAgICBcbiAgICBjb25zdCBleHBlY3RlZCA9IGV4cGVjdGVkRG9jdW1lbnRzW2xvc3NUeXBlXSB8fCBbXVxuICAgIHJldHVybiBleHBlY3RlZC5maWx0ZXIoZG9jVHlwZSA9PiAhcHJlc2VudFR5cGVzLmhhcyhkb2NUeXBlKSlcbiAgfVxuXG4gIHByaXZhdGUgZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoXG4gICAgY2xhaW1EcmFmdDogQ2xhaW1EcmFmdCwgXG4gICAgcG9saWN5SGl0czogYW55W10sIFxuICAgIGV2aWRlbmNlOiBhbnlbXVxuICApOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gW11cbiAgICBcbiAgICAvLyBDb3ZlcmFnZSByZWNvbW1lbmRhdGlvbnNcbiAgICBpZiAocG9saWN5SGl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdObyBtYXRjaGluZyBwb2xpY3kgY2xhdXNlcyBmb3VuZCAtIHJldmlldyBjb3ZlcmFnZSBtYW51YWxseScpXG4gICAgfSBlbHNlIGlmIChwb2xpY3lIaXRzWzBdLnNpbWlsYXJpdHkgPCAwLjgpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdMb3cgcG9saWN5IG1hdGNoIGNvbmZpZGVuY2UgLSBhZGp1c3RlciByZXZpZXcgcmVjb21tZW5kZWQnKVxuICAgIH1cbiAgICBcbiAgICAvLyBFdmlkZW5jZSByZWNvbW1lbmRhdGlvbnNcbiAgICBjb25zdCBsb3dDb25maWRlbmNlRmllbGRzID0gZXZpZGVuY2UuZmlsdGVyKGUgPT4gZS5jb25maWRlbmNlIDwgMC42KVxuICAgIGlmIChsb3dDb25maWRlbmNlRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKGAke2xvd0NvbmZpZGVuY2VGaWVsZHMubGVuZ3RofSBmaWVsZHMgbmVlZCBtYW51YWwgdmVyaWZpY2F0aW9uYClcbiAgICB9XG4gICAgXG4gICAgLy8gQW1vdW50IHJlY29tbWVuZGF0aW9uc1xuICAgIGlmIChjbGFpbURyYWZ0LmVzdGltYXRlZEFtb3VudCAmJiBjbGFpbURyYWZ0LmVzdGltYXRlZEFtb3VudCA+IDEwMDAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnSGlnaC12YWx1ZSBjbGFpbSAtIHNlbmlvciBhZGp1c3RlciByZXZpZXcgcmVxdWlyZWQnKVxuICAgIH1cbiAgICBcbiAgICAvLyBEb2N1bWVudCByZWNvbW1lbmRhdGlvbnNcbiAgICBpZiAoIWNsYWltRHJhZnQuYXR0YWNobWVudHMuc29tZShhID0+IGEudHlwZSA9PT0gJ0RhbWFnZVBob3RvJykpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdEYW1hZ2UgcGhvdG9zIHJlY29tbWVuZGVkIGZvciBjbGFpbSB2YWxpZGF0aW9uJylcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlY29tbWVuZGF0aW9uc1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVBdXRvbWF0aW9uTGV2ZWwoZXZpZGVuY2U6IGFueVtdKTogbnVtYmVyIHtcbiAgICBjb25zdCBoaWdoQ29uZmlkZW5jZUZpZWxkcyA9IGV2aWRlbmNlLmZpbHRlcihlID0+IGUuY29uZmlkZW5jZSA+PSAwLjgpLmxlbmd0aFxuICAgIHJldHVybiBldmlkZW5jZS5sZW5ndGggPiAwID8gaGlnaENvbmZpZGVuY2VGaWVsZHMgLyBldmlkZW5jZS5sZW5ndGggOiAwXG4gIH1cbn0iXSwibmFtZXMiOlsiQXNzZW1ibGVyQWdlbnQiLCJleGVjdXRlIiwic3RhdGUiLCJjb25maWciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiY2xhaW1EYXRhIiwiYXNzZW1ibGVDbGFpbURhdGEiLCJkdXJhdGlvbiIsImN1cnJlbnRTdGVwIiwiYXVkaXRFdmVudHMiLCJzdGVwIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJhZ2VudCIsInN0YXR1cyIsImRldGFpbHMiLCJmaWVsZHNBc3NlbWJsZWQiLCJPYmplY3QiLCJrZXlzIiwiZXh0cmFjdGVkRmllbGRzIiwibGVuZ3RoIiwiZG9jdW1lbnRzUHJvY2Vzc2VkIiwiZG9jdW1lbnRzIiwicG9saWN5SGl0c0luY2x1ZGVkIiwicG9saWN5SGl0cyIsInRvdGFsUHJvY2Vzc2luZ1RpbWUiLCJlcnJvciIsImVycm9ycyIsIlN0cmluZyIsImNsYWltRHJhZnQiLCJjcmVhdGVDbGFpbURyYWZ0IiwiZGVjaXNpb25QYWNrIiwiY3JlYXRlRGVjaXNpb25QYWNrIiwiZmllbGRFdmlkZW5jZSIsInByb2Nlc3NpbmdNZXRyaWNzIiwiY2FsY3VsYXRlUHJvY2Vzc2luZ01ldHJpY3MiLCJjbGFpbUlkIiwiZ2VuZXJhdGVDbGFpbUlkIiwiZXZpZGVuY2UiLCJwb2xpY3lHcm91bmRpbmciLCJhdWRpdCIsImF1ZGl0VHJhaWwiLCJjcmVhdGVkQXQiLCJpZCIsImdlbmVyYXRlRHJhZnRJZCIsInBvbGljeU51bWJlciIsInNhbml0aXplUG9saWN5TnVtYmVyIiwiY2xhaW1hbnROYW1lIiwiY29udGFjdEVtYWlsIiwibWFza0VtYWlsIiwiY29udGFjdFBob25lIiwibWFza1Bob25lIiwibG9zc0RhdGUiLCJmb3JtYXREYXRlIiwibG9zc1R5cGUiLCJsb3NzTG9jYXRpb24iLCJkZXNjcmlwdGlvbiIsImVzdGltYXRlZEFtb3VudCIsImVzdGltYXRlZERhbWFnZSIsInZlaGljbGVJbmZvIiwicHJvcGVydHlBZGRyZXNzIiwiYXR0YWNobWVudHMiLCJtYXAiLCJkb2MiLCJuYW1lIiwibWltZVR5cGUiLCJ0eXBlIiwiY29uZmlkZW5jZSIsImNvdmVyYWdlRm91bmQiLCJhc3Nlc3NDb3ZlcmFnZSIsImRlZHVjdGlibGUiLCJkZXRlcm1pbmVEZWR1Y3RpYmxlIiwic291cmNlIiwiY2FsY3VsYXRlT3ZlcmFsbENvbmZpZGVuY2UiLCJnZW5lcmF0ZURlY2lzaW9uUGFja0lkIiwiZXZpZGVuY2VTdW1tYXJ5IiwidG90YWxGaWVsZHMiLCJoaWdoQ29uZmlkZW5jZUZpZWxkcyIsImZpbHRlciIsImUiLCJsb3dDb25maWRlbmNlRmllbGRzIiwiYXZnQ29uZmlkZW5jZSIsInJlZHVjZSIsInN1bSIsImRvY3VtZW50QW5hbHlzaXMiLCJ0b3RhbERvY3VtZW50cyIsImRvY3VtZW50VHlwZXMiLCJTZXQiLCJkIiwiYXZnRG9jdW1lbnRDb25maWRlbmNlIiwibWlzc2luZ0RvY3VtZW50cyIsImlkZW50aWZ5TWlzc2luZ0RvY3VtZW50cyIsInBvbGljeUFzc2Vzc21lbnQiLCJjbGF1c2VzRm91bmQiLCJjb3ZlcmFnZUNvbmZpcm1lZCIsInRvcFNpbWlsYXJpdHlTY29yZSIsIk1hdGgiLCJtYXgiLCJoIiwic2ltaWxhcml0eSIsInJlY29tbWVuZGVkQWN0aW9ucyIsImdlbmVyYXRlUmVjb21tZW5kYXRpb25zIiwicHJvY2Vzc2luZ1N1bW1hcnkiLCJ0b3RhbFRpbWUiLCJzdGVwc0NvbXBsZXRlZCIsInN0ZXBzV2l0aEVycm9ycyIsImF1dG9tYXRpb25MZXZlbCIsImNhbGN1bGF0ZUF1dG9tYXRpb25MZXZlbCIsImNvbXBsZXRlZFN0ZXBzIiwiZmFpbGVkU3RlcHMiLCJhdmVyYWdlSGFuZGxlVGltZSIsImZpZWxkc0F1dG9Qb3B1bGF0ZWQiLCJrZXkiLCJ1bmRlZmluZWQiLCJvdmVycmlkZVJhdGUiLCJyYWdIaXRSYXRlIiwic3RlcHNGYWlsZWQiLCJzdWNjZXNzUmF0ZSIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwidG9VcHBlckNhc2UiLCJyZXBlYXQiLCJzbGljZSIsImVtYWlsIiwidXNlcm5hbWUiLCJkb21haW4iLCJzcGxpdCIsIm1hc2tlZFVzZXJuYW1lIiwic3Vic3RyaW5nIiwicGhvbmUiLCJkaWdpdHMiLCJyZXBsYWNlIiwiZGF0ZVN0ciIsImRhdGUiLCJkZWZhdWx0RGVkdWN0aWJsZXMiLCJmaWVsZHMiLCJ2YWx1ZXMiLCJ2IiwicmVxdWlyZWRGaWVsZHMiLCJwcmVzZW50UmVxdWlyZWQiLCJmaWVsZCIsInByZXNlbnRUeXBlcyIsImV4cGVjdGVkRG9jdW1lbnRzIiwiZXhwZWN0ZWQiLCJkb2NUeXBlIiwiaGFzIiwicmVjb21tZW5kYXRpb25zIiwicHVzaCIsInNvbWUiLCJhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/agents/nodes/assemblerAgent.ts\n"));

/***/ })

});