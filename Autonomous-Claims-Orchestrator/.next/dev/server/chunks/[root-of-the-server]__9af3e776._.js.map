{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/ingestedClaims.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nconst DATA_DIR = path.join(process.cwd(), 'data')\nconst INGESTED_DIR = path.join(DATA_DIR, 'ingested-attachments')\nconst CLAIMS_FILE = path.join(DATA_DIR, 'ingested-claims.json')\n\nexport interface IngestedAttachment {\n  name: string\n  path: string\n  size: number\n  mimeType: string\n}\n\nexport interface IngestedClaim {\n  id: string\n  policyNumber: string\n  from: string\n  to: string\n  subject: string\n  emailBody: string\n  attachments: IngestedAttachment[]\n  createdAt: string\n  source: 'sendgrid' | 'demo' | 'imap'\n}\n\nfunction ensureDataDir() {\n  if (!fs.existsSync(DATA_DIR)) {\n    fs.mkdirSync(DATA_DIR, { recursive: true })\n  }\n  if (!fs.existsSync(INGESTED_DIR)) {\n    fs.mkdirSync(INGESTED_DIR, { recursive: true })\n  }\n}\n\nfunction getClaimsData(): IngestedClaim[] {\n  ensureDataDir()\n  if (!fs.existsSync(CLAIMS_FILE)) {\n    return []\n  }\n  try {\n    const content = fs.readFileSync(CLAIMS_FILE, 'utf-8')\n    return JSON.parse(content)\n  } catch {\n    return []\n  }\n}\n\nfunction saveClaimsData(claims: IngestedClaim[]) {\n  ensureDataDir()\n  fs.writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8')\n}\n\n/** Extract policy number from email body using common patterns */\nexport function extractPolicyNumber(emailBody: string): string | null {\n  const patterns = [\n    /policy\\s*#?\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /policy\\s*number\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /Policy\\s*#([A-Z0-9]+)/i,\n    /#([A-Z]{2}\\d{6,})/,\n    /\\b([A-Z]{2}\\d{6,})\\b/,\n  ]\n  for (const pattern of patterns) {\n    const match = emailBody.match(pattern)\n    if (match && match[1]) {\n      return match[1]\n    }\n  }\n  return null\n}\n\n/** Save an ingested claim (from SendGrid, IMAP, or other source) */\nexport function saveIngestedClaim(\n  from: string,\n  to: string,\n  subject: string,\n  emailBody: string,\n  attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }>,\n  source: 'sendgrid' | 'imap' = 'sendgrid'\n): IngestedClaim {\n  const policyNumber = extractPolicyNumber(emailBody) || extractPolicyNumber(subject) || 'UNKNOWN'\n  const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n\n  ensureDataDir()\n  const claimDir = path.join(INGESTED_DIR, claimId)\n  fs.mkdirSync(claimDir, { recursive: true })\n\n  const attachments: IngestedAttachment[] = []\n  for (const file of attachmentFiles) {\n    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')\n    const filePath = path.join(claimDir, safeName)\n    fs.writeFileSync(filePath, file.buffer)\n    attachments.push({\n      name: file.name,\n      path: filePath,\n      size: file.buffer.length,\n      mimeType: file.mimeType || 'application/octet-stream',\n    })\n  }\n\n  const claim: IngestedClaim = {\n    id: claimId,\n    policyNumber,\n    from,\n    to,\n    subject,\n    emailBody,\n    attachments,\n    createdAt: new Date().toISOString(),\n    source,\n  }\n\n  const claims = getClaimsData()\n  claims.unshift(claim)\n  saveClaimsData(claims)\n  return claim\n}\n\n/** Get all ingested claims (for dropdown). Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getAllIngestedClaims(): IngestedClaim[] {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  if (hasRealClaims) {\n    return claims.filter((c) => c.source !== 'demo')\n  }\n  return claims\n}\n\n/** Get a single claim by ID */\nexport function getIngestedClaimById(id: string): IngestedClaim | null {\n  const claims = getClaimsData()\n  return claims.find((c) => c.id === id) || null\n}\n\n/** Get distinct policy numbers for dropdown. Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getPolicyNumbers(): Array<{ id: string; policyNumber: string; subject: string }> {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  const toShow = hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n  return toShow.map((c) => ({\n    id: c.id,\n    policyNumber: c.policyNumber,\n    subject: c.subject,\n  }))\n}\n\n/** Seed demo claims from scenarios folder when no claims exist */\nfunction seedDemoClaims() {\n  const scenariosDir = path.join(process.cwd(), 'demo-data', 'scenarios')\n  if (!fs.existsSync(scenariosDir)) return\n\n  const scenarios = [\n    { folder: 'auto-collision', policyNumber: 'AC789456123', from: 'sarah.johnson@email.com', to: 'pranay.nath@aimill.in', subject: 'Car Accident Claim - Policy #AC789456123' },\n    { folder: 'commercial-liability', policyNumber: 'CL789012345', from: 'antonio.martinez@tonysrestaurant.com', to: 'pranay.nath@aimill.in', subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345' },\n    { folder: 'property-water-damage', policyNumber: 'HO456789234', from: 'robert.chen@email.com', to: 'pranay.nath@aimill.in', subject: 'Urgent - Water Damage Claim - Policy #HO456789234' },\n  ]\n\n  const claims: IngestedClaim[] = []\n  const baseTime = Date.now() - 86400000 * 2\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const s = scenarios[i]\n    const emailPath = path.join(scenariosDir, s.folder, 'email.txt')\n    const attachmentsDir = path.join(scenariosDir, s.folder, 'attachments')\n    if (!fs.existsSync(emailPath)) continue\n\n    const emailBody = fs.readFileSync(emailPath, 'utf-8')\n    const claimId = `DEMO-${s.policyNumber}-${i}`\n    const claimDir = path.join(INGESTED_DIR, claimId)\n    fs.mkdirSync(claimDir, { recursive: true })\n\n    const attachments: IngestedAttachment[] = []\n    if (fs.existsSync(attachmentsDir)) {\n      for (const file of fs.readdirSync(attachmentsDir)) {\n        const srcPath = path.join(attachmentsDir, file)\n        if (fs.statSync(srcPath).isFile()) {\n          const destPath = path.join(claimDir, file)\n          fs.copyFileSync(srcPath, destPath)\n          attachments.push({ name: file, path: destPath, size: fs.statSync(destPath).size, mimeType: 'text/plain' })\n        }\n      }\n    }\n\n    claims.push({\n      id: claimId,\n      policyNumber: s.policyNumber,\n      from: s.from,\n      to: s.to,\n      subject: s.subject,\n      emailBody,\n      attachments,\n      createdAt: new Date(baseTime + i * 3600000).toISOString(),\n      source: 'demo',\n    })\n  }\n\n  if (claims.length > 0) {\n    saveClaimsData(claims)\n  }\n}\n\n/** Clear all ingested claims and attachments (for fresh start) */\nexport function clearAllIngestedClaims(): void {\n  ensureDataDir()\n  if (fs.existsSync(CLAIMS_FILE)) fs.unlinkSync(CLAIMS_FILE)\n  if (fs.existsSync(INGESTED_DIR)) {\n    for (const entry of fs.readdirSync(INGESTED_DIR, { withFileTypes: true })) {\n      const fullPath = path.join(INGESTED_DIR, entry.name)\n      if (entry.isDirectory()) {\n        fs.rmSync(fullPath, { recursive: true })\n      }\n    }\n  }\n}\n\n/** Read attachment file content for processing (text files) */\nexport function readAttachmentContent(claimId: string, attachmentName: string): string {\n  const claim = getIngestedClaimById(claimId)\n  if (!claim) throw new Error('Claim not found')\n  const att = claim.attachments.find((a) => a.name === attachmentName)\n  if (!att || !fs.existsSync(att.path)) throw new Error('Attachment not found')\n  const ext = path.extname(att.name).toLowerCase()\n  if (['.txt', '.csv', '.log'].includes(ext)) {\n    return fs.readFileSync(att.path, 'utf-8')\n  }\n  return `[Document: ${att.name} - content extracted for processing]`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 297, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/services/openai.ts"],"sourcesContent":["import OpenAI from 'openai'\n\n// Initialize OpenAI client\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY || '',\n  dangerouslyAllowBrowser: true // For demo purposes - in production, use server-side API routes\n})\n\nexport interface FunctionCall {\n  name: string\n  description: string\n  parameters: {\n    type: 'object'\n    properties: Record<string, any>\n    required: string[]\n  }\n}\n\nexport interface LLMResponse {\n  content: string\n  functionCalls?: Array<{\n    name: string\n    arguments: Record<string, any>\n  }>\n}\n\nexport class OpenAIService {\n  private model: string\n  private temperature: number\n\n  constructor(model: string = 'gpt-4-1106-preview', temperature: number = 0.1) {\n    this.model = model\n    this.temperature = temperature\n  }\n\n  async callLLM(\n    prompt: string,\n    systemPrompt?: string,\n    functions?: FunctionCall[]\n  ): Promise<LLMResponse> {\n    try {\n      const messages: any[] = []\n      \n      if (systemPrompt) {\n        messages.push({ role: 'system', content: systemPrompt })\n      }\n      \n      messages.push({ role: 'user', content: prompt })\n\n      const requestConfig: any = {\n        model: this.model,\n        messages,\n        temperature: this.temperature,\n        max_tokens: 2000\n      }\n\n      // Add function calling if functions are provided\n      if (functions && functions.length > 0) {\n        requestConfig.functions = functions\n        requestConfig.function_call = 'auto'\n      }\n\n      const response = await openai.chat.completions.create(requestConfig)\n      \n      const choice = response.choices[0]\n      \n      if (!choice) {\n        throw new Error('No response from OpenAI')\n      }\n\n      const result: LLMResponse = {\n        content: choice.message?.content || ''\n      }\n\n      // Handle function calls\n      if (choice.message?.function_call) {\n        result.functionCalls = [{\n          name: choice.message.function_call.name,\n          arguments: JSON.parse(choice.message.function_call.arguments || '{}')\n        }]\n      }\n\n      return result\n    } catch (error) {\n      console.error('OpenAI API call failed:', error)\n      throw new Error(`OpenAI API call failed: ${error}`)\n    }\n  }\n\n  async extractClaimFields(emailText: string, documents: string[]): Promise<Record<string, any>> {\n    const systemPrompt = `You are an expert insurance claims processor. Extract structured claim information from the provided email and documents. Be precise and only extract information that is explicitly stated or can be confidently inferred.`\n\n    const prompt = `Extract claim fields from this FNOL email and attachments:\n\nEMAIL:\n${emailText}\n\nDOCUMENTS:\n${documents.join('\\n\\n---\\n\\n')}\n\nExtract the following fields if present:\n- policyNumber: Insurance policy number\n- claimantName: Name of the person filing the claim\n- contactEmail: Contact email address\n- contactPhone: Contact phone number\n- lossDate: Date when the loss occurred (YYYY-MM-DD format)\n- lossType: Type of loss (Collision, Water, Fire, Theft, Liability, Other)\n- lossLocation: Where the loss occurred\n- description: Brief description of what happened\n- vehicleInfo: If auto claim - year, make, model, license plate\n- propertyAddress: If property claim - property address\n- estimatedDamage: Estimated damage amount if mentioned\n\nReturn ONLY a JSON object with the extracted fields. Use null for missing fields.`\n\n    const functions: FunctionCall[] = [{\n      name: 'extract_claim_fields',\n      description: 'Extract structured claim information from email and documents',\n      parameters: {\n        type: 'object',\n        properties: {\n          policyNumber: { type: 'string', description: 'Insurance policy number' },\n          claimantName: { type: 'string', description: 'Name of claimant' },\n          contactEmail: { type: 'string', description: 'Contact email' },\n          contactPhone: { type: 'string', description: 'Contact phone number' },\n          lossDate: { type: 'string', description: 'Loss date in YYYY-MM-DD format' },\n          lossType: { \n            type: 'string', \n            enum: ['Collision', 'Water', 'Fire', 'Theft', 'Liability', 'Other'],\n            description: 'Type of loss'\n          },\n          lossLocation: { type: 'string', description: 'Location where loss occurred' },\n          description: { type: 'string', description: 'Description of what happened' },\n          vehicleInfo: { \n            type: 'object',\n            properties: {\n              year: { type: 'string' },\n              make: { type: 'string' },\n              model: { type: 'string' },\n              licensePlate: { type: 'string' }\n            },\n            description: 'Vehicle information for auto claims'\n          },\n          propertyAddress: { type: 'string', description: 'Property address for property claims' },\n          estimatedDamage: { type: 'number', description: 'Estimated damage amount' }\n        },\n        required: []\n      }\n    }]\n\n    const response = await this.callLLM(prompt, systemPrompt, functions)\n    \n    if (response.functionCalls && response.functionCalls.length > 0) {\n      return response.functionCalls[0].arguments\n    }\n    \n    // Fallback: try to parse JSON from content\n    try {\n      return JSON.parse(response.content)\n    } catch {\n      throw new Error('Failed to extract structured claim fields from LLM response')\n    }\n  }\n\n  async classifyDocument(filename: string, content: string): Promise<{\n    type: string\n    confidence: number\n    keyFields: Record<string, any>\n  }> {\n    const systemPrompt = `You are a document classification expert for insurance claims. Classify the document type and extract key fields.`\n\n    const prompt = `Classify this document and extract key information:\n\nFILENAME: ${filename}\nCONTENT:\n${content.substring(0, 2000)}...\n\nClassify the document type as one of:\n- PoliceReport\n- RepairEstimate  \n- Invoice\n- MedicalRecord\n- IncidentReport\n- DamagePhoto\n- Other\n\nAlso extract relevant key fields based on the document type.`\n\n    const functions: FunctionCall[] = [{\n      name: 'classify_document',\n      description: 'Classify document type and extract key fields',\n      parameters: {\n        type: 'object',\n        properties: {\n          type: {\n            type: 'string',\n            enum: ['PoliceReport', 'RepairEstimate', 'Invoice', 'MedicalRecord', 'IncidentReport', 'DamagePhoto', 'Other'],\n            description: 'Document type classification'\n          },\n          confidence: {\n            type: 'number',\n            minimum: 0,\n            maximum: 1,\n            description: 'Confidence score for classification'\n          },\n          keyFields: {\n            type: 'object',\n            description: 'Key fields extracted from the document'\n          }\n        },\n        required: ['type', 'confidence', 'keyFields']\n      }\n    }]\n\n    const response = await this.callLLM(prompt, systemPrompt, functions)\n    \n    if (response.functionCalls && response.functionCalls.length > 0) {\n      const args = response.functionCalls[0].arguments\n      return {\n        type: args.type || 'Other',\n        confidence: args.confidence || 0.5,\n        keyFields: args.keyFields || {}\n      }\n    }\n    \n    // Fallback classification\n    return {\n      type: 'Other',\n      confidence: 0.5,\n      keyFields: {}\n    }\n  }\n\n  async generateFieldEvidence(\n    fieldName: string, \n    value: any, \n    emailText: string, \n    documents: string[]\n  ): Promise<{\n    confidence: number\n    sourceLocator: string\n    rationale: string\n  }> {\n    const systemPrompt = `You are an evidence analyst for insurance claims. Identify the source and rationale for extracted field values.`\n\n    const prompt = `Analyze the evidence for this extracted field:\n\nFIELD: ${fieldName}\nVALUE: ${value}\n\nSOURCE TEXT:\nEMAIL: ${emailText}\n\nDOCUMENTS:\n${documents.join('\\n\\n---\\n\\n')}\n\nProvide:\n1. Confidence score (0-1) for this field extraction\n2. Source locator (where in the text this value was found)\n3. Brief rationale explaining why this value was extracted`\n\n    const functions: FunctionCall[] = [{\n      name: 'analyze_field_evidence',\n      description: 'Analyze evidence for extracted field',\n      parameters: {\n        type: 'object',\n        properties: {\n          confidence: {\n            type: 'number',\n            minimum: 0,\n            maximum: 1,\n            description: 'Confidence score for field extraction'\n          },\n          sourceLocator: {\n            type: 'string',\n            description: 'Location where value was found (e.g., email_text:100-150, doc1:50-75)'\n          },\n          rationale: {\n            type: 'string',\n            description: 'Brief explanation of why this value was extracted'\n          }\n        },\n        required: ['confidence', 'sourceLocator', 'rationale']\n      }\n    }]\n\n    const response = await this.callLLM(prompt, systemPrompt, functions)\n    \n    if (response.functionCalls && response.functionCalls.length > 0) {\n      const args = response.functionCalls[0].arguments\n      return {\n        confidence: args.confidence || 0.7,\n        sourceLocator: args.sourceLocator || 'text_inference',\n        rationale: args.rationale || 'Inferred from document context'\n      }\n    }\n    \n    // Fallback evidence\n    return {\n      confidence: 0.7,\n      sourceLocator: 'text_inference',\n      rationale: 'Inferred from document context'\n    }\n  }\n\n  async queryPolicyDatabase(\n    lossType: string,\n    description: string,\n    extractedFields: Record<string, any>\n  ): Promise<Array<{\n    clauseId: string\n    title: string\n    similarity: number\n    rationale: string\n  }>> {\n    const systemPrompt = `You are a policy database search expert. Given claim information, identify the most relevant policy clauses.`\n\n    const prompt = `Find relevant policy clauses for this claim:\n\nLOSS TYPE: ${lossType}\nDESCRIPTION: ${description}\nEXTRACTED FIELDS: ${JSON.stringify(extractedFields, null, 2)}\n\nBased on this information, identify which of these policy clauses are most relevant:\n\nAUTO INSURANCE:\n- AUTO-COL-001: Collision Coverage - covers vehicle collisions\n- AUTO-LIAB-001: Bodily Injury Liability - covers injury to others\n- AUTO-PD-001: Property Damage Liability - covers damage to others' property\n\nHOMEOWNERS:\n- HO-WATER-001: Water Damage Coverage - covers sudden water damage\n- HO-STORM-001: Wind and Hail Coverage - covers storm damage\n\nCOMMERCIAL LIABILITY:\n- CGL-SLIP-001: Premises Liability Coverage - covers slip and fall\n- CGL-MED-001: Medical Payments Coverage - covers medical expenses\n\nReturn the top 3 most relevant clauses with similarity scores.`\n\n    const functions: FunctionCall[] = [{\n      name: 'query_policy_clauses',\n      description: 'Find relevant policy clauses for the claim',\n      parameters: {\n        type: 'object',\n        properties: {\n          relevantClauses: {\n            type: 'array',\n            items: {\n              type: 'object',\n              properties: {\n                clauseId: { type: 'string', description: 'Policy clause ID' },\n                title: { type: 'string', description: 'Clause title' },\n                similarity: { \n                  type: 'number', \n                  minimum: 0, \n                  maximum: 1,\n                  description: 'Similarity score to the claim'\n                },\n                rationale: { type: 'string', description: 'Why this clause is relevant' }\n              },\n              required: ['clauseId', 'title', 'similarity', 'rationale']\n            },\n            maxItems: 3\n          }\n        },\n        required: ['relevantClauses']\n      }\n    }]\n\n    const response = await this.callLLM(prompt, systemPrompt, functions)\n    \n    if (response.functionCalls && response.functionCalls.length > 0) {\n      return response.functionCalls[0].arguments.relevantClauses || []\n    }\n    \n    return []\n  }\n\n  async summarizeProcessing(\n    extractedFields: Record<string, any>,\n    documents: any[],\n    policyHits: any[]\n  ): Promise<{\n    summary: string\n    recommendations: string[]\n    riskFlags: string[]\n  }> {\n    const systemPrompt = `You are a claims processing supervisor. Summarize the automated processing results and provide recommendations.`\n\n    const prompt = `Summarize this automated claim processing:\n\nEXTRACTED FIELDS:\n${JSON.stringify(extractedFields, null, 2)}\n\nDOCUMENTS PROCESSED: ${documents.length}\nDOCUMENT TYPES: ${documents.map(d => d.type).join(', ')}\n\nPOLICY HITS: ${policyHits.length}\nTOP POLICY MATCH: ${policyHits[0]?.title || 'None'}\n\nProvide:\n1. A brief summary of the claim\n2. Recommendations for next steps\n3. Any risk flags or concerns`\n\n    const functions: FunctionCall[] = [{\n      name: 'summarize_claim_processing',\n      description: 'Summarize claim processing results',\n      parameters: {\n        type: 'object',\n        properties: {\n          summary: {\n            type: 'string',\n            description: 'Brief summary of the claim and processing'\n          },\n          recommendations: {\n            type: 'array',\n            items: { type: 'string' },\n            description: 'Recommended next steps'\n          },\n          riskFlags: {\n            type: 'array',\n            items: { type: 'string' },\n            description: 'Risk flags or concerns identified'\n          }\n        },\n        required: ['summary', 'recommendations', 'riskFlags']\n      }\n    }]\n\n    const response = await this.callLLM(prompt, systemPrompt, functions)\n    \n    if (response.functionCalls && response.functionCalls.length > 0) {\n      const args = response.functionCalls[0].arguments\n      return {\n        summary: args.summary || 'Claim processed automatically with extracted information.',\n        recommendations: args.recommendations || ['Review extracted information', 'Verify policy coverage'],\n        riskFlags: args.riskFlags || []\n      }\n    }\n    \n    return {\n      summary: 'Claim processed automatically with extracted information.',\n      recommendations: ['Review extracted information', 'Verify policy coverage'],\n      riskFlags: []\n    }\n  }\n}\n\n// Export singleton instance\nexport const openaiService = new OpenAIService()"],"names":[],"mappings":"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"}},
    {"offset": {"line": 769, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/agents/nodes/ingestionAgent.ts"],"sourcesContent":["import { AgentState, AgentConfig, UploadedFile } from '../types'\nimport { DocumentType } from '@/types/claims'\nimport { openaiService } from '@/lib/services/openai'\n\nexport class IngestionAgent {\n  async execute(state: AgentState, config: AgentConfig): Promise<Partial<AgentState>> {\n    const startTime = Date.now()\n    \n    try {\n      // Log ingestion start\n      const auditEvent = {\n        step: 'ingestion',\n        timestamp: new Date().toISOString(),\n        duration: 0,\n        agent: 'IngestionAgent',\n        status: 'started' as const,\n        details: {\n          emailLength: state.emailText.length,\n          fileCount: state.files.length,\n          files: state.files.map(f => ({ name: f.name, size: f.size, type: f.mimeType }))\n        }\n      }\n\n      // Normalize email text\n      const normalizedEmail = this.normalizeEmailText(state.emailText)\n      \n      // Process and classify attachments\n      const documents = await this.processAttachments(state.files)\n      \n      // Extract basic metadata\n      const metadata = this.extractEmailMetadata(normalizedEmail)\n      \n      const duration = Date.now() - startTime\n      \n      return {\n        currentStep: 'Document Classification',\n        documents,\n        auditEvents: [...state.auditEvents, {\n          ...auditEvent,\n          duration,\n          status: 'completed',\n          details: {\n            ...auditEvent.details,\n            documentsProcessed: documents.length,\n            metadata\n          }\n        }]\n      }\n    } catch (error) {\n      const duration = Date.now() - startTime\n      \n      return {\n        errors: [...state.errors, `Ingestion failed: ${error}`],\n        auditEvents: [...state.auditEvents, {\n          step: 'ingestion',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'IngestionAgent',\n          status: 'failed',\n          details: { error: String(error) }\n        }]\n      }\n    }\n  }\n\n  private normalizeEmailText(emailText: string): string {\n    // Remove forwarding headers, normalize whitespace\n    return emailText\n      .replace(/^(From:|To:|Subject:|Date:).*$/gm, '') // Remove headers\n      .replace(/\\s+/g, ' ') // Normalize whitespace\n      .trim()\n  }\n\n  private async processAttachments(files: UploadedFile[]): Promise<any[]> {\n    const documents = []\n    \n    for (const file of files) {\n      // Simulate OCR/text extraction\n      const extractedText = await this.simulateOCR(file)\n      \n      try {\n        // Use OpenAI for document classification\n        const classification = await openaiService.classifyDocument(file.name, extractedText)\n        \n        documents.push({\n          id: `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          name: file.name,\n          type: classification.type as DocumentType,\n          mimeType: file.mimeType,\n          content: extractedText,\n          confidence: classification.confidence,\n          keyFields: classification.keyFields,\n          metadata: {\n            size: file.size,\n            processedAt: new Date().toISOString(),\n            classificationMethod: 'openai'\n          }\n        })\n      } catch (error) {\n        // Fallback to rule-based classification\n        console.warn(`OpenAI classification failed for ${file.name}, using fallback:`, error)\n        const docType = this.classifyDocument(file.name, extractedText)\n        \n        documents.push({\n          id: `doc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          name: file.name,\n          type: docType,\n          mimeType: file.mimeType,\n          content: extractedText,\n          confidence: this.calculateConfidence(file.name, extractedText, docType),\n          keyFields: {},\n          metadata: {\n            size: file.size,\n            processedAt: new Date().toISOString(),\n            classificationMethod: 'rule_based_fallback'\n          }\n        })\n      }\n    }\n    \n    return documents\n  }\n\n  private async simulateOCR(file: UploadedFile): Promise<string> {\n    // In a real implementation, this would call Azure Form Recognizer or AWS Textract\n    // For demo, we return the provided content (which simulates extracted text)\n    \n    // Add some realistic OCR processing delay\n    await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000))\n    \n    return file.content || `[OCR extracted content from ${file.name}]`\n  }\n\n  private classifyDocument(fileName: string, content: string): DocumentType {\n    const name = fileName.toLowerCase()\n    const text = content.toLowerCase()\n    \n    // Rule-based classification\n    if (name.includes('police') || text.includes('police report') || text.includes('officer')) {\n      return 'PoliceReport'\n    }\n    if (name.includes('estimate') || name.includes('repair') || text.includes('estimate') || text.includes('labor')) {\n      return 'RepairEstimate'\n    }\n    if (name.includes('invoice') || name.includes('bill') || text.includes('invoice') || text.includes('total due')) {\n      return 'Invoice'\n    }\n    if (name.includes('photo') || name.includes('image') || name.includes('damage') || text.includes('photo')) {\n      return 'DamagePhoto'\n    }\n    if (name.includes('medical') || text.includes('hospital') || text.includes('patient') || text.includes('diagnosis')) {\n      return 'MedicalRecord'\n    }\n    \n    return 'Other'\n  }\n\n  private calculateConfidence(fileName: string, content: string, docType: DocumentType): number {\n    // Simple confidence scoring based on keyword matches\n    let confidence = 0.6 // Base confidence\n    \n    const keywords = this.getKeywordsForDocType(docType)\n    const text = (fileName + ' ' + content).toLowerCase()\n    \n    for (const keyword of keywords) {\n      if (text.includes(keyword)) {\n        confidence += 0.1\n      }\n    }\n    \n    return Math.min(confidence, 1.0)\n  }\n\n  private getKeywordsForDocType(docType: DocumentType): string[] {\n    const keywordMap: Record<DocumentType, string[]> = {\n      PoliceReport: ['police', 'officer', 'badge', 'incident', 'citation', 'vehicle'],\n      RepairEstimate: ['estimate', 'repair', 'labor', 'parts', 'total', 'damage'],\n      Invoice: ['invoice', 'bill', 'payment', 'due', 'amount', 'services'],\n      DamagePhoto: ['photo', 'image', 'damage', 'picture', 'scene'],\n      MedicalRecord: ['hospital', 'patient', 'diagnosis', 'treatment', 'doctor', 'medical'],\n      IncidentReport: ['incident', 'report', 'accident', 'occurred', 'witness', 'details'],\n      Other: []\n    }\n    \n    return keywordMap[docType] || []\n  }\n\n  private extractEmailMetadata(emailText: string): Record<string, any> {\n    const lines = emailText.split('\\n')\n    const metadata: Record<string, any> = {}\n    \n    // Extract basic email components\n    for (const line of lines) {\n      if (line.startsWith('Subject:')) {\n        metadata.subject = line.replace('Subject:', '').trim()\n      }\n      if (line.startsWith('From:')) {\n        metadata.from = line.replace('From:', '').trim()\n      }\n      if (line.startsWith('Date:')) {\n        metadata.date = line.replace('Date:', '').trim()\n      }\n    }\n    \n    return metadata\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1009, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/agents/nodes/extractionAgent.ts"],"sourcesContent":["import { AgentState, AgentConfig } from '../types'\nimport { FieldEvidence, LossType } from '@/types/claims'\nimport { openaiService } from '@/lib/services/openai'\n\nexport class ExtractionAgent {\n  async execute(state: AgentState, config: AgentConfig): Promise<Partial<AgentState>> {\n    const startTime = Date.now()\n    \n    try {\n      // Extract claim fields using real OpenAI API\n      const extractedFields = await this.extractClaimFields(state.emailText, state.documents)\n      \n      // Generate evidence for each field using OpenAI\n      const fieldEvidence = await this.generateFieldEvidence(extractedFields, state.emailText, state.documents)\n      \n      const duration = Date.now() - startTime\n      \n      return {\n        currentStep: 'Policy Grounding',\n        extractedFields,\n        fieldEvidence,\n        auditEvents: [...state.auditEvents, {\n          step: 'extraction',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'ExtractionAgent',\n          status: 'completed',\n          details: {\n            fieldsExtracted: Object.keys(extractedFields).length,\n            evidenceCount: fieldEvidence.length,\n            avgConfidence: fieldEvidence.reduce((sum, e) => sum + e.confidence, 0) / fieldEvidence.length,\n            llmModel: config.llmModel\n          }\n        }]\n      }\n    } catch (error) {\n      const duration = Date.now() - startTime\n      \n      // Fallback to rule-based extraction if OpenAI fails\n      console.warn('OpenAI extraction failed, falling back to rule-based extraction:', error)\n      const fallbackFields = await this.extractClaimFieldsFallback(state.emailText, state.documents)\n      const fallbackEvidence = await this.generateFieldEvidenceFallback(fallbackFields, state.emailText, state.documents)\n      \n      return {\n        currentStep: 'Policy Grounding',\n        extractedFields: fallbackFields,\n        fieldEvidence: fallbackEvidence,\n        warnings: [...state.warnings, 'OpenAI extraction failed, used fallback extraction'],\n        auditEvents: [...state.auditEvents, {\n          step: 'extraction',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'ExtractionAgent',\n          status: 'completed_with_fallback',\n          details: { \n            error: String(error),\n            fallbackUsed: true,\n            fieldsExtracted: Object.keys(fallbackFields).length\n          }\n        }]\n      }\n    }\n  }\n\n  private async extractClaimFields(emailText: string, documents: any[]): Promise<Record<string, any>> {\n    try {\n      // Use OpenAI to extract claim fields\n      const documentContents = documents.map(d => d.content || '')\n      const extractedFields = await openaiService.extractClaimFields(emailText, documentContents)\n      \n      // Validate and clean the extracted fields\n      return this.validateAndCleanFields(extractedFields)\n    } catch (error) {\n      console.error('OpenAI extraction failed:', error)\n      throw error\n    }\n  }\n\n  private async extractClaimFieldsFallback(emailText: string, documents: any[]): Promise<Record<string, any>> {\n    // Fallback to rule-based extraction\n    const allText = emailText + '\\n\\n' + documents.map(d => d.content).join('\\n\\n')\n    \n    return {\n      policyNumber: this.extractPolicyNumber(allText),\n      claimantName: this.extractClaimantName(allText),\n      contactEmail: this.extractContactEmail(allText),\n      contactPhone: this.extractContactPhone(allText),\n      lossDate: this.extractLossDate(allText),\n      lossType: this.extractLossType(allText),\n      lossLocation: this.extractLossLocation(allText),\n      description: this.extractDescription(allText),\n      vehicleInfo: this.extractVehicleInfo(allText),\n      propertyAddress: this.extractPropertyAddress(allText),\n      estimatedDamage: this.extractEstimatedDamage(allText)\n    }\n  }\n\n  private async generateFieldEvidence(\n    fields: Record<string, any>, \n    emailText: string, \n    documents: any[]\n  ): Promise<FieldEvidence[]> {\n    const evidence: FieldEvidence[] = []\n    const documentContents = documents.map(d => d.content || '')\n    \n    for (const [fieldName, value] of Object.entries(fields)) {\n      if (value) {\n        try {\n          // Use OpenAI to generate evidence analysis\n          const evidenceAnalysis = await openaiService.generateFieldEvidence(\n            fieldName, \n            value, \n            emailText, \n            documentContents\n          )\n          \n          evidence.push({\n            field: fieldName,\n            value: String(value),\n            confidence: evidenceAnalysis.confidence,\n            sourceLocator: evidenceAnalysis.sourceLocator,\n            rationale: evidenceAnalysis.rationale\n          })\n        } catch (error) {\n          // Fallback to rule-based evidence\n          const sourceEvidence = this.findTextEvidence(fieldName, value, emailText + '\\n\\n' + documentContents.join('\\n\\n'), documents)\n          evidence.push({\n            field: fieldName,\n            value: String(value),\n            confidence: sourceEvidence.confidence,\n            sourceLocator: sourceEvidence.locator,\n            rationale: sourceEvidence.rationale\n          })\n        }\n      }\n    }\n    \n    return evidence\n  }\n\n  private async generateFieldEvidenceFallback(\n    fields: Record<string, any>, \n    emailText: string, \n    documents: any[]\n  ): Promise<FieldEvidence[]> {\n    const evidence: FieldEvidence[] = []\n    const allText = emailText + '\\n\\n' + documents.map(d => d.content).join('\\n\\n')\n    \n    for (const [fieldName, value] of Object.entries(fields)) {\n      if (value) {\n        const sourceEvidence = this.findTextEvidence(fieldName, value, allText, documents)\n        evidence.push({\n          field: fieldName,\n          value: String(value),\n          confidence: sourceEvidence.confidence,\n          sourceLocator: sourceEvidence.locator,\n          rationale: sourceEvidence.rationale\n        })\n      }\n    }\n    \n    return evidence\n  }\n\n  private validateAndCleanFields(fields: Record<string, any>): Record<string, any> {\n    const cleaned: Record<string, any> = {}\n    \n    // Clean and validate each field\n    for (const [key, value] of Object.entries(fields)) {\n      if (value !== null && value !== undefined && value !== '') {\n        switch (key) {\n          case 'policyNumber':\n            cleaned[key] = this.maskPolicyNumber(String(value))\n            break\n          case 'contactEmail':\n            cleaned[key] = this.maskEmail(String(value))\n            break\n          case 'contactPhone':\n            cleaned[key] = this.maskPhone(String(value))\n            break\n          case 'lossDate':\n            cleaned[key] = this.validateDate(String(value))\n            break\n          case 'estimatedDamage':\n            cleaned[key] = this.validateAmount(value)\n            break\n          default:\n            cleaned[key] = value\n        }\n      }\n    }\n    \n    return cleaned\n  }\n\n  private maskPolicyNumber(policyNumber: string): string {\n    // Mask policy number for privacy (show only last 3 digits)\n    return policyNumber.length > 3 ? \n      '*'.repeat(policyNumber.length - 3) + policyNumber.slice(-3) :\n      policyNumber\n  }\n\n  private maskEmail(email: string): string {\n    const [username, domain] = email.split('@')\n    if (!domain) return email\n    \n    const maskedUsername = username.length > 4 ?\n      username.substring(0, 2) + '*'.repeat(username.length - 4) + username.slice(-2) :\n      username\n    \n    return `${maskedUsername}@${domain}`\n  }\n\n  private maskPhone(phone: string): string {\n    // Show only last 4 digits\n    const digits = phone.replace(/\\D/g, '')\n    return digits.length > 4 ? \n      '*'.repeat(digits.length - 4) + digits.slice(-4) :\n      phone\n  }\n\n  private validateDate(dateStr: string): string {\n    try {\n      const date = new Date(dateStr)\n      return date.toISOString().split('T')[0] // YYYY-MM-DD format\n    } catch {\n      return dateStr // Return original if parsing fails\n    }\n  }\n\n  private validateAmount(amount: any): number | null {\n    const num = typeof amount === 'number' ? amount : parseFloat(String(amount))\n    return isNaN(num) ? null : num\n  }\n\n  private findTextEvidence(fieldName: string, value: any, allText: string, documents: any[]): {\n    confidence: number\n    locator: string\n    rationale: string\n  } {\n    const valueStr = String(value).toLowerCase()\n    const text = allText.toLowerCase()\n    \n    // Find exact matches first\n    if (text.includes(valueStr)) {\n      const index = text.indexOf(valueStr)\n      const context = allText.substring(Math.max(0, index - 50), index + valueStr.length + 50)\n      \n      return {\n        confidence: 0.95,\n        locator: `text_offset:${index}-${index + valueStr.length}`,\n        rationale: `Direct text match found: \"${context.trim()}\"`\n      }\n    }\n    \n    // Pattern-based matching for specific field types\n    return this.getPatternBasedEvidence(fieldName, value, allText)\n  }\n\n  private getPatternBasedEvidence(fieldName: string, value: any, text: string): {\n    confidence: number\n    locator: string\n    rationale: string\n  } {\n    switch (fieldName) {\n      case 'policyNumber':\n        return {\n          confidence: 0.9,\n          locator: 'pattern_match:policy_format',\n          rationale: 'Matches standard policy number format with prefix and digits'\n        }\n      case 'lossDate':\n        return {\n          confidence: 0.85,\n          locator: 'pattern_match:date_format',\n          rationale: 'Extracted from date context in incident description'\n        }\n      case 'contactEmail':\n        return {\n          confidence: 0.95,\n          locator: 'pattern_match:email_format',\n          rationale: 'Valid email format in sender or contact information'\n        }\n      case 'contactPhone':\n        return {\n          confidence: 0.9,\n          locator: 'pattern_match:phone_format',\n          rationale: 'Standard phone number format with area code'\n        }\n      default:\n        return {\n          confidence: 0.7,\n          locator: 'inference:context',\n          rationale: 'Inferred from contextual information in documents'\n        }\n    }\n  }\n\n  // Field extraction methods\n  private extractPolicyNumber(text: string): string | null {\n    const patterns = [\n      /policy[#\\s]*:?\\s*([A-Z]{2}\\d{9})/i,\n      /policy[#\\s]*:?\\s*([A-Z]{2}\\d{6}\\d{3})/i,\n      /policy[#\\s]*:?\\s*([A-Z]+\\d+)/i\n    ]\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern)\n      if (match) {\n        return match[1]\n      }\n    }\n    return null\n  }\n\n  private extractClaimantName(text: string): string | null {\n    // Look for name in various contexts\n    const patterns = [\n      /(?:from|name|claimant):\\s*([A-Z][a-z]+\\s+[A-Z][a-z]+)/i,\n      /([A-Z][a-z]+\\s+[A-Z][a-z]+)(?:\\s+<?[\\w._%+-]+@[\\w.-]+\\.[A-Z]{2,}>?)/i\n    ]\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern)\n      if (match) {\n        return match[1]\n      }\n    }\n    return null\n  }\n\n  private extractContactEmail(text: string): string | null {\n    const pattern = /[\\w._%+-]+@[\\w.-]+\\.[A-Z]{2,}/i\n    const match = text.match(pattern)\n    return match ? match[0] : null\n  }\n\n  private extractContactPhone(text: string): string | null {\n    const patterns = [\n      /\\(?\\d{3}\\)?[-.\\s]?\\d{3}[-.\\s]?\\d{4}/,\n      /\\d{3}[-.\\s]\\d{3}[-.\\s]\\d{4}/\n    ]\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern)\n      if (match) {\n        return match[0]\n      }\n    }\n    return null\n  }\n\n  private extractLossDate(text: string): string | null {\n    const patterns = [\n      /(?:accident|incident|loss|occurred?).*?(\\d{1,2}\\/\\d{1,2}\\/\\d{4})/i,\n      /(?:march|april|may|june|july|august|september|october|november|december)\\s+\\d{1,2},?\\s+\\d{4}/i\n    ]\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern)\n      if (match) {\n        return match[1] || match[0]\n      }\n    }\n    return null\n  }\n\n  private extractLossType(text: string): LossType {\n    if (/collision|accident|crash|vehicle|car/i.test(text)) {\n      return 'Collision'\n    }\n    if (/water|flood|leak|pipe|storm/i.test(text)) {\n      return 'Water'\n    }\n    if (/fire|burn|smoke/i.test(text)) {\n      return 'Fire'\n    }\n    if (/theft|stolen|burglary/i.test(text)) {\n      return 'Theft'\n    }\n    if (/liability|slip|fall|injury/i.test(text)) {\n      return 'Liability'\n    }\n    return 'Other'\n  }\n\n  private extractLossLocation(text: string): string | null {\n    const patterns = [\n      /(?:at|location|address):\\s*([^,\\n]+(?:,\\s*[^,\\n]+)*)/i,\n      /(\\d+\\s+[A-Za-z\\s]+(?:street|st|avenue|ave|road|rd|drive|dr|lane|ln|boulevard|blvd))/i\n    ]\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern)\n      if (match) {\n        return match[1].trim()\n      }\n    }\n    return null\n  }\n\n  private extractDescription(text: string): string | null {\n    // Extract the main incident description\n    const sentences = text.split(/[.!?]+/)\n    const relevantSentences = sentences.filter(s => \n      /accident|incident|damage|occurred|happened|hit|struck|fell|slip|crash/i.test(s)\n    )\n    \n    return relevantSentences.slice(0, 3).join('. ').trim() || null\n  }\n\n  private extractVehicleInfo(text: string): Record<string, any> | null {\n    const yearMatch = text.match(/\\b(19|20)\\d{2}\\b/)\n    const makeMatch = text.match(/\\b(Honda|Toyota|Ford|Chevrolet|BMW|Mercedes|Audi|Nissan|Hyundai|Kia|Mazda|Subaru|Volkswagen|Volvo|Lexus|Acura|Infiniti|Cadillac|Buick|GMC|Jeep|Chrysler|Dodge|Ram)\\b/i)\n    const modelMatch = text.match(/\\b(Civic|Accord|Camry|Corolla|F-150|Silverado|Malibu|Escape|Explorer|CR-V|Pilot|Altima|Sentra|Elantra|Sonata|Optima|Soul|CX-5|Outback|Forester|Jetta|Passat|XC90|ES|IS|RX|GS|LS|Q50|Q60|ATS|CTS|Escalade|LaCrosse|Enclave|Sierra|Terrain|Wrangler|Grand Cherokee|Compass|300|Charger|Challenger|1500|2500|3500)\\b/i)\n    const licenseMatch = text.match(/(?:license|plate)[#\\s]*:?\\s*([A-Z0-9-]+)/i)\n    \n    if (yearMatch || makeMatch || modelMatch) {\n      return {\n        year: yearMatch ? yearMatch[0] : null,\n        make: makeMatch ? makeMatch[0] : null,\n        model: modelMatch ? modelMatch[0] : null,\n        licensePlate: licenseMatch ? licenseMatch[1] : null\n      }\n    }\n    \n    return null\n  }\n\n  private extractPropertyAddress(text: string): string | null {\n    const patterns = [\n      /(?:property|home|house|address):\\s*([^,\\n]+(?:,\\s*[A-Z]{2}\\s*\\d{5})?)/i,\n      /(\\d+\\s+[A-Za-z\\s]+(?:street|st|avenue|ave|road|rd|drive|dr|lane|ln|boulevard|blvd)[^,\\n]*(?:,\\s*[A-Za-z\\s]+,?\\s*[A-Z]{2}\\s*\\d{5})?)/i\n    ]\n    \n    for (const pattern of patterns) {\n      const match = text.match(pattern)\n      if (match) {\n        return match[1].trim()\n      }\n    }\n    return null\n  }\n\n  private extractEstimatedDamage(text: string): number | null {\n    const patterns = [\n      /\\$([0-9,]+\\.?\\d*)/g,\n      /([0-9,]+\\.?\\d*)\\s*dollars?/gi\n    ]\n    \n    const amounts: number[] = []\n    for (const pattern of patterns) {\n      let match\n      while ((match = pattern.exec(text)) !== null) {\n        const amount = parseFloat(match[1].replace(/,/g, ''))\n        if (amount > 100 && amount < 100000) { // Reasonable damage range\n          amounts.push(amount)\n        }\n      }\n    }\n    \n    return amounts.length > 0 ? Math.max(...amounts) : null\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1407, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/agents/nodes/policyAgent.ts"],"sourcesContent":["import { AgentState, AgentConfig } from '../types'\nimport { PolicyHit } from '@/types/claims'\nimport { openaiService } from '@/lib/services/openai'\n\nexport class PolicyAgent {\n  private policyDatabase: PolicyClause[]\n\n  constructor() {\n    this.policyDatabase = this.initializePolicyDatabase()\n  }\n\n  async execute(state: AgentState, config: AgentConfig): Promise<Partial<AgentState>> {\n    const startTime = Date.now()\n    \n    try {\n      // Query policy database using extracted fields and document context\n      const policyHits = await this.queryPolicyDatabase(\n        state.extractedFields,\n        state.documents,\n        state.emailText\n      )\n\n      const duration = Date.now() - startTime\n      \n      return {\n        currentStep: 'Decision Assembly',\n        policyHits,\n        auditEvents: [...state.auditEvents, {\n          step: 'policy_grounding',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'PolicyAgent',\n          status: 'completed',\n          details: {\n            clausesFound: policyHits.length,\n            avgSimilarity: policyHits.reduce((sum, h) => sum + (h.similarity || h.score || 0), 0) / policyHits.length,\n            topScore: policyHits.length > 0 ? Math.max(...policyHits.map(h => h.similarity || h.score || 0)) : 0\n          }\n        }]\n      }\n    } catch (error) {\n      const duration = Date.now() - startTime\n      \n      return {\n        errors: [...state.errors, `Policy grounding failed: ${error}`],\n        auditEvents: [...state.auditEvents, {\n          step: 'policy_grounding',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'PolicyAgent',\n          status: 'failed',\n          details: { error: String(error) }\n        }]\n      }\n    }\n  }\n\n  private async queryPolicyDatabase(\n    extractedFields: Record<string, any>,\n    documents: any[],\n    emailText: string\n  ): Promise<PolicyHit[]> {\n    try {\n      // Use OpenAI to find relevant policy clauses\n      const lossType = extractedFields.lossType || 'Other'\n      const description = extractedFields.description || 'Claim submitted'\n      \n      const openaiResults = await openaiService.queryPolicyDatabase(lossType, description, extractedFields)\n      \n      // Convert OpenAI results to full PolicyHit format\n      const policyHits: PolicyHit[] = openaiResults.map(result => {\n        const clause = this.policyDatabase.find(c => c.id === result.clauseId)\n        return {\n          clauseId: result.clauseId,\n          title: result.title,\n          content: clause?.content || 'Policy clause content',\n          similarity: result.similarity,\n          rationale: result.rationale,\n          sourceDocument: clause?.sourceDocument || 'Policy Document',\n          section: clause?.section || 'Section Unknown'\n        }\n      })\n      \n      return policyHits\n    } catch (error) {\n      console.warn('OpenAI policy query failed, using fallback:', error)\n      \n      // Fallback to rule-based policy search\n      await new Promise(resolve => setTimeout(resolve, 800 + Math.random() * 500))\n\n      const searchContext = this.buildSearchContext(extractedFields, documents, emailText)\n      const candidateHits = this.findRelevantClauses(searchContext)\n      \n      const scoredHits = candidateHits.map(clause => ({\n        clauseId: clause.id,\n        title: clause.title,\n        content: clause.content,\n        similarity: this.calculateSimilarity(searchContext, clause),\n        rationale: this.generateRationale(searchContext, clause),\n        sourceDocument: clause.sourceDocument,\n        section: clause.section\n      }))\n\n      return scoredHits\n        .filter(hit => hit.similarity >= 0.6)\n        .sort((a, b) => b.similarity - a.similarity)\n        .slice(0, 5)\n    }\n  }\n\n  private buildSearchContext(\n    extractedFields: Record<string, any>,\n    documents: any[],\n    emailText: string\n  ): string {\n    const context = []\n    \n    // Add loss type and description\n    if (extractedFields.lossType) {\n      context.push(`Loss Type: ${extractedFields.lossType}`)\n    }\n    if (extractedFields.description) {\n      context.push(`Description: ${extractedFields.description}`)\n    }\n    \n    // Add document types as context\n    const docTypes = documents.map(d => d.type).join(', ')\n    if (docTypes) {\n      context.push(`Document Types: ${docTypes}`)\n    }\n    \n    // Add key extracted fields\n    const keyFields = ['vehicleInfo', 'propertyAddress', 'estimatedDamage']\n    for (const field of keyFields) {\n      if (extractedFields[field]) {\n        context.push(`${field}: ${JSON.stringify(extractedFields[field])}`)\n      }\n    }\n    \n    return context.join('\\n')\n  }\n\n  private findRelevantClauses(searchContext: string): PolicyClause[] {\n    const context = searchContext.toLowerCase()\n    const relevantClauses = []\n    \n    for (const clause of this.policyDatabase) {\n      const clauseText = clause.content.toLowerCase()\n      const clauseKeywords = clause.keywords.map(k => k.toLowerCase())\n      \n      // Check for keyword matches\n      let hasMatch = false\n      for (const keyword of clauseKeywords) {\n        if (context.includes(keyword) || clauseText.includes(keyword)) {\n          hasMatch = true\n          break\n        }\n      }\n      \n      // Check for loss type matches\n      if (context.includes('collision') && clause.coverage.includes('collision')) hasMatch = true\n      if (context.includes('water') && clause.coverage.includes('water')) hasMatch = true\n      if (context.includes('liability') && clause.coverage.includes('liability')) hasMatch = true\n      if (context.includes('fire') && clause.coverage.includes('fire')) hasMatch = true\n      \n      if (hasMatch) {\n        relevantClauses.push(clause)\n      }\n    }\n    \n    return relevantClauses\n  }\n\n  private calculateSimilarity(searchContext: string, clause: PolicyClause): number {\n    const context = searchContext.toLowerCase()\n    const clauseText = clause.content.toLowerCase()\n    \n    let score = 0.0\n    \n    // Keyword matching (40% of score)\n    let keywordMatches = 0\n    for (const keyword of clause.keywords) {\n      if (context.includes(keyword.toLowerCase())) {\n        keywordMatches++\n      }\n    }\n    score += (keywordMatches / clause.keywords.length) * 0.4\n    \n    // Coverage type matching (30% of score)\n    for (const coverage of clause.coverage) {\n      if (context.includes(coverage.toLowerCase())) {\n        score += 0.3\n        break\n      }\n    }\n    \n    // Text overlap (20% of score)\n    const contextWords = context.split(/\\s+/)\n    const clauseWords = clauseText.split(/\\s+/)\n    const commonWords = contextWords.filter(word => \n      word.length > 3 && clauseWords.includes(word)\n    )\n    score += (commonWords.length / Math.max(contextWords.length, clauseWords.length)) * 0.2\n    \n    // Document type relevance (10% of score)\n    if (clause.applicableDocuments.some(docType => context.includes(docType.toLowerCase()))) {\n      score += 0.1\n    }\n    \n    return Math.min(score, 1.0)\n  }\n\n  private generateRationale(searchContext: string, clause: PolicyClause): string {\n    const context = searchContext.toLowerCase()\n    const reasons = []\n    \n    // Check keyword matches\n    const matchedKeywords = clause.keywords.filter(k => \n      context.includes(k.toLowerCase())\n    )\n    if (matchedKeywords.length > 0) {\n      reasons.push(`Matched keywords: ${matchedKeywords.join(', ')}`)\n    }\n    \n    // Check coverage matches\n    const matchedCoverage = clause.coverage.filter(c => \n      context.includes(c.toLowerCase())\n    )\n    if (matchedCoverage.length > 0) {\n      reasons.push(`Relevant coverage: ${matchedCoverage.join(', ')}`)\n    }\n    \n    // Check document type matches\n    const matchedDocs = clause.applicableDocuments.filter(d => \n      context.includes(d.toLowerCase())\n    )\n    if (matchedDocs.length > 0) {\n      reasons.push(`Applicable documents: ${matchedDocs.join(', ')}`)\n    }\n    \n    return reasons.join('; ') || 'General policy relevance'\n  }\n\n  private initializePolicyDatabase(): PolicyClause[] {\n    return [\n      // Auto Insurance Clauses\n      {\n        id: 'AUTO-COL-001',\n        title: 'Collision Coverage',\n        content: 'We will pay for direct and accidental loss to your covered auto caused by collision with another object or by upset of your covered auto. Collision coverage is subject to the deductible shown in the Declarations.',\n        coverage: ['collision', 'auto'],\n        keywords: ['collision', 'crash', 'accident', 'vehicle', 'auto', 'car', 'deductible'],\n        applicableDocuments: ['PoliceReport', 'RepairEstimate', 'DamagePhoto'],\n        sourceDocument: 'Auto Policy Form AP-2024',\n        section: 'Part D - Coverage for Damage to Your Auto',\n        deductible: 500\n      },\n      {\n        id: 'AUTO-LIAB-001',\n        title: 'Bodily Injury Liability',\n        content: 'We will pay damages for bodily injury for which any insured becomes legally responsible because of an auto accident. We will settle or defend, as we consider appropriate, any claim or suit asking for these damages.',\n        coverage: ['liability', 'bodily injury'],\n        keywords: ['bodily injury', 'liability', 'accident', 'damages', 'lawsuit', 'medical'],\n        applicableDocuments: ['PoliceReport', 'MedicalRecord', 'MedicalBill'],\n        sourceDocument: 'Auto Policy Form AP-2024',\n        section: 'Part A - Liability Coverage'\n      },\n      {\n        id: 'AUTO-PD-001',\n        title: 'Property Damage Liability',\n        content: 'We will pay damages for property damage for which any insured becomes legally responsible because of an auto accident. Property damage means physical injury to, destruction of, or loss of use of tangible property.',\n        coverage: ['liability', 'property damage'],\n        keywords: ['property damage', 'liability', 'accident', 'damages', 'physical injury'],\n        applicableDocuments: ['PoliceReport', 'RepairEstimate', 'DamagePhoto'],\n        sourceDocument: 'Auto Policy Form AP-2024',\n        section: 'Part A - Liability Coverage'\n      },\n      \n      // Homeowners Insurance Clauses  \n      {\n        id: 'HO-WATER-001',\n        title: 'Water Damage Coverage',\n        content: 'We cover sudden and accidental discharge or overflow of water or steam from within a plumbing, heating, air conditioning, or automatic fire protective sprinkler system, or from within a household appliance.',\n        coverage: ['water damage', 'property'],\n        keywords: ['water', 'discharge', 'overflow', 'plumbing', 'pipe', 'leak', 'sudden'],\n        applicableDocuments: ['DamagePhoto', 'RepairEstimate', 'Invoice'],\n        sourceDocument: 'Homeowners Policy Form HO-3',\n        section: 'Section I - Property Coverages',\n        deductible: 1000\n      },\n      {\n        id: 'HO-STORM-001',\n        title: 'Wind and Hail Coverage',\n        content: 'We cover direct physical loss to property caused by windstorm or hail. This coverage includes damage caused by objects blown by wind or falling trees due to wind.',\n        coverage: ['wind', 'hail', 'storm'],\n        keywords: ['wind', 'windstorm', 'hail', 'storm', 'tree', 'branch', 'roof'],\n        applicableDocuments: ['DamagePhoto', 'WeatherReport', 'RepairEstimate'],\n        sourceDocument: 'Homeowners Policy Form HO-3',\n        section: 'Section I - Property Coverages',\n        deductible: 1000\n      },\n      \n      // Commercial Liability Clauses\n      {\n        id: 'CGL-SLIP-001',\n        title: 'Premises Liability Coverage',\n        content: 'We will pay those sums that the insured becomes legally obligated to pay as damages because of bodily injury or property damage to which this insurance applies caused by an occurrence on premises owned or rented by you.',\n        coverage: ['liability', 'premises', 'slip and fall'],\n        keywords: ['slip', 'fall', 'premises', 'liability', 'bodily injury', 'occurrence'],\n        applicableDocuments: ['IncidentReport', 'MedicalRecord', 'WitnessStatement'],\n        sourceDocument: 'Commercial General Liability Policy CGL-2024',\n        section: 'Coverage A - Bodily Injury and Property Damage Liability'\n      },\n      {\n        id: 'CGL-MED-001',\n        title: 'Medical Payments Coverage',\n        content: 'We will pay medical expenses incurred by a person for bodily injury caused by an accident on premises you own or rent or because of your operations, without regard to fault.',\n        coverage: ['medical payments', 'no fault'],\n        keywords: ['medical expenses', 'medical payments', 'accident', 'premises', 'no fault'],\n        applicableDocuments: ['MedicalRecord', 'MedicalBill', 'IncidentReport'],\n        sourceDocument: 'Commercial General Liability Policy CGL-2024',\n        section: 'Coverage C - Medical Payments'\n      }\n    ]\n  }\n}\n\ninterface PolicyClause {\n  id: string\n  title: string\n  content: string\n  coverage: string[]\n  keywords: string[]\n  applicableDocuments: string[]\n  sourceDocument: string\n  section: string\n  deductible?: number\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1792, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/agents/nodes/assemblerAgent.ts"],"sourcesContent":["import { AgentState, AgentConfig } from '../types'\nimport { ClaimData, DecisionPack, ClaimDraft } from '@/types/claims'\n\nexport class AssemblerAgent {\n  async execute(state: AgentState, config: AgentConfig): Promise<Partial<AgentState>> {\n    const startTime = Date.now()\n    \n    try {\n      // Create the final claim data structure\n      const claimData = await this.assembleClaimData(state)\n      \n      const duration = Date.now() - startTime\n      \n      return {\n        currentStep: 'Review',\n        claimData,\n        auditEvents: [...state.auditEvents, {\n          step: 'assembly',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'AssemblerAgent',\n          status: 'completed',\n          details: {\n            fieldsAssembled: Object.keys(state.extractedFields).length,\n            documentsProcessed: state.documents.length,\n            policyHitsIncluded: state.policyHits.length,\n            totalProcessingTime: Date.now() - state.startTime\n          }\n        }]\n      }\n    } catch (error) {\n      const duration = Date.now() - startTime\n      \n      return {\n        errors: [...state.errors, `Assembly failed: ${error}`],\n        auditEvents: [...state.auditEvents, {\n          step: 'assembly',\n          timestamp: new Date().toISOString(),\n          duration,\n          agent: 'AssemblerAgent',\n          status: 'failed',\n          details: { error: String(error) }\n        }]\n      }\n    }\n  }\n\n  private async assembleClaimData(state: AgentState): Promise<ClaimData> {\n    // Create claim draft\n    const claimDraft = this.createClaimDraft(state.extractedFields, state.documents)\n    \n    // Assemble decision pack\n    const decisionPack = this.createDecisionPack(\n      claimDraft,\n      state.fieldEvidence,\n      state.documents,\n      state.policyHits,\n      state.auditEvents\n    )\n    \n    // Calculate processing metrics\n    const processingMetrics = this.calculateProcessingMetrics(state)\n    \n    return {\n      claimId: this.generateClaimId(),\n      decisionPack: {\n        ...decisionPack,\n        claimDraft,\n        evidence: state.fieldEvidence,\n        documents: state.documents,\n        policyGrounding: state.policyHits,\n        audit: state.auditEvents\n      },\n      auditTrail: state.auditEvents,\n      processingMetrics,\n      createdAt: new Date().toISOString(),\n      status: 'draft'\n    }\n  }\n\n  private createClaimDraft(extractedFields: Record<string, any>, documents: any[]): ClaimDraft {\n    return {\n      id: this.generateDraftId(),\n      policyNumber: this.sanitizePolicyNumber(extractedFields.policyNumber),\n      claimantName: extractedFields.claimantName || 'Unknown',\n      contactEmail: this.maskEmail(extractedFields.contactEmail),\n      contactPhone: this.maskPhone(extractedFields.contactPhone),\n      lossDate: this.formatDate(extractedFields.lossDate),\n      lossType: extractedFields.lossType || 'Other',\n      lossLocation: extractedFields.lossLocation || 'Not specified',\n      description: extractedFields.description || 'Claim details extracted from submitted documents',\n      estimatedAmount: extractedFields.estimatedDamage || null,\n      \n      // Vehicle-specific fields\n      vehicleInfo: extractedFields.vehicleInfo || null,\n      \n      // Property-specific fields  \n      propertyAddress: extractedFields.propertyAddress || null,\n      \n      // Attachments reference\n      attachments: documents.map(doc => ({\n        id: doc.id,\n        name: doc.name,\n        mimeType: doc.mimeType || 'application/octet-stream',\n        type: doc.type,\n        confidence: doc.confidence\n      })),\n      \n      // Coverage assessment\n      coverageFound: this.assessCoverage(extractedFields),\n      deductible: this.determineDeductible(extractedFields),\n      \n      // Metadata\n      createdAt: new Date().toISOString(),\n      source: 'automated_extraction',\n      confidence: this.calculateOverallConfidence(extractedFields)\n    }\n  }\n\n  private createDecisionPack(\n    claimDraft: ClaimDraft,\n    evidence: any[],\n    documents: any[],\n    policyHits: any[],\n    auditEvents: any[]\n  ): DecisionPack {\n    return {\n      id: this.generateDecisionPackId(),\n      claimDraft,\n      evidence,\n      documents,\n      policyGrounding: policyHits,\n      audit: auditEvents,\n      \n      // Evidence summary\n      evidenceSummary: {\n        totalFields: evidence.length,\n        highConfidenceFields: evidence.filter(e => e.confidence >= 0.8).length,\n        lowConfidenceFields: evidence.filter(e => e.confidence < 0.6).length,\n        avgConfidence: evidence.reduce((sum, e) => sum + e.confidence, 0) / evidence.length\n      },\n      \n      // Document analysis\n      documentAnalysis: {\n        totalDocuments: documents.length,\n        documentTypes: [...new Set(documents.map(d => d.type))],\n        avgDocumentConfidence: documents.reduce((sum, d) => sum + d.confidence, 0) / documents.length,\n        missingDocuments: this.identifyMissingDocuments(claimDraft.lossType, documents)\n      },\n      \n      // Policy assessment\n      policyAssessment: {\n        clausesFound: policyHits.length,\n        coverageConfirmed: policyHits.length > 0,\n        topSimilarityScore: policyHits.length > 0 ? Math.max(...policyHits.map(h => h.similarity)) : 0,\n        recommendedActions: this.generateRecommendations(claimDraft, policyHits, evidence)\n      },\n      \n      // Processing summary\n      processingSummary: {\n        totalTime: auditEvents.length > 0 ? \n          auditEvents.reduce((sum, e) => sum + e.duration, 0) : 0,\n        stepsCompleted: auditEvents.filter(e => e.status === 'completed').length,\n        stepsWithErrors: auditEvents.filter(e => e.status === 'failed').length,\n        automationLevel: this.calculateAutomationLevel(evidence)\n      },\n      \n      createdAt: new Date().toISOString()\n    }\n  }\n\n  private calculateProcessingMetrics(state: AgentState): any {\n    const totalTime = Date.now() - state.startTime\n    const completedSteps = state.auditEvents.filter(e => e.status === 'completed').length\n    const failedSteps = state.auditEvents.filter(e => e.status === 'failed').length\n    \n    return {\n      totalProcessingTime: totalTime,\n      averageHandleTime: totalTime / 60000, // in minutes\n      fieldsAutoPopulated: Object.keys(state.extractedFields).filter(key => \n        state.extractedFields[key] !== null && state.extractedFields[key] !== undefined\n      ).length,\n      overrideRate: 0, // Would be calculated based on manual corrections\n      ragHitRate: state.policyHits.length > 0 ? 1 : 0,\n      stepsCompleted: completedSteps,\n      stepsFailed: failedSteps,\n      successRate: completedSteps / (completedSteps + failedSteps)\n    }\n  }\n\n  // Utility methods\n  private generateClaimId(): string {\n    return `CLM-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`\n  }\n\n  private generateDraftId(): string {\n    return `DRAFT-${Date.now()}-${Math.random().toString(36).substr(2, 4).toUpperCase()}`\n  }\n\n  private generateDecisionPackId(): string {\n    return `DP-${Date.now()}-${Math.random().toString(36).substr(2, 8).toUpperCase()}`\n  }\n\n  private sanitizePolicyNumber(policyNumber: string | null): string {\n    if (!policyNumber) return 'Unknown'\n    // Mask policy number for privacy (show only last 3 digits)\n    return policyNumber.length > 3 ? \n      '*'.repeat(policyNumber.length - 3) + policyNumber.slice(-3) :\n      policyNumber\n  }\n\n  private maskEmail(email: string | null): string {\n    if (!email) return ''\n    const [username, domain] = email.split('@')\n    if (!domain) return email\n    \n    const maskedUsername = username.length > 4 ?\n      username.substring(0, 2) + '*'.repeat(username.length - 4) + username.slice(-2) :\n      username\n    \n    return `${maskedUsername}@${domain}`\n  }\n\n  private maskPhone(phone: string | null): string {\n    if (!phone) return ''\n    // Show only last 4 digits\n    const digits = phone.replace(/\\D/g, '')\n    return digits.length > 4 ? \n      '*'.repeat(digits.length - 4) + digits.slice(-4) :\n      phone\n  }\n\n  private formatDate(dateStr: string | null): string {\n    if (!dateStr) return ''\n    \n    try {\n      const date = new Date(dateStr)\n      return date.toISOString().split('T')[0] // YYYY-MM-DD format\n    } catch {\n      return dateStr // Return original if parsing fails\n    }\n  }\n\n  private assessCoverage(extractedFields: Record<string, any>): boolean {\n    // Simple coverage assessment based on policy number presence\n    return !!extractedFields.policyNumber\n  }\n\n  private determineDeductible(extractedFields: Record<string, any>): number | undefined {\n    // Default deductibles based on loss type\n    const lossType = extractedFields.lossType\n    const defaultDeductibles: Record<string, number> = {\n      'Collision': 500,\n      'Water': 1000,\n      'Wind': 1000,\n      'Liability': 0\n    }\n    \n    return defaultDeductibles[lossType] || undefined\n  }\n\n  private calculateOverallConfidence(extractedFields: Record<string, any>): number {\n    const fields = Object.values(extractedFields).filter(v => v !== null && v !== undefined)\n    const requiredFields = ['policyNumber', 'claimantName', 'lossDate', 'lossType']\n    const presentRequired = requiredFields.filter(field => extractedFields[field]).length\n    \n    return (presentRequired / requiredFields.length) * 0.6 + (fields.length / 10) * 0.4\n  }\n\n  private identifyMissingDocuments(lossType: string, documents: any[]): string[] {\n    const presentTypes = new Set(documents.map(d => d.type))\n    const expectedDocuments: Record<string, string[]> = {\n      'Collision': ['PoliceReport', 'RepairEstimate', 'DamagePhoto'],\n      'Water': ['DamagePhoto', 'RepairEstimate'],\n      'Liability': ['IncidentReport', 'MedicalRecord'],\n      'Fire': ['DamagePhoto', 'RepairEstimate', 'FireReport'],\n      'Theft': ['PoliceReport', 'ItemList']\n    }\n    \n    const expected = expectedDocuments[lossType] || []\n    return expected.filter(docType => !presentTypes.has(docType))\n  }\n\n  private generateRecommendations(\n    claimDraft: ClaimDraft, \n    policyHits: any[], \n    evidence: any[]\n  ): string[] {\n    const recommendations = []\n    \n    // Coverage recommendations\n    if (policyHits.length === 0) {\n      recommendations.push('No matching policy clauses found - review coverage manually')\n    } else if (policyHits[0].similarity < 0.8) {\n      recommendations.push('Low policy match confidence - adjuster review recommended')\n    }\n    \n    // Evidence recommendations\n    const lowConfidenceFields = evidence.filter(e => e.confidence < 0.6)\n    if (lowConfidenceFields.length > 0) {\n      recommendations.push(`${lowConfidenceFields.length} fields need manual verification`)\n    }\n    \n    // Amount recommendations\n    if (claimDraft.estimatedAmount && claimDraft.estimatedAmount > 10000) {\n      recommendations.push('High-value claim - senior adjuster review required')\n    }\n    \n    // Document recommendations\n    if (!claimDraft.attachments.some(a => a.type === 'DamagePhoto')) {\n      recommendations.push('Damage photos recommended for claim validation')\n    }\n    \n    return recommendations\n  }\n\n  private calculateAutomationLevel(evidence: any[]): number {\n    const highConfidenceFields = evidence.filter(e => e.confidence >= 0.8).length\n    return evidence.length > 0 ? highConfidenceFields / evidence.length : 0\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2084, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/agents/orchestrator.ts"],"sourcesContent":["import { AgentState, AgentConfig, UploadedFile } from './types'\nimport { ClaimData } from '@/types/claims'\nimport { IngestionAgent } from './nodes/ingestionAgent'\nimport { ExtractionAgent } from './nodes/extractionAgent'\nimport { PolicyAgent } from './nodes/policyAgent'\nimport { AssemblerAgent } from './nodes/assemblerAgent'\n\nexport class LangGraphOrchestrator {\n  private ingestionAgent: IngestionAgent\n  private extractionAgent: ExtractionAgent\n  private policyAgent: PolicyAgent\n  private assemblerAgent: AssemblerAgent\n  private config: AgentConfig\n  private hasOpenAIKey: boolean\n\n  constructor(config?: Partial<AgentConfig>) {\n    this.config = {\n      llmModel: process.env.OPENAI_MODEL || 'gpt-4-1106-preview',\n      confidenceThreshold: 0.6,\n      maxRetries: 3,\n      timeoutMs: 30000,\n      ...config\n    }\n\n    // Check if OpenAI API key is available\n    this.hasOpenAIKey = !!(process.env.OPENAI_API_KEY || (typeof window !== 'undefined' && (window as any).OPENAI_API_KEY))\n\n    // Initialize agent nodes\n    this.ingestionAgent = new IngestionAgent()\n    this.extractionAgent = new ExtractionAgent()\n    this.policyAgent = new PolicyAgent()\n    this.assemblerAgent = new AssemblerAgent()\n  }\n\n  async processClaim(emailText: string, files: UploadedFile[]): Promise<ClaimData> {\n    const startTime = Date.now()\n    \n    // Initialize agent state\n    let state: AgentState = {\n      emailText,\n      files,\n      currentStep: 'Initializing',\n      startTime,\n      documents: [],\n      extractedFields: {},\n      fieldEvidence: [],\n      policyHits: [],\n      auditEvents: [],\n      errors: [],\n      warnings: []\n    }\n\n    try {\n      // Execute agent workflow in sequence\n      state = await this.executeWorkflow(state)\n      \n      if (state.claimData) {\n        return state.claimData\n      } else {\n        throw new Error('Workflow completed but no claim data generated')\n      }\n    } catch (error) {\n      // Add error to audit trail\n      state.auditEvents.push({\n        step: 'orchestrator_error',\n        timestamp: new Date().toISOString(),\n        duration: Date.now() - startTime,\n        agent: 'Orchestrator',\n        status: 'failed',\n        details: { error: String(error) }\n      })\n\n      throw new Error(`Claim processing failed: ${error}`)\n    }\n  }\n\n  private async executeWorkflow(initialState: AgentState): Promise<AgentState> {\n    let state = { ...initialState }\n\n    // Step 1: Ingestion Agent\n    state.currentStep = 'Document Ingestion'\n    state = { ...state, ...(await this.executeWithRetry(\n      () => this.ingestionAgent.execute(state, this.config),\n      'ingestion'\n    ))}\n\n    // Step 2: Extraction Agent\n    state.currentStep = 'Field Extraction'\n    state = { ...state, ...(await this.executeWithRetry(\n      () => this.extractionAgent.execute(state, this.config),\n      'extraction'\n    ))}\n\n    // Step 3: Policy Agent\n    state.currentStep = 'Policy Grounding'\n    state = { ...state, ...(await this.executeWithRetry(\n      () => this.policyAgent.execute(state, this.config),\n      'policy_grounding'\n    ))}\n\n    // Step 4: Assembler Agent\n    state.currentStep = 'Decision Assembly'\n    state = { ...state, ...(await this.executeWithRetry(\n      () => this.assemblerAgent.execute(state, this.config),\n      'assembly'\n    ))}\n\n    return state\n  }\n\n  private async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    stepName: string,\n    retryCount = 0\n  ): Promise<T> {\n    try {\n      return await Promise.race([\n        operation(),\n        this.createTimeoutPromise()\n      ])\n    } catch (error) {\n      if (retryCount < this.config.maxRetries) {\n        // Log retry attempt\n        console.warn(`Retrying ${stepName} (attempt ${retryCount + 1}): ${error}`)\n        \n        // Exponential backoff\n        await new Promise(resolve => \n          setTimeout(resolve, Math.pow(2, retryCount) * 1000)\n        )\n        \n        return this.executeWithRetry(operation, stepName, retryCount + 1)\n      } else {\n        throw new Error(`${stepName} failed after ${this.config.maxRetries} retries: ${error}`)\n      }\n    }\n  }\n\n  private createTimeoutPromise(): Promise<never> {\n    return new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(new Error(`Operation timed out after ${this.config.timeoutMs}ms`))\n      }, this.config.timeoutMs)\n    })\n  }\n\n  // Utility methods for monitoring and debugging\n  getProcessingStatus(state: AgentState): {\n    currentStep: string\n    progress: number\n    estimatedTimeRemaining: number\n    errors: string[]\n  } {\n    const totalSteps = 4 // ingestion, extraction, policy, assembly\n    const completedSteps = state.auditEvents.filter(e => e.status === 'completed').length\n    const progress = completedSteps / totalSteps\n    \n    const avgStepTime = state.auditEvents.length > 0 ?\n      state.auditEvents.reduce((sum, e) => sum + e.duration, 0) / state.auditEvents.length :\n      2000 // Default 2 seconds per step\n    \n    const estimatedTimeRemaining = (totalSteps - completedSteps) * avgStepTime\n\n    return {\n      currentStep: state.currentStep,\n      progress,\n      estimatedTimeRemaining,\n      errors: state.errors\n    }\n  }\n\n  getAuditTrail(state: AgentState): any[] {\n    return state.auditEvents.map(event => ({\n      ...event,\n      formattedDuration: `${event.duration}ms`,\n      formattedTimestamp: new Date(event.timestamp).toLocaleString()\n    }))\n  }\n\n  // Configuration management\n  updateConfig(newConfig: Partial<AgentConfig>): void {\n    this.config = { ...this.config, ...newConfig }\n  }\n\n  getConfig(): AgentConfig {\n    return { ...this.config }\n  }\n\n  // Check OpenAI integration status\n  getOpenAIStatus(): {\n    available: boolean\n    model: string\n    message: string\n  } {\n    return {\n      available: this.hasOpenAIKey,\n      model: this.config.llmModel,\n      message: this.hasOpenAIKey \n        ? `OpenAI integration active with ${this.config.llmModel}` \n        : 'OpenAI API key not configured - using simulation mode'\n    }\n  }\n\n  // Health check for the orchestrator\n  async healthCheck(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy'\n    details: Record<string, any>\n  }> {\n    try {\n      // Test with minimal input\n      const testState: AgentState = {\n        emailText: 'Test health check',\n        files: [],\n        currentStep: 'health_check',\n        startTime: Date.now(),\n        documents: [],\n        extractedFields: {},\n        fieldEvidence: [],\n        policyHits: [],\n        auditEvents: [],\n        errors: [],\n        warnings: []\n      }\n\n      // Quick test of each agent\n      const results = await Promise.allSettled([\n        this.ingestionAgent.execute(testState, this.config),\n        this.extractionAgent.execute(testState, this.config),\n        this.policyAgent.execute(testState, this.config),\n        this.assemblerAgent.execute(testState, this.config)\n      ])\n\n      const failedAgents = results.filter(r => r.status === 'rejected').length\n      const openaiStatus = this.getOpenAIStatus()\n      \n      return {\n        status: failedAgents === 0 ? 'healthy' : failedAgents <= 1 ? 'degraded' : 'unhealthy',\n        details: {\n          agentsOnline: results.length - failedAgents,\n          totalAgents: results.length,\n          config: this.config,\n          openaiStatus,\n          timestamp: new Date().toISOString()\n        }\n      }\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        details: {\n          error: String(error),\n          timestamp: new Date().toISOString()\n        }\n      }\n    }\n  }\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2307, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/app/api/process-claim/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getIngestedClaimById, readAttachmentContent } from '@/lib/ingestedClaims'\nimport { LangGraphOrchestrator } from '@/lib/agents/orchestrator'\nimport { UploadedFile } from '@/lib/agents/types'\nimport fs from 'fs'\n\n/**\n * POST /api/process-claim\n * Body: { ingestedClaimId: string }\n * Processes the selected ingested claim and returns ClaimData\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { ingestedClaimId } = body\n\n    if (!ingestedClaimId) {\n      return NextResponse.json(\n        { error: 'ingestedClaimId is required' },\n        { status: 400 }\n      )\n    }\n\n    const claim = getIngestedClaimById(ingestedClaimId)\n    if (!claim) {\n      return NextResponse.json(\n        { error: 'Claim not found' },\n        { status: 404 }\n      )\n    }\n\n    const files: UploadedFile[] = claim.attachments.map((att) => {\n      let content: string\n      try {\n        const ext = att.name.toLowerCase().split('.').pop() || ''\n        if (['txt', 'csv', 'log'].includes(ext)) {\n          content = fs.readFileSync(att.path, 'utf-8')\n        } else {\n          content = `[Document: ${att.name} - binary content]`\n        }\n      } catch {\n        content = `[Could not read: ${att.name}]`\n      }\n      return {\n        name: att.name,\n        content,\n        mimeType: att.mimeType,\n        size: att.size,\n      }\n    })\n\n    const orchestrator = new LangGraphOrchestrator({\n      llmModel: process.env.OPENAI_MODEL || 'gpt-4-1106-preview',\n      confidenceThreshold: 0.6,\n      maxRetries: 2,\n      timeoutMs: 30000,\n    })\n\n    const claimData = await orchestrator.processClaim(claim.emailBody, files)\n\n    const openaiStatus = orchestrator.getOpenAIStatus()\n    claimData.auditTrail.push({\n      step: 'system_info',\n      timestamp: new Date().toISOString(),\n      duration: 0,\n      agent: 'System',\n      status: 'completed',\n      details: {\n        openaiIntegration: openaiStatus.available ? 'active' : 'demo_mode',\n        model: openaiStatus.model,\n      },\n    })\n\n    return NextResponse.json(claimData)\n  } catch (error) {\n    console.error('Process claim error:', error)\n    return NextResponse.json(\n      { error: 'Claim processing failed', details: String(error) },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAEA;;;;;AAOO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,eAAe,EAAE,GAAG;QAE5B,IAAI,CAAC,iBAAiB;YACpB,OAAO,wLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,QAAQ,IAAA,uLAAoB,EAAC;QACnC,IAAI,CAAC,OAAO;YACV,OAAO,wLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkB,GAC3B;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,QAAwB,MAAM,WAAW,CAAC,GAAG,CAAC,CAAC;YACnD,IAAI;YACJ,IAAI;gBACF,MAAM,MAAM,IAAI,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,KAAK,GAAG,MAAM;gBACvD,IAAI;oBAAC;oBAAO;oBAAO;iBAAM,CAAC,QAAQ,CAAC,MAAM;oBACvC,UAAU,wGAAE,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE;gBACtC,OAAO;oBACL,UAAU,CAAC,WAAW,EAAE,IAAI,IAAI,CAAC,kBAAkB,CAAC;gBACtD;YACF,EAAE,OAAM;gBACN,UAAU,CAAC,iBAAiB,EAAE,IAAI,IAAI,CAAC,CAAC,CAAC;YAC3C;YACA,OAAO;gBACL,MAAM,IAAI,IAAI;gBACd;gBACA,UAAU,IAAI,QAAQ;gBACtB,MAAM,IAAI,IAAI;YAChB;QACF;QAEA,MAAM,eAAe,IAAI,gMAAqB,CAAC;YAC7C,UAAU,QAAQ,GAAG,CAAC,YAAY,IAAI;YACtC,qBAAqB;YACrB,YAAY;YACZ,WAAW;QACb;QAEA,MAAM,YAAY,MAAM,aAAa,YAAY,CAAC,MAAM,SAAS,EAAE;QAEnE,MAAM,eAAe,aAAa,eAAe;QACjD,UAAU,UAAU,CAAC,IAAI,CAAC;YACxB,MAAM;YACN,WAAW,IAAI,OAAO,WAAW;YACjC,UAAU;YACV,OAAO;YACP,QAAQ;YACR,SAAS;gBACP,mBAAmB,aAAa,SAAS,GAAG,WAAW;gBACvD,OAAO,aAAa,KAAK;YAC3B;QACF;QAEA,OAAO,wLAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,wLAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAA2B,SAAS,OAAO;QAAO,GAC3D;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}