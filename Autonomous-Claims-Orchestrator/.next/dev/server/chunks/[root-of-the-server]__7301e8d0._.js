module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/node:buffer [external] (node:buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:buffer", () => require("node:buffer"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[project]/Autonomous-Claims-Orchestrator/services/ingested-claims/index.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addDedupKeysToSet",
    ()=>addDedupKeysToSet,
    "clearAllIngestedClaims",
    ()=>clearAllIngestedClaims,
    "extractPolicyNumber",
    ()=>extractPolicyNumber,
    "getAllIngestedClaims",
    ()=>getAllIngestedClaims,
    "getExistingMessageIds",
    ()=>getExistingMessageIds,
    "getIngestedClaimById",
    ()=>getIngestedClaimById,
    "getPolicyNumbers",
    ()=>getPolicyNumbers,
    "isDuplicateEmail",
    ()=>isDuplicateEmail,
    "readAttachmentContent",
    ()=>readAttachmentContent,
    "saveIngestedClaim",
    ()=>saveIngestedClaim
]);
/**
 * Ingested Claims Microservice
 *
 * Manages FNOL claims ingested from email (IMAP, SendGrid, demo).
 * Provides CRUD, policy extraction, deduplication, and attachment handling.
 */ var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/path [external] (path, cjs)");
;
;
const DATA_DIR = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'data');
const INGESTED_DIR = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(DATA_DIR, 'ingested-attachments');
const CLAIMS_FILE = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(DATA_DIR, 'ingested-claims.json');
function ensureDataDir() {
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(DATA_DIR)) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].mkdirSync(DATA_DIR, {
            recursive: true
        });
    }
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(INGESTED_DIR)) {
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].mkdirSync(INGESTED_DIR, {
            recursive: true
        });
    }
}
function getClaimsData() {
    ensureDataDir();
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CLAIMS_FILE)) return [];
    try {
        return JSON.parse(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(CLAIMS_FILE, 'utf-8'));
    } catch  {
        return [];
    }
}
function saveClaimsData(claims) {
    ensureDataDir();
    __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8');
}
function normalizeDedupKey(s) {
    return s.trim().toLowerCase();
}
function normalizedSubjectFrom(subject, from) {
    return normalizeDedupKey(`${subject}|${from}`);
}
function fallbackPolicyDisplay(messageId, claimId) {
    if (!messageId) return claimId;
    if (messageId.includes('<') && messageId.includes('@')) {
        const inner = messageId.replace(/^<|>$/g, '').trim();
        return inner || claimId;
    }
    return claimId;
}
function seedDemoClaims() {
    const scenariosDir = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(process.cwd(), 'demo-data', 'scenarios');
    if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(scenariosDir)) return;
    const scenarios = [
        {
            folder: 'auto-collision',
            policyNumber: 'AC789456123',
            from: 'sarah.johnson@email.com',
            to: 'pranay.nath@aimill.in',
            subject: 'Car Accident Claim - Policy #AC789456123'
        },
        {
            folder: 'commercial-liability',
            policyNumber: 'CL789012345',
            from: 'antonio.martinez@tonysrestaurant.com',
            to: 'pranay.nath@aimill.in',
            subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345'
        },
        {
            folder: 'property-water-damage',
            policyNumber: 'HO456789234',
            from: 'robert.chen@email.com',
            to: 'pranay.nath@aimill.in',
            subject: 'Urgent - Water Damage Claim - Policy #HO456789234'
        }
    ];
    const claims = [];
    const baseTime = Date.now() - 86400000 * 2;
    for(let i = 0; i < scenarios.length; i++){
        const s = scenarios[i];
        const emailPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(scenariosDir, s.folder, 'email.txt');
        const attachmentsDir = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(scenariosDir, s.folder, 'attachments');
        if (!__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(emailPath)) continue;
        const emailBody = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(emailPath, 'utf-8');
        const claimId = `DEMO-${s.policyNumber}-${i}`;
        const claimDir = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(INGESTED_DIR, claimId);
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].mkdirSync(claimDir, {
            recursive: true
        });
        const attachments = [];
        if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(attachmentsDir)) {
            for (const file of __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readdirSync(attachmentsDir)){
                const srcPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(attachmentsDir, file);
                if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].statSync(srcPath).isFile()) {
                    const destPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(claimDir, file);
                    __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].copyFileSync(srcPath, destPath);
                    attachments.push({
                        name: file,
                        path: destPath,
                        size: __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].statSync(destPath).size,
                        mimeType: 'text/plain'
                    });
                }
            }
        }
        claims.push({
            id: claimId,
            policyNumber: s.policyNumber,
            from: s.from,
            to: s.to,
            subject: s.subject,
            emailBody,
            attachments,
            createdAt: new Date(baseTime + i * 3600000).toISOString(),
            source: 'demo'
        });
    }
    if (claims.length > 0) saveClaimsData(claims);
}
function extractPolicyNumber(emailBody) {
    const patterns = [
        /policy\s*#?\s*:?\s*([A-Z0-9]{6,})/i,
        /policy\s*number\s*:?\s*([A-Z0-9]{6,})/i,
        /Policy\s*#([A-Z0-9]+)/i,
        /#([A-Z]{2}\d{6,})/,
        /\b([A-Z]{2}\d{6,})\b/
    ];
    for (const pattern of patterns){
        const match = emailBody.match(pattern);
        if (match?.[1]) return match[1];
    }
    return null;
}
function getExistingMessageIds() {
    const claims = getClaimsData();
    const ids = new Set();
    for (const c of claims){
        ids.add(normalizedSubjectFrom(c.subject, c.from));
        if (c.messageId) {
            ids.add(normalizeDedupKey(c.messageId));
            const inner = c.messageId.replace(/^<|>$/g, '').trim();
            if (inner) ids.add(normalizeDedupKey(inner));
        }
    }
    return ids;
}
function addDedupKeysToSet(ids, subject, from, messageId, dedupKey) {
    ids.add(normalizedSubjectFrom(subject, from));
    ids.add(normalizeDedupKey(dedupKey));
    if (messageId) {
        const inner = messageId.replace(/^<|>$/g, '').trim();
        if (inner) ids.add(normalizeDedupKey(inner));
    }
}
function isDuplicateEmail(subject, from, messageId, dateHeader, existingIds) {
    if (existingIds.has(normalizedSubjectFrom(subject, from))) return true;
    const dedupKey = messageId ? normalizeDedupKey(messageId) : normalizeDedupKey(`${subject}|${from}|${dateHeader}`);
    if (existingIds.has(dedupKey)) return true;
    if (messageId) {
        const inner = messageId.replace(/^<|>$/g, '').trim();
        if (inner && existingIds.has(normalizeDedupKey(inner))) return true;
    }
    return false;
}
function saveIngestedClaim(from, to, subject, emailBody, attachmentFiles, source = 'sendgrid', messageId, emailMessageIdForDisplay) {
    const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
    const extracted = extractPolicyNumber(emailBody) || extractPolicyNumber(subject);
    const policyNumber = extracted ?? fallbackPolicyDisplay(emailMessageIdForDisplay ?? messageId, claimId);
    ensureDataDir();
    const claimDir = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(INGESTED_DIR, claimId);
    __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].mkdirSync(claimDir, {
        recursive: true
    });
    const attachments = [];
    for (const file of attachmentFiles){
        const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_');
        const filePath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(claimDir, safeName);
        __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].writeFileSync(filePath, file.buffer);
        attachments.push({
            name: file.name,
            path: filePath,
            size: file.buffer.length,
            mimeType: file.mimeType || 'application/octet-stream'
        });
    }
    const claim = {
        id: claimId,
        policyNumber,
        from,
        to,
        subject,
        emailBody,
        attachments,
        createdAt: new Date().toISOString(),
        source
    };
    if (messageId) claim.messageId = messageId;
    const claims = getClaimsData();
    claims.unshift(claim);
    saveClaimsData(claims);
    return claim;
}
function getAllIngestedClaims() {
    let claims = getClaimsData();
    if (claims.length === 0) {
        seedDemoClaims();
        claims = getClaimsData();
    }
    const hasRealClaims = claims.some((c)=>c.source === 'imap' || c.source === 'sendgrid');
    return hasRealClaims ? claims.filter((c)=>c.source !== 'demo') : claims;
}
function getIngestedClaimById(id) {
    const claims = getClaimsData();
    return claims.find((c)=>c.id === id) ?? null;
}
function getPolicyNumbers() {
    let claims = getClaimsData();
    if (claims.length === 0) {
        seedDemoClaims();
        claims = getClaimsData();
    }
    const hasRealClaims = claims.some((c)=>c.source === 'imap' || c.source === 'sendgrid');
    const toShow = hasRealClaims ? claims.filter((c)=>c.source !== 'demo') : claims;
    return toShow.map((c)=>({
            id: c.id,
            policyNumber: c.policyNumber,
            subject: c.subject
        }));
}
function clearAllIngestedClaims() {
    ensureDataDir();
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(CLAIMS_FILE)) __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].unlinkSync(CLAIMS_FILE);
    if (__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(INGESTED_DIR)) {
        for (const entry of __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readdirSync(INGESTED_DIR, {
            withFileTypes: true
        })){
            const fullPath = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].join(INGESTED_DIR, entry.name);
            if (entry.isDirectory()) __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].rmSync(fullPath, {
                recursive: true
            });
        }
    }
}
function readAttachmentContent(claimId, attachmentName) {
    const claim = getIngestedClaimById(claimId);
    if (!claim) throw new Error('Claim not found');
    const att = claim.attachments.find((a)=>a.name === attachmentName);
    if (!att || !__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].existsSync(att.path)) throw new Error('Attachment not found');
    const ext = __TURBOPACK__imported__module__$5b$externals$5d2f$path__$5b$external$5d$__$28$path$2c$__cjs$29$__["default"].extname(att.name).toLowerCase();
    if ([
        '.txt',
        '.csv',
        '.log'
    ].includes(ext)) {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readFileSync(att.path, 'utf-8');
    }
    return `[Document: ${att.name} - content extracted for processing]`;
}
}),
"[project]/Autonomous-Claims-Orchestrator/services/email-ingestion/index.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "syncInbox",
    ()=>syncInbox
]);
/**
 * Email Ingestion Microservice
 *
 * Fetches emails from IMAP (Gmail/Outlook), classifies via LLM (FNOL vs non-FNOL),
 * ingests only FNOL-related content. Uses Node.js imapflow - no Python required.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$imapflow$2f$lib$2f$imap$2d$flow$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/node_modules/imapflow/lib/imap-flow.js [app-route] (ecmascript)");
// @ts-expect-error - mailparser has no types
var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$mailparser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/node_modules/mailparser/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/node_modules/openai/client.mjs [app-route] (ecmascript) <export OpenAI as default>");
var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$ingested$2d$claims$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/services/ingested-claims/index.ts [app-route] (ecmascript)");
;
;
;
;
const IMAP_HOST = process.env.IMAP_HOST || 'imap.gmail.com';
const IMAP_PORT = parseInt(process.env.IMAP_PORT || '993', 10);
const IMAP_USER = process.env.SENDER_EMAIL || process.env.IMAP_USER || '';
const IMAP_PASSWORD = (process.env.EMAIL_PASSWORD || process.env.IMAP_PASSWORD || '').replace(/\s/g, '');
const IMAP_MAILBOX = process.env.IMAP_MAILBOX || 'INBOX';
const INCLUDE_READ = process.env.IMAP_SYNC_INCLUDE_READ !== 'false';
const MAX_EMAILS = parseInt(process.env.IMAP_SYNC_MAX_EMAILS || '100', 10);
const FNOL_FILTER_ENABLED = process.env.FNOL_FILTER_ENABLED !== 'false';
async function classifyFnolByLLM(subject, body) {
    if (!FNOL_FILTER_ENABLED) return true;
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) return true;
    try {
        const openai = new __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__["default"]({
            apiKey
        });
        const model = process.env.OPENAI_MODEL || 'gpt-4o-mini';
        const text = `Subject: ${subject}\n\nBody:\n${body.slice(0, 3000)}`;
        const response = await openai.chat.completions.create({
            model,
            messages: [
                {
                    role: 'system',
                    content: `You are an FNOL classifier. Determine if this email is a First Notice of Loss (FNOL) or insurance claim submission.
FNOL = an insured person notifying their insurer of a loss, incident, or damage to file a claim (e.g. accident, water damage, theft, fire, collision, bodily injury, property damage).
Reply with ONLY "yes" or "no".`
                },
                {
                    role: 'user',
                    content: `Is this email an FNOL or insurance claim submission?\n\n${text}`
                }
            ],
            max_tokens: 10,
            temperature: 0
        });
        const answer = (response.choices[0]?.message?.content || '').trim().toLowerCase();
        return answer.startsWith('yes');
    } catch (err) {
        console.error('FNOL classifier error:', err);
        return true;
    }
}
function formatAddress(addr) {
    if (!addr) return '';
    const arr = Array.isArray(addr) ? addr : [
        addr
    ];
    return arr.map((a)=>a?.text || a?.address || a?.value?.[0]?.address).filter(Boolean).join(', ');
}
function formatDate(d) {
    const date = d instanceof Date ? d : new Date(d);
    if (isNaN(date.getTime())) return '';
    return date.toLocaleString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
    });
}
function buildFullEmailBody(opts) {
    const lines = [];
    if (opts.subject) lines.push(`Subject: ${opts.subject}`);
    if (opts.from) lines.push(`From: ${opts.from}`);
    if (opts.to) lines.push(`To: ${opts.to}`);
    if (opts.dateStr) lines.push(`Date: ${opts.dateStr}`);
    if (lines.length) lines.push('');
    if (opts.bodyText) lines.push(opts.bodyText.trim());
    return lines.join('\n');
}
function stripHtml(html) {
    return html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '').replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
}
async function syncInbox() {
    const result = {
        success: false,
        ingested: 0,
        scanned: 0,
        skippedNoFnol: 0,
        skippedDuplicate: 0,
        errors: []
    };
    if (!IMAP_USER || !IMAP_PASSWORD) {
        result.errors.push('IMAP credentials not configured. Set SENDER_EMAIL and EMAIL_PASSWORD in .env');
        return result;
    }
    const client = new __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$imapflow$2f$lib$2f$imap$2d$flow$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ImapFlow"]({
        host: IMAP_HOST,
        port: IMAP_PORT,
        secure: true,
        auth: {
            user: IMAP_USER,
            pass: IMAP_PASSWORD
        },
        logger: false
    });
    const mailboxesToTry = [
        IMAP_MAILBOX
    ];
    if (IMAP_HOST.toLowerCase().includes('gmail') && IMAP_MAILBOX.toUpperCase() === 'INBOX') {
        if (INCLUDE_READ) {
            mailboxesToTry.unshift('[Gmail]/All Mail', '[Google Mail]/All Mail');
        } else {
            mailboxesToTry.push('[Gmail]/All Mail', '[Google Mail]/All Mail');
        }
    }
    try {
        await client.connect();
        let uids = [];
        let mailboxUsed = '';
        for (const mbox of mailboxesToTry){
            try {
                const lock = await client.getMailboxLock(mbox);
                try {
                    const searchCriteria = INCLUDE_READ ? {
                        all: true
                    } : {
                        seen: false
                    };
                    const searchResult = await client.search(searchCriteria, {
                        uid: true
                    });
                    let list = Array.isArray(searchResult) ? searchResult : [];
                    list = list.slice(-MAX_EMAILS);
                    if (list.length > 0) {
                        uids = list;
                        mailboxUsed = mbox;
                        break;
                    }
                } finally{
                    lock.release();
                }
            } catch  {
                continue;
            }
        }
        if (uids.length === 0) {
            result.success = true;
            result.hint = "Inbox empty. For Gmail: enable 'All Mail' in Settings > Labels > Show in IMAP, or set IMAP_MAILBOX='[Gmail]/All Mail' in .env";
            await client.logout();
            return result;
        }
        result.scanned = uids.length;
        result.mailboxUsed = mailboxUsed;
        const existingIds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$ingested$2d$claims$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getExistingMessageIds"])();
        const lock = await client.getMailboxLock(mailboxUsed || IMAP_MAILBOX);
        try {
            const messages = await client.fetch(uids, {
                envelope: true,
                source: true,
                uid: true
            }, {
                uid: true
            });
            for await (const msg of messages){
                try {
                    const rawSource = msg.source;
                    if (!rawSource) {
                        result.errors.push(`Message ${msg.uid}: No source data`);
                        continue;
                    }
                    const rawBuffer = Buffer.isBuffer(rawSource) ? rawSource : Buffer.from(rawSource);
                    const parsed = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$mailparser$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["simpleParser"])(rawBuffer);
                    const subject = parsed.subject || '(No subject)';
                    const from = formatAddress(parsed.from) || '';
                    const to = formatAddress(parsed.to) || '';
                    const messageId = parsed.messageId || '';
                    const dateHeader = parsed.date ? String(parsed.date) : '';
                    const dedupKey = messageId || `${subject}|${from}|${dateHeader}`;
                    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$ingested$2d$claims$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isDuplicateEmail"])(subject, from, messageId, dateHeader, existingIds)) {
                        result.skippedDuplicate = (result.skippedDuplicate ?? 0) + 1;
                        continue;
                    }
                    const bodyText = parsed.text || (parsed.html ? stripHtml(parsed.html) : '');
                    const isFnol = await classifyFnolByLLM(subject, bodyText);
                    if (!isFnol) {
                        result.skippedNoFnol++;
                        continue;
                    }
                    const dateStr = parsed.date ? formatDate(parsed.date) : '';
                    const emailBody = buildFullEmailBody({
                        subject,
                        from,
                        to,
                        dateStr,
                        bodyText
                    });
                    const attachmentFiles = [];
                    if (parsed.attachments?.length) {
                        for (const att of parsed.attachments){
                            const content = att.content;
                            const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content || []);
                            const filename = att.filename || `attachment-${attachmentFiles.length + 1}`;
                            const mimeType = att.contentType || 'application/octet-stream';
                            attachmentFiles.push({
                                name: filename,
                                buffer,
                                mimeType
                            });
                        }
                    }
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$ingested$2d$claims$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["saveIngestedClaim"])(from, to, subject, emailBody, attachmentFiles, 'imap', dedupKey, messageId || undefined);
                    result.ingested++;
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$ingested$2d$claims$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["addDedupKeysToSet"])(existingIds, subject, from, messageId, dedupKey);
                    if (!INCLUDE_READ) {
                        await client.messageFlagsAdd(msg.uid, [
                            '\\Seen'
                        ], {
                            uid: true
                        });
                    }
                } catch (err) {
                    result.errors.push(`Failed to process message ${msg.uid}: ${err instanceof Error ? err.message : String(err)}`);
                }
            }
            result.success = result.errors.length === 0;
        } finally{
            lock.release();
        }
        await client.logout();
    } catch (err) {
        result.errors.push(err instanceof Error ? err.message : String(err));
        try {
            await client.logout();
        } catch  {
        // ignore
        }
    }
    return result;
}
}),
"[project]/Autonomous-Claims-Orchestrator/app/api/sync-inbox/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST
]);
/**
 * POST /api/sync-inbox
 * Delegates to Email Ingestion microservice.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$email$2d$ingestion$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/Autonomous-Claims-Orchestrator/services/email-ingestion/index.ts [app-route] (ecmascript)");
;
;
async function POST() {
    try {
        const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$services$2f$email$2d$ingestion$2f$index$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["syncInbox"])();
        return __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: result.success,
            ingested: result.ingested,
            scanned: result.scanned,
            skippedNoFnol: result.skippedNoFnol,
            skippedDuplicate: result.skippedDuplicate ?? 0,
            errors: result.errors,
            hint: result.hint
        });
    } catch (error) {
        console.error('Sync inbox error:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$Autonomous$2d$Claims$2d$Orchestrator$2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            ingested: 0,
            scanned: 0,
            skippedNoFnol: 0,
            skippedDuplicate: 0,
            errors: [
                String(error)
            ]
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__7301e8d0._.js.map