{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/ingestedClaims.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nconst DATA_DIR = path.join(process.cwd(), 'data')\nconst INGESTED_DIR = path.join(DATA_DIR, 'ingested-attachments')\nconst CLAIMS_FILE = path.join(DATA_DIR, 'ingested-claims.json')\n\nexport interface IngestedAttachment {\n  name: string\n  path: string\n  size: number\n  mimeType: string\n}\n\nexport interface IngestedClaim {\n  id: string\n  policyNumber: string\n  from: string\n  to: string\n  subject: string\n  emailBody: string\n  attachments: IngestedAttachment[]\n  createdAt: string\n  source: 'sendgrid' | 'demo' | 'imap'\n  messageId?: string\n}\n\nfunction ensureDataDir() {\n  if (!fs.existsSync(DATA_DIR)) {\n    fs.mkdirSync(DATA_DIR, { recursive: true })\n  }\n  if (!fs.existsSync(INGESTED_DIR)) {\n    fs.mkdirSync(INGESTED_DIR, { recursive: true })\n  }\n}\n\nfunction getClaimsData(): IngestedClaim[] {\n  ensureDataDir()\n  if (!fs.existsSync(CLAIMS_FILE)) {\n    return []\n  }\n  try {\n    const content = fs.readFileSync(CLAIMS_FILE, 'utf-8')\n    return JSON.parse(content)\n  } catch {\n    return []\n  }\n}\n\nfunction saveClaimsData(claims: IngestedClaim[]) {\n  ensureDataDir()\n  fs.writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8')\n}\n\n/** Extract policy number from email body using common patterns */\nexport function extractPolicyNumber(emailBody: string): string | null {\n  const patterns = [\n    /policy\\s*#?\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /policy\\s*number\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /Policy\\s*#([A-Z0-9]+)/i,\n    /#([A-Z]{2}\\d{6,})/,\n    /\\b([A-Z]{2}\\d{6,})\\b/,\n  ]\n  for (const pattern of patterns) {\n    const match = emailBody.match(pattern)\n    if (match && match[1]) {\n      return match[1]\n    }\n  }\n  return null\n}\n\nfunction normalizeDedupKey(s: string): string {\n  return s.trim().toLowerCase()\n}\n\nfunction normalizedSubjectFrom(subject: string, from: string): string {\n  return normalizeDedupKey(`${subject}|${from}`)\n}\n\n/** Get existing message IDs / dedup keys for avoiding re-ingestion.\n * Adds both Message-ID (raw + normalized) and subject|from for each claim\n * so duplicates are caught even when Message-ID varies (forward/reply) or is missing.\n */\nexport function getExistingMessageIds(): Set<string> {\n  const claims = getClaimsData()\n  const ids = new Set<string>()\n  for (const c of claims) {\n    ids.add(normalizedSubjectFrom(c.subject, c.from))\n    if (c.messageId) {\n      ids.add(normalizeDedupKey(c.messageId))\n      const inner = c.messageId.replace(/^<|>$/g, '').trim()\n      if (inner) ids.add(normalizeDedupKey(inner))\n    }\n  }\n  return ids\n}\n\n/** Add dedup keys for a newly ingested claim so future syncs can detect duplicates */\nexport function addDedupKeysToSet(\n  ids: Set<string>,\n  subject: string,\n  from: string,\n  messageId: string,\n  dedupKey: string\n): void {\n  ids.add(normalizedSubjectFrom(subject, from))\n  ids.add(normalizeDedupKey(dedupKey))\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner) ids.add(normalizeDedupKey(inner))\n  }\n}\n\n/** Check if email is a duplicate using normalized dedup keys */\nexport function isDuplicateEmail(\n  subject: string,\n  from: string,\n  messageId: string,\n  dateHeader: string,\n  existingIds: Set<string>\n): boolean {\n  const subjectFrom = normalizedSubjectFrom(subject, from)\n  if (existingIds.has(subjectFrom)) return true\n  const dedupKey = messageId\n    ? normalizeDedupKey(messageId)\n    : normalizeDedupKey(`${subject}|${from}|${dateHeader}`)\n  if (existingIds.has(dedupKey)) return true\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner && existingIds.has(normalizeDedupKey(inner))) return true\n  }\n  return false\n}\n\n/** Use email Message-ID as identifier when policy number not found */\nfunction fallbackPolicyDisplay(messageId: string | undefined, claimId: string): string {\n  if (!messageId) return claimId\n  // Message-ID format: <local@domain> - use the email ID itself (strip angle brackets)\n  if (messageId.includes('<') && messageId.includes('@')) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    return inner || claimId\n  }\n  return claimId\n}\n\n/** Save an ingested claim (from SendGrid, IMAP, or other source).\n * messageId: dedup key (stored in claim). emailMessageIdForDisplay: RFC Message-ID for fallback when no policy.\n */\nexport function saveIngestedClaim(\n  from: string,\n  to: string,\n  subject: string,\n  emailBody: string,\n  attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }>,\n  source: 'sendgrid' | 'imap' = 'sendgrid',\n  messageId?: string,\n  emailMessageIdForDisplay?: string\n): IngestedClaim {\n  const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  const extracted = extractPolicyNumber(emailBody) || extractPolicyNumber(subject)\n  const policyNumber = extracted ?? fallbackPolicyDisplay(emailMessageIdForDisplay ?? messageId, claimId)\n\n  ensureDataDir()\n  const claimDir = path.join(INGESTED_DIR, claimId)\n  fs.mkdirSync(claimDir, { recursive: true })\n\n  const attachments: IngestedAttachment[] = []\n  for (const file of attachmentFiles) {\n    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')\n    const filePath = path.join(claimDir, safeName)\n    fs.writeFileSync(filePath, file.buffer)\n    attachments.push({\n      name: file.name,\n      path: filePath,\n      size: file.buffer.length,\n      mimeType: file.mimeType || 'application/octet-stream',\n    })\n  }\n\n  const claim: IngestedClaim = {\n    id: claimId,\n    policyNumber,\n    from,\n    to,\n    subject,\n    emailBody,\n    attachments,\n    createdAt: new Date().toISOString(),\n    source,\n  }\n  if (messageId) claim.messageId = messageId\n\n  const claims = getClaimsData()\n  claims.unshift(claim)\n  saveClaimsData(claims)\n  return claim\n}\n\n/** Get all ingested claims (for dropdown). Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getAllIngestedClaims(): IngestedClaim[] {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  if (hasRealClaims) {\n    return claims.filter((c) => c.source !== 'demo')\n  }\n  return claims\n}\n\n/** Get a single claim by ID */\nexport function getIngestedClaimById(id: string): IngestedClaim | null {\n  const claims = getClaimsData()\n  return claims.find((c) => c.id === id) || null\n}\n\n/** Get distinct policy numbers for dropdown. Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getPolicyNumbers(): Array<{ id: string; policyNumber: string; subject: string }> {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  const toShow = hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n  return toShow.map((c) => ({\n    id: c.id,\n    policyNumber: c.policyNumber,\n    subject: c.subject,\n  }))\n}\n\n/** Seed demo claims from scenarios folder when no claims exist */\nfunction seedDemoClaims() {\n  const scenariosDir = path.join(process.cwd(), 'demo-data', 'scenarios')\n  if (!fs.existsSync(scenariosDir)) return\n\n  const scenarios = [\n    { folder: 'auto-collision', policyNumber: 'AC789456123', from: 'sarah.johnson@email.com', to: 'pranay.nath@aimill.in', subject: 'Car Accident Claim - Policy #AC789456123' },\n    { folder: 'commercial-liability', policyNumber: 'CL789012345', from: 'antonio.martinez@tonysrestaurant.com', to: 'pranay.nath@aimill.in', subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345' },\n    { folder: 'property-water-damage', policyNumber: 'HO456789234', from: 'robert.chen@email.com', to: 'pranay.nath@aimill.in', subject: 'Urgent - Water Damage Claim - Policy #HO456789234' },\n  ]\n\n  const claims: IngestedClaim[] = []\n  const baseTime = Date.now() - 86400000 * 2\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const s = scenarios[i]\n    const emailPath = path.join(scenariosDir, s.folder, 'email.txt')\n    const attachmentsDir = path.join(scenariosDir, s.folder, 'attachments')\n    if (!fs.existsSync(emailPath)) continue\n\n    const emailBody = fs.readFileSync(emailPath, 'utf-8')\n    const claimId = `DEMO-${s.policyNumber}-${i}`\n    const claimDir = path.join(INGESTED_DIR, claimId)\n    fs.mkdirSync(claimDir, { recursive: true })\n\n    const attachments: IngestedAttachment[] = []\n    if (fs.existsSync(attachmentsDir)) {\n      for (const file of fs.readdirSync(attachmentsDir)) {\n        const srcPath = path.join(attachmentsDir, file)\n        if (fs.statSync(srcPath).isFile()) {\n          const destPath = path.join(claimDir, file)\n          fs.copyFileSync(srcPath, destPath)\n          attachments.push({ name: file, path: destPath, size: fs.statSync(destPath).size, mimeType: 'text/plain' })\n        }\n      }\n    }\n\n    claims.push({\n      id: claimId,\n      policyNumber: s.policyNumber,\n      from: s.from,\n      to: s.to,\n      subject: s.subject,\n      emailBody,\n      attachments,\n      createdAt: new Date(baseTime + i * 3600000).toISOString(),\n      source: 'demo',\n    })\n  }\n\n  if (claims.length > 0) {\n    saveClaimsData(claims)\n  }\n}\n\n/** Clear all ingested claims and attachments (for fresh start) */\nexport function clearAllIngestedClaims(): void {\n  ensureDataDir()\n  if (fs.existsSync(CLAIMS_FILE)) fs.unlinkSync(CLAIMS_FILE)\n  if (fs.existsSync(INGESTED_DIR)) {\n    for (const entry of fs.readdirSync(INGESTED_DIR, { withFileTypes: true })) {\n      const fullPath = path.join(INGESTED_DIR, entry.name)\n      if (entry.isDirectory()) {\n        fs.rmSync(fullPath, { recursive: true })\n      }\n    }\n  }\n}\n\n/** Read attachment file content for processing (text files) */\nexport function readAttachmentContent(claimId: string, attachmentName: string): string {\n  const claim = getIngestedClaimById(claimId)\n  if (!claim) throw new Error('Claim not found')\n  const att = claim.attachments.find((a) => a.name === attachmentName)\n  if (!att || !fs.existsSync(att.path)) throw new Error('Attachment not found')\n  const ext = path.extname(att.name).toLowerCase()\n  if (['.txt', '.csv', '.log'].includes(ext)) {\n    return fs.readFileSync(att.path, 'utf-8')\n  }\n  return `[Document: ${att.name} - content extracted for processing]`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/app/api/ingested-claims/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getIngestedClaimById } from '@/lib/ingestedClaims'\n\n/** GET /api/ingested-claims/[id] - Get single ingested claim with email and attachments */\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params\n    const claim = getIngestedClaimById(id)\n\n    if (!claim) {\n      return NextResponse.json({ error: 'Claim not found' }, { status: 404 })\n    }\n\n    return NextResponse.json(claim)\n  } catch (error) {\n    console.error('Error fetching claim:', error)\n    return NextResponse.json(\n      { error: 'Failed to fetch claim' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAGO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACF,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QACrB,MAAM,QAAQ,IAAA,uLAAoB,EAAC;QAEnC,IAAI,CAAC,OAAO;YACV,OAAO,wLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QAEA,OAAO,wLAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yBAAyB;QACvC,OAAO,wLAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAwB,GACjC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}