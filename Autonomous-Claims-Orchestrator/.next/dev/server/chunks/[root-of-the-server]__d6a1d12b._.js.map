{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/services/ingested-claims/index.ts"],"sourcesContent":["/**\n * Ingested Claims Microservice\n *\n * Manages FNOL claims ingested from email (IMAP, SendGrid, demo).\n * Provides CRUD, policy extraction, deduplication, and attachment handling.\n */\n\nimport fs from 'fs'\nimport path from 'path'\nimport type { IngestedClaim, IngestedAttachment } from './types'\n\nconst DATA_DIR = path.join(process.cwd(), 'data')\nconst INGESTED_DIR = path.join(DATA_DIR, 'ingested-attachments')\nconst CLAIMS_FILE = path.join(DATA_DIR, 'ingested-claims.json')\n\nfunction ensureDataDir(): void {\n  if (!fs.existsSync(DATA_DIR)) {\n    fs.mkdirSync(DATA_DIR, { recursive: true })\n  }\n  if (!fs.existsSync(INGESTED_DIR)) {\n    fs.mkdirSync(INGESTED_DIR, { recursive: true })\n  }\n}\n\nfunction getClaimsData(): IngestedClaim[] {\n  ensureDataDir()\n  if (!fs.existsSync(CLAIMS_FILE)) return []\n  try {\n    return JSON.parse(fs.readFileSync(CLAIMS_FILE, 'utf-8'))\n  } catch {\n    return []\n  }\n}\n\nfunction saveClaimsData(claims: IngestedClaim[]): void {\n  ensureDataDir()\n  fs.writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8')\n}\n\nfunction normalizeDedupKey(s: string): string {\n  return s.trim().toLowerCase()\n}\n\nfunction normalizedSubjectFrom(subject: string, from: string): string {\n  return normalizeDedupKey(`${subject}|${from}`)\n}\n\nfunction fallbackPolicyDisplay(messageId: string | undefined, claimId: string): string {\n  if (!messageId) return claimId\n  if (messageId.includes('<') && messageId.includes('@')) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    return inner || claimId\n  }\n  return claimId\n}\n\nfunction seedDemoClaims(): void {\n  const scenariosDir = path.join(process.cwd(), 'demo-data', 'scenarios')\n  if (!fs.existsSync(scenariosDir)) return\n\n  const scenarios = [\n    {\n      folder: 'auto-collision',\n      policyNumber: 'AC789456123',\n      from: 'sarah.johnson@email.com',\n      to: 'pranay.nath@aimill.in',\n      subject: 'Car Accident Claim - Policy #AC789456123',\n    },\n    {\n      folder: 'commercial-liability',\n      policyNumber: 'CL789012345',\n      from: 'antonio.martinez@tonysrestaurant.com',\n      to: 'pranay.nath@aimill.in',\n      subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345',\n    },\n    {\n      folder: 'property-water-damage',\n      policyNumber: 'HO456789234',\n      from: 'robert.chen@email.com',\n      to: 'pranay.nath@aimill.in',\n      subject: 'Urgent - Water Damage Claim - Policy #HO456789234',\n    },\n  ]\n\n  const claims: IngestedClaim[] = []\n  const baseTime = Date.now() - 86400000 * 2\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const s = scenarios[i]\n    const emailPath = path.join(scenariosDir, s.folder, 'email.txt')\n    const attachmentsDir = path.join(scenariosDir, s.folder, 'attachments')\n    if (!fs.existsSync(emailPath)) continue\n\n    const emailBody = fs.readFileSync(emailPath, 'utf-8')\n    const claimId = `DEMO-${s.policyNumber}-${i}`\n    const claimDir = path.join(INGESTED_DIR, claimId)\n    fs.mkdirSync(claimDir, { recursive: true })\n\n    const attachments: IngestedAttachment[] = []\n    if (fs.existsSync(attachmentsDir)) {\n      for (const file of fs.readdirSync(attachmentsDir)) {\n        const srcPath = path.join(attachmentsDir, file)\n        if (fs.statSync(srcPath).isFile()) {\n          const destPath = path.join(claimDir, file)\n          fs.copyFileSync(srcPath, destPath)\n          attachments.push({\n            name: file,\n            path: destPath,\n            size: fs.statSync(destPath).size,\n            mimeType: 'text/plain',\n          })\n        }\n      }\n    }\n\n    claims.push({\n      id: claimId,\n      policyNumber: s.policyNumber,\n      from: s.from,\n      to: s.to,\n      subject: s.subject,\n      emailBody,\n      attachments,\n      createdAt: new Date(baseTime + i * 3600000).toISOString(),\n      source: 'demo',\n    })\n  }\n\n  if (claims.length > 0) saveClaimsData(claims)\n}\n\nexport { type IngestedClaim, type IngestedAttachment }\n\n/** Extract policy number from email body using common patterns */\nexport function extractPolicyNumber(emailBody: string): string | null {\n  const patterns = [\n    /policy\\s*#?\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /policy\\s*number\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /Policy\\s*#([A-Z0-9]+)/i,\n    /#([A-Z]{2}\\d{6,})/,\n    /\\b([A-Z]{2}\\d{6,})\\b/,\n  ]\n  for (const pattern of patterns) {\n    const match = emailBody.match(pattern)\n    if (match?.[1]) return match[1]\n  }\n  return null\n}\n\n/** Get existing message IDs for deduplication */\nexport function getExistingMessageIds(): Set<string> {\n  const claims = getClaimsData()\n  const ids = new Set<string>()\n  for (const c of claims) {\n    ids.add(normalizedSubjectFrom(c.subject, c.from))\n    if (c.messageId) {\n      ids.add(normalizeDedupKey(c.messageId))\n      const inner = c.messageId.replace(/^<|>$/g, '').trim()\n      if (inner) ids.add(normalizeDedupKey(inner))\n    }\n  }\n  return ids\n}\n\n/** Add dedup keys for a newly ingested claim */\nexport function addDedupKeysToSet(\n  ids: Set<string>,\n  subject: string,\n  from: string,\n  messageId: string,\n  dedupKey: string\n): void {\n  ids.add(normalizedSubjectFrom(subject, from))\n  ids.add(normalizeDedupKey(dedupKey))\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner) ids.add(normalizeDedupKey(inner))\n  }\n}\n\n/** Check if email is a duplicate */\nexport function isDuplicateEmail(\n  subject: string,\n  from: string,\n  messageId: string,\n  dateHeader: string,\n  existingIds: Set<string>\n): boolean {\n  if (existingIds.has(normalizedSubjectFrom(subject, from))) return true\n  const dedupKey = messageId\n    ? normalizeDedupKey(messageId)\n    : normalizeDedupKey(`${subject}|${from}|${dateHeader}`)\n  if (existingIds.has(dedupKey)) return true\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner && existingIds.has(normalizeDedupKey(inner))) return true\n  }\n  return false\n}\n\n/** Save an ingested claim */\nexport function saveIngestedClaim(\n  from: string,\n  to: string,\n  subject: string,\n  emailBody: string,\n  attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }>,\n  source: 'sendgrid' | 'imap' = 'sendgrid',\n  messageId?: string,\n  emailMessageIdForDisplay?: string\n): IngestedClaim {\n  const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  const extracted = extractPolicyNumber(emailBody) || extractPolicyNumber(subject)\n  const policyNumber =\n    extracted ?? fallbackPolicyDisplay(emailMessageIdForDisplay ?? messageId, claimId)\n\n  ensureDataDir()\n  const claimDir = path.join(INGESTED_DIR, claimId)\n  fs.mkdirSync(claimDir, { recursive: true })\n\n  const attachments: IngestedAttachment[] = []\n  for (const file of attachmentFiles) {\n    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')\n    const filePath = path.join(claimDir, safeName)\n    fs.writeFileSync(filePath, file.buffer)\n    attachments.push({\n      name: file.name,\n      path: filePath,\n      size: file.buffer.length,\n      mimeType: file.mimeType || 'application/octet-stream',\n    })\n  }\n\n  const claim: IngestedClaim = {\n    id: claimId,\n    policyNumber,\n    from,\n    to,\n    subject,\n    emailBody,\n    attachments,\n    createdAt: new Date().toISOString(),\n    source,\n  }\n  if (messageId) claim.messageId = messageId\n\n  const claims = getClaimsData()\n  claims.unshift(claim)\n  saveClaimsData(claims)\n  return claim\n}\n\n/** Get all ingested claims */\nexport function getAllIngestedClaims(): IngestedClaim[] {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  return hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n}\n\n/** Get a single claim by ID */\nexport function getIngestedClaimById(id: string): IngestedClaim | null {\n  const claims = getClaimsData()\n  return claims.find((c) => c.id === id) ?? null\n}\n\n/** Get policy numbers for dropdown */\nexport function getPolicyNumbers(): Array<{ id: string; policyNumber: string; subject: string }> {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  const toShow = hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n  return toShow.map((c) => ({ id: c.id, policyNumber: c.policyNumber, subject: c.subject }))\n}\n\n/** Clear all ingested claims */\nexport function clearAllIngestedClaims(): void {\n  ensureDataDir()\n  if (fs.existsSync(CLAIMS_FILE)) fs.unlinkSync(CLAIMS_FILE)\n  if (fs.existsSync(INGESTED_DIR)) {\n    for (const entry of fs.readdirSync(INGESTED_DIR, { withFileTypes: true })) {\n      const fullPath = path.join(INGESTED_DIR, entry.name)\n      if (entry.isDirectory()) fs.rmSync(fullPath, { recursive: true })\n    }\n  }\n}\n\n/** Read attachment content for processing */\nexport function readAttachmentContent(claimId: string, attachmentName: string): string {\n  const claim = getIngestedClaimById(claimId)\n  if (!claim) throw new Error('Claim not found')\n  const att = claim.attachments.find((a) => a.name === attachmentName)\n  if (!att || !fs.existsSync(att.path)) throw new Error('Attachment not found')\n  const ext = path.extname(att.name).toLowerCase()\n  if (['.txt', '.csv', '.log'].includes(ext)) {\n    return fs.readFileSync(att.path, 'utf-8')\n  }\n  return `[Document: ${att.name} - content extracted for processing]`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/services/extraction/index.ts"],"sourcesContent":["/**\n * Extraction Microservice\n *\n * Runs information_extraction.py (LLM-based extraction from email, documents, images).\n * Returns structured claim fields, evidence, and document analysis.\n */\n\nimport { spawn } from 'child_process'\nimport path from 'path'\nimport { getIngestedClaimById } from '@/services/ingested-claims'\nimport type { ExtractionResult } from './types'\nexport type { ExtractionResult } from './types'\n\nconst SCRIPT_PATH = path.join(process.cwd(), 'services', 'extraction', 'extraction.py')\nconst PY_CMD = process.platform === 'win32' ? 'python' : 'python3'\n\n/** Run extraction for an ingested claim */\nexport async function runExtraction(ingestedClaimId: string): Promise<ExtractionResult> {\n  const claim = getIngestedClaimById(ingestedClaimId)\n  if (!claim) {\n    throw new Error('Claim not found')\n  }\n\n  return new Promise<ExtractionResult>((resolve, reject) => {\n    const proc = spawn(PY_CMD, [SCRIPT_PATH, ingestedClaimId], {\n      cwd: process.cwd(),\n      env: { ...process.env },\n    })\n\n    let stdout = ''\n    let stderr = ''\n\n    proc.stdout?.on('data', (d) => {\n      stdout += d.toString()\n    })\n    proc.stderr?.on('data', (d) => {\n      stderr += d.toString()\n    })\n\n    proc.on('close', (code) => {\n      try {\n        const parsed = JSON.parse(stdout.trim())\n        if (parsed.error) {\n          reject(new Error(parsed.error))\n        } else {\n          resolve(parsed)\n        }\n      } catch {\n        reject(\n          new Error(stderr || stdout || `Python exited with code ${code}`)\n        )\n      }\n    })\n\n    proc.on('error', (err) => reject(err))\n  })\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;CAKC,GAED;AACA;AACA;;;;AAIA,MAAM,cAAc,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,cAAc;AACvE,MAAM,SAAS,sCAA+B,0BAAW;AAGlD,eAAe,cAAc,eAAuB;IACzD,MAAM,QAAQ,IAAA,yMAAoB,EAAC;IACnC,IAAI,CAAC,OAAO;QACV,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO,IAAI,QAA0B,CAAC,SAAS;QAC7C,MAAM,OAAO,IAAA,4HAAK,EAAC,QAAQ;YAAC;YAAa;SAAgB,EAAE;YACzD,KAAK,QAAQ,GAAG;YAChB,KAAK;gBAAE,GAAG,QAAQ,GAAG;YAAC;QACxB;QAEA,IAAI,SAAS;QACb,IAAI,SAAS;QAEb,KAAK,MAAM,EAAE,GAAG,QAAQ,CAAC;YACvB,UAAU,EAAE,QAAQ;QACtB;QACA,KAAK,MAAM,EAAE,GAAG,QAAQ,CAAC;YACvB,UAAU,EAAE,QAAQ;QACtB;QAEA,KAAK,EAAE,CAAC,SAAS,CAAC;YAChB,IAAI;gBACF,MAAM,SAAS,KAAK,KAAK,CAAC,OAAO,IAAI;gBACrC,IAAI,OAAO,KAAK,EAAE;oBAChB,OAAO,IAAI,MAAM,OAAO,KAAK;gBAC/B,OAAO;oBACL,QAAQ;gBACV;YACF,EAAE,OAAM;gBACN,OACE,IAAI,MAAM,UAAU,UAAU,CAAC,wBAAwB,EAAE,MAAM;YAEnE;QACF;QAEA,KAAK,EAAE,CAAC,SAAS,CAAC,MAAQ,OAAO;IACnC;AACF"}},
    {"offset": {"line": 408, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/policyClauses.ts"],"sourcesContent":["/**\n * Policy clauses database — ISO form references and market-standard language.\n * Clauses align with ISO Personal Auto Policy (PAP), ISO HO-3, and ISO CGL forms.\n */\n\nimport type { PolicyHit } from '@/types/claims'\n\nexport interface PolicyClause {\n  clauseId: string\n  formRef: string\n  title: string\n  section: string\n  content: string\n  lossTypes: string[]\n  productTypes: string[]\n  /** When set, claim must include this peril or clause is excluded (avoids theft matching water claims) */\n  primaryPeril?: string\n}\n\nconst POLICY_CLAUSES: PolicyClause[] = [\n  {\n    clauseId: 'PAP-D-001',\n    formRef: 'ISO PAP 2018',\n    title: 'Part D – Coverage for Damage to Your Auto (Collision)',\n    section: 'Part D – Physical Damage',\n    content:\n      'We will pay for direct and accidental loss to your covered auto caused by collision. \"Collision\" means the upset of your covered auto or its impact with another vehicle or object. Our limit of liability for loss will be the lesser of: (1) the actual cash value of the stolen or damaged property; or (2) the amount necessary to repair or replace the property with other property of like kind and quality. The deductible shown in the Declarations applies to each loss.',\n    lossTypes: ['collision', 'autocollision', 'auto'],\n    productTypes: ['auto', 'ac'],\n  },\n  {\n    clauseId: 'PAP-A-002',\n    formRef: 'ISO PAP 2018',\n    title: 'Part A – Liability Coverage (Bodily Injury)',\n    section: 'Part A – Liability',\n    content:\n      'We will pay damages for bodily injury or death for which any insured becomes legally responsible because of an auto accident. Damages include prejudgment interest awarded against the insured. We will settle or defend, as we consider appropriate, any claim or suit asking for these damages. In addition to our limit of liability, we will pay all defense costs we incur. Our duty to settle or defend ends when our limit of liability for this coverage has been exhausted by payment of judgments or settlements.',\n    lossTypes: ['collision', 'autocollision', 'liability', 'bodily injury'],\n    productTypes: ['auto', 'ac', 'cl'],\n  },\n  {\n    clauseId: 'PAP-C-003',\n    formRef: 'ISO PAP 2018',\n    title: 'Part C – Uninsured Motorists Coverage',\n    section: 'Part C – Uninsured Motorists',\n    content:\n      'We will pay compensatory damages which an insured is legally entitled to recover from the owner or operator of an uninsured motor vehicle because of bodily injury sustained by an insured caused by an accident. The owner\\'s or operator\\'s liability for these damages must arise out of the ownership, maintenance or use of the uninsured motor vehicle. Any judgment for damages arising out of a suit brought without our written consent is not binding on us.',\n    lossTypes: ['collision', 'autocollision'],\n    productTypes: ['auto', 'ac'],\n  },\n  {\n    clauseId: 'HO3-I-004',\n    formRef: 'ISO HO-3 2011',\n    title: 'Section I – Accidental Discharge or Overflow of Water',\n    section: 'Section I – Perils Insured Against (Coverage A & B)',\n    content:\n      'We insure for direct physical loss to property described in Coverages A and B caused by: (8) Accidental discharge or overflow of water or steam from within a plumbing, heating, air conditioning or automatic fire protective sprinkler system or from within a household appliance, on the residence premises. This includes the cost to tear out and replace any part of a building necessary to repair the system or appliance from which the water or steam escaped. We do not cover loss to the system or appliance from which the water or steam escaped, or loss caused by or resulting from freezing except as provided in the Freezing of Plumbing peril. We do not cover loss from constant or repeated seepage or leakage over a period of 14 or more days.',\n    lossTypes: ['water', 'propertydamage', 'property'],\n    productTypes: ['home', 'ho', 'property'],\n  },\n  {\n    clauseId: 'HO3-I-005',\n    formRef: 'ISO HO-3 2011',\n    title: 'Section I – Windstorm or Hail',\n    section: 'Section I – Perils Insured Against',\n    content:\n      'We insure for direct physical loss to property described in Coverages A and B caused by: (1) Windstorm or hail. This includes damage to roofs, siding, and other exterior surfaces. Tree limb or debris impact to the roof resulting in water intrusion is covered when windstorm or hail is the proximate cause of the damage. We do not cover loss to the interior of a building or the property inside it unless the wind or hail first damages the building, allowing the wind or hail to enter.',\n    lossTypes: ['water', 'propertydamage', 'property', 'storm'],\n    productTypes: ['home', 'ho', 'property'],\n  },\n  {\n    clauseId: 'HO3-I-006',\n    formRef: 'ISO HO-3 2011',\n    title: 'Section I – Deductible',\n    section: 'Section I – Conditions',\n    content:\n      'Our payment for loss will be the amount of loss minus your deductible. The deductible applies per occurrence. For loss caused by windstorm or hail, a separate windstorm or hail deductible may apply as shown in the Declarations. This deductible is calculated as a percentage of the Coverage A limit of liability. For all other covered perils, the deductible shown in the Declarations applies. No deductible applies to loss from theft.',\n    lossTypes: ['water', 'fire', 'theft', 'propertydamage', 'collision'],\n    productTypes: ['home', 'ho', 'auto', 'ac'],\n  },\n  {\n    clauseId: 'HO3-I-007',\n    formRef: 'ISO HO-3 2011',\n    primaryPeril: 'fire',\n    title: 'Section I – Fire or Lightning',\n    section: 'Section I – Perils Insured Against',\n    content:\n      'We insure for direct physical loss to property described in Coverages A and B caused by: (2) Fire or lightning. This includes loss from smoke, scorching, or other damage caused by fire or lightning. We also cover loss from water or other substances used to extinguish the fire. We cover the cost of debris removal resulting from a loss we cover. We do not cover loss caused by fire resulting from agricultural smudging or industrial operations.',\n    lossTypes: ['fire'],\n    productTypes: ['home', 'ho', 'property'],\n  },\n  {\n    clauseId: 'HO3-I-008',\n    formRef: 'ISO HO-3 2011',\n    primaryPeril: 'theft',\n    title: 'Section I – Theft',\n    section: 'Section I – Perils Insured Against',\n    content:\n      'We insure for direct physical loss to property described in Coverages A and B caused by: (11) Theft, including attempted theft. We also cover loss of property from a known place when it is likely that the property has been stolen. We do not cover loss caused by theft committed by an insured. Proof of loss may require you to furnish a copy of the police report. We may require you to submit to examination under oath.',\n    lossTypes: ['theft'],\n    productTypes: ['home', 'ho', 'property'],\n  },\n  {\n    clauseId: 'CGL-A-009',\n    formRef: 'ISO CG 00 01',\n    title: 'Coverage A – Bodily Injury and Property Damage Liability',\n    section: 'Coverage A – Insuring Agreement',\n    content:\n      'We will pay those sums that the insured becomes legally obligated to pay as damages because of \"bodily injury\" or \"property damage\" to which this insurance applies. We will have the right and duty to defend the insured against any \"suit\" seeking those damages. However, we will have no duty to defend the insured against any \"suit\" seeking damages for \"bodily injury\" or \"property damage\" to which this insurance does not apply. We may, at our discretion, investigate any \"occurrence\" and settle any claim or \"suit\" that may result. Our duty to settle or defend ends when we have used up the applicable limit of insurance in the payment of judgments or settlements.',\n    lossTypes: ['liability', 'slip and fall', 'bodily injury'],\n    productTypes: ['commercial', 'cl'],\n  },\n  {\n    clauseId: 'CGL-A-010',\n    formRef: 'ISO CG 00 01',\n    title: 'Coverage A – Premises and Operations',\n    section: 'Coverage A – Bodily Injury and Property Damage',\n    content:\n      'This insurance applies to \"bodily injury\" and \"property damage\" only if: (1) The \"bodily injury\" or \"property damage\" is caused by an \"occurrence\" that takes place in the \"coverage territory\"; (2) The \"bodily injury\" or \"property damage\" occurs during the policy period; and (3) Prior to the policy period, no insured listed under Paragraph 1. of Section II – Who Is An Insured and no \"employee\" authorized by you to give or receive notice of an \"occurrence\" or claim, knew that the \"bodily injury\" or \"property damage\" had occurred. \"Occurrence\" means an accident, including continuous or repeated exposure to substantially the same general harmful conditions. Premises liability, including slip, trip and fall incidents on your premises, falls within this coverage.',\n    lossTypes: ['liability', 'slip and fall', 'premises'],\n    productTypes: ['commercial', 'cl'],\n  },\n  {\n    clauseId: 'GEN-011',\n    formRef: 'Standard Conditions',\n    title: 'Duties in the Event of Loss',\n    section: 'Conditions – Notice and Cooperation',\n    content:\n      'You must see that the following are done in the event of loss: (a) Give prompt notice to us or our agent; (b) Give a description of how, when and where the loss occurred; (c) Take all reasonable steps to protect the property from further damage, and keep a record of your expenses for consideration in the settlement of the claim; (d) As often as we reasonably require, show the damaged property and provide us with records and documents we request; (e) Submit to examination under oath if we require it.',\n    lossTypes: ['collision', 'water', 'fire', 'theft', 'liability', 'propertydamage', 'other'],\n    productTypes: ['auto', 'home', 'commercial', 'ac', 'ho', 'cl'],\n  },\n  {\n    clauseId: 'GEN-012',\n    formRef: 'Standard Conditions',\n    title: 'Loss Payment',\n    section: 'Conditions – Settlement',\n    content:\n      'We will pay for covered loss within 30 days after we receive your proof of loss, if you have complied with all of the terms of this policy and: (a) We have reached agreement with you on the amount of loss; or (b) An appraisal award has been made. We will pay only for the actual cash value of the damage until actual repair or replacement is complete. Once actual repair or replacement is complete, we will pay the amount you actually spend that is necessary to complete the repair or replacement.',\n    lossTypes: ['collision', 'water', 'fire', 'theft', 'liability', 'other'],\n    productTypes: ['auto', 'home', 'commercial', 'ac', 'ho', 'cl'],\n  },\n]\n\nfunction inferProductTypes(policyNumber: string): string[] {\n  const p = (policyNumber || '').toUpperCase().replace(/\\*+/g, '').trim()\n  if (p.startsWith('AC') || p.startsWith('AUTO')) return ['auto', 'ac']\n  if (p.startsWith('HO') || p.startsWith('HP') || p.startsWith('PROP')) return ['home', 'ho', 'property']\n  if (p.startsWith('CL') || p.startsWith('GL') || p.startsWith('COM')) return ['commercial', 'cl']\n  return ['auto', 'home', 'commercial', 'ac', 'ho', 'cl']\n}\n\nfunction inferLossTypes(lossType: string, description?: string): string[] {\n  const types = new Set<string>()\n  const lt = (lossType || '').toLowerCase()\n  const desc = (description || '').toLowerCase()\n  const combined = `${lt} ${desc}`\n\n  if (/\\b(collision|auto|autocollision|accident|vehicle|car)\\b/.test(combined)) {\n    types.add('collision').add('autocollision').add('auto')\n  }\n  if (/\\b(water|leak|flood|storm|roof|intrusion|ceiling|pipe)\\b/.test(combined)) {\n    types.add('water').add('propertydamage').add('property')\n  }\n  if (/\\b(fire|smoke)\\b/.test(combined)) types.add('fire').add('propertydamage')\n  if (/\\b(theft|stolen)\\b/.test(combined)) types.add('theft').add('propertydamage')\n  if (/\\b(liability|slip|fall|premises|customer|restaurant|business)\\b/.test(combined)) {\n    types.add('liability').add('slip and fall').add('premises')\n  }\n  if (/\\b(property|home|house|property damage)\\b/.test(combined)) {\n    types.add('property').add('propertydamage')\n  }\n\n  if (types.size === 0) {\n    if (lt) types.add(lt.replace(/\\s+/g, ''))\n    types.add('other')\n  }\n  return Array.from(types)\n}\n\nfunction computeSimilarity(\n  clause: PolicyClause,\n  lossTypes: string[],\n  productTypes: string[]\n): number {\n  const claimLossSet = new Set(lossTypes.map((t) => t.toLowerCase()))\n\n  // Peril-specific clauses (e.g. Theft, Fire) must match their primary peril\n  if (clause.primaryPeril) {\n    const required = clause.primaryPeril.toLowerCase()\n    if (!claimLossSet.has(required) && ![...claimLossSet].some((lt) => lt.includes(required) || required.includes(lt))) {\n      return 0\n    }\n  }\n\n  let score = 0.5\n  const clauseLoss = clause.lossTypes.map((t) => t.toLowerCase())\n  const clauseProduct = clause.productTypes.map((t) => t.toLowerCase())\n  for (const lt of lossTypes) {\n    if (clauseLoss.some((c) => c.includes(lt) || lt.includes(c))) {\n      score += 0.28\n      break\n    }\n  }\n  for (const pt of productTypes) {\n    if (clauseProduct.some((c) => c.includes(pt) || pt.includes(c))) {\n      score += 0.2\n      break\n    }\n  }\n  return Math.min(0.97, score)\n}\n\nfunction buildRationale(clause: PolicyClause, lossType: string, policyNumber: string): string {\n  const parts: string[] = [clause.formRef]\n  if (lossType) parts.push(`Loss type: ${lossType}`)\n  if (policyNumber) parts.push('Product type applicable')\n  return parts.join(' • ')\n}\n\n/**\n * Get policy grounding (matching clauses) based on extracted claim fields.\n */\nexport function getPolicyGrounding(extractedFields: Record<string, unknown>): PolicyHit[] {\n  const policyNumber = String(extractedFields.policyNumber || '').replace(/\\*+/g, '').trim()\n  const lossType = String(extractedFields.lossType || 'Other').trim()\n  const description = String(extractedFields.description || '')\n\n  const productTypes = policyNumber ? inferProductTypes(policyNumber) : ['auto', 'home', 'commercial', 'ac', 'ho', 'cl']\n  const lossTypes = inferLossTypes(lossType, description)\n\n  const scored = POLICY_CLAUSES.map((clause) => {\n    const similarity = computeSimilarity(clause, lossTypes, productTypes)\n    return {\n      ...clause,\n      similarity,\n      rationale: buildRationale(clause, lossType, policyNumber),\n    }\n  })\n\n  scored.sort((a, b) => b.similarity - a.similarity)\n  const hits = scored.slice(0, 6).filter((s) => s.similarity >= 0.6)\n\n  return hits.map((c) => ({\n    clauseId: c.clauseId,\n    title: c.title,\n    snippet: c.content.slice(0, 140) + (c.content.length > 140 ? '...' : ''),\n    content: c.content,\n    section: c.section,\n    score: c.similarity,\n    similarity: c.similarity,\n    rationale: c.rationale,\n    sourceRef: c.formRef,\n    sourceDocument: 'Policy Schedule',\n  }))\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAgBD,MAAM,iBAAiC;IACrC;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;YAAiB;SAAO;QACjD,cAAc;YAAC;YAAQ;SAAK;IAC9B;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;YAAiB;YAAa;SAAgB;QACvE,cAAc;YAAC;YAAQ;YAAM;SAAK;IACpC;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;SAAgB;QACzC,cAAc;YAAC;YAAQ;SAAK;IAC9B;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAS;YAAkB;SAAW;QAClD,cAAc;YAAC;YAAQ;YAAM;SAAW;IAC1C;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAS;YAAkB;YAAY;SAAQ;QAC3D,cAAc;YAAC;YAAQ;YAAM;SAAW;IAC1C;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAS;YAAQ;YAAS;YAAkB;SAAY;QACpE,cAAc;YAAC;YAAQ;YAAM;YAAQ;SAAK;IAC5C;IACA;QACE,UAAU;QACV,SAAS;QACT,cAAc;QACd,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;SAAO;QACnB,cAAc;YAAC;YAAQ;YAAM;SAAW;IAC1C;IACA;QACE,UAAU;QACV,SAAS;QACT,cAAc;QACd,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;SAAQ;QACpB,cAAc;YAAC;YAAQ;YAAM;SAAW;IAC1C;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;YAAiB;SAAgB;QAC1D,cAAc;YAAC;YAAc;SAAK;IACpC;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;YAAiB;SAAW;QACrD,cAAc;YAAC;YAAc;SAAK;IACpC;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;YAAS;YAAQ;YAAS;YAAa;YAAkB;SAAQ;QAC1F,cAAc;YAAC;YAAQ;YAAQ;YAAc;YAAM;YAAM;SAAK;IAChE;IACA;QACE,UAAU;QACV,SAAS;QACT,OAAO;QACP,SAAS;QACT,SACE;QACF,WAAW;YAAC;YAAa;YAAS;YAAQ;YAAS;YAAa;SAAQ;QACxE,cAAc;YAAC;YAAQ;YAAQ;YAAc;YAAM;YAAM;SAAK;IAChE;CACD;AAED,SAAS,kBAAkB,YAAoB;IAC7C,MAAM,IAAI,CAAC,gBAAgB,EAAE,EAAE,WAAW,GAAG,OAAO,CAAC,QAAQ,IAAI,IAAI;IACrE,IAAI,EAAE,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,SAAS,OAAO;QAAC;QAAQ;KAAK;IACrE,IAAI,EAAE,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,SAAS,OAAO;QAAC;QAAQ;QAAM;KAAW;IACvG,IAAI,EAAE,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,QAAQ,OAAO;QAAC;QAAc;KAAK;IAChG,OAAO;QAAC;QAAQ;QAAQ;QAAc;QAAM;QAAM;KAAK;AACzD;AAEA,SAAS,eAAe,QAAgB,EAAE,WAAoB;IAC5D,MAAM,QAAQ,IAAI;IAClB,MAAM,KAAK,CAAC,YAAY,EAAE,EAAE,WAAW;IACvC,MAAM,OAAO,CAAC,eAAe,EAAE,EAAE,WAAW;IAC5C,MAAM,WAAW,GAAG,GAAG,CAAC,EAAE,MAAM;IAEhC,IAAI,0DAA0D,IAAI,CAAC,WAAW;QAC5E,MAAM,GAAG,CAAC,aAAa,GAAG,CAAC,iBAAiB,GAAG,CAAC;IAClD;IACA,IAAI,2DAA2D,IAAI,CAAC,WAAW;QAC7E,MAAM,GAAG,CAAC,SAAS,GAAG,CAAC,kBAAkB,GAAG,CAAC;IAC/C;IACA,IAAI,mBAAmB,IAAI,CAAC,WAAW,MAAM,GAAG,CAAC,QAAQ,GAAG,CAAC;IAC7D,IAAI,qBAAqB,IAAI,CAAC,WAAW,MAAM,GAAG,CAAC,SAAS,GAAG,CAAC;IAChE,IAAI,kEAAkE,IAAI,CAAC,WAAW;QACpF,MAAM,GAAG,CAAC,aAAa,GAAG,CAAC,iBAAiB,GAAG,CAAC;IAClD;IACA,IAAI,4CAA4C,IAAI,CAAC,WAAW;QAC9D,MAAM,GAAG,CAAC,YAAY,GAAG,CAAC;IAC5B;IAEA,IAAI,MAAM,IAAI,KAAK,GAAG;QACpB,IAAI,IAAI,MAAM,GAAG,CAAC,GAAG,OAAO,CAAC,QAAQ;QACrC,MAAM,GAAG,CAAC;IACZ;IACA,OAAO,MAAM,IAAI,CAAC;AACpB;AAEA,SAAS,kBACP,MAAoB,EACpB,SAAmB,EACnB,YAAsB;IAEtB,MAAM,eAAe,IAAI,IAAI,UAAU,GAAG,CAAC,CAAC,IAAM,EAAE,WAAW;IAE/D,2EAA2E;IAC3E,IAAI,OAAO,YAAY,EAAE;QACvB,MAAM,WAAW,OAAO,YAAY,CAAC,WAAW;QAChD,IAAI,CAAC,aAAa,GAAG,CAAC,aAAa,CAAC;eAAI;SAAa,CAAC,IAAI,CAAC,CAAC,KAAO,GAAG,QAAQ,CAAC,aAAa,SAAS,QAAQ,CAAC,MAAM;YAClH,OAAO;QACT;IACF;IAEA,IAAI,QAAQ;IACZ,MAAM,aAAa,OAAO,SAAS,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,WAAW;IAC5D,MAAM,gBAAgB,OAAO,YAAY,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,WAAW;IAClE,KAAK,MAAM,MAAM,UAAW;QAC1B,IAAI,WAAW,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAC,KAAK;YAC5D,SAAS;YACT;QACF;IACF;IACA,KAAK,MAAM,MAAM,aAAc;QAC7B,IAAI,cAAc,IAAI,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC,OAAO,GAAG,QAAQ,CAAC,KAAK;YAC/D,SAAS;YACT;QACF;IACF;IACA,OAAO,KAAK,GAAG,CAAC,MAAM;AACxB;AAEA,SAAS,eAAe,MAAoB,EAAE,QAAgB,EAAE,YAAoB;IAClF,MAAM,QAAkB;QAAC,OAAO,OAAO;KAAC;IACxC,IAAI,UAAU,MAAM,IAAI,CAAC,CAAC,WAAW,EAAE,UAAU;IACjD,IAAI,cAAc,MAAM,IAAI,CAAC;IAC7B,OAAO,MAAM,IAAI,CAAC;AACpB;AAKO,SAAS,mBAAmB,eAAwC;IACzE,MAAM,eAAe,OAAO,gBAAgB,YAAY,IAAI,IAAI,OAAO,CAAC,QAAQ,IAAI,IAAI;IACxF,MAAM,WAAW,OAAO,gBAAgB,QAAQ,IAAI,SAAS,IAAI;IACjE,MAAM,cAAc,OAAO,gBAAgB,WAAW,IAAI;IAE1D,MAAM,eAAe,eAAe,kBAAkB,gBAAgB;QAAC;QAAQ;QAAQ;QAAc;QAAM;QAAM;KAAK;IACtH,MAAM,YAAY,eAAe,UAAU;IAE3C,MAAM,SAAS,eAAe,GAAG,CAAC,CAAC;QACjC,MAAM,aAAa,kBAAkB,QAAQ,WAAW;QACxD,OAAO;YACL,GAAG,MAAM;YACT;YACA,WAAW,eAAe,QAAQ,UAAU;QAC9C;IACF;IAEA,OAAO,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,UAAU,GAAG,EAAE,UAAU;IACjD,MAAM,OAAO,OAAO,KAAK,CAAC,GAAG,GAAG,MAAM,CAAC,CAAC,IAAM,EAAE,UAAU,IAAI;IAE9D,OAAO,KAAK,GAAG,CAAC,CAAC,IAAM,CAAC;YACtB,UAAU,EAAE,QAAQ;YACpB,OAAO,EAAE,KAAK;YACd,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,GAAG,OAAO,CAAC,EAAE,OAAO,CAAC,MAAM,GAAG,MAAM,QAAQ,EAAE;YACvE,SAAS,EAAE,OAAO;YAClB,SAAS,EAAE,OAAO;YAClB,OAAO,EAAE,UAAU;YACnB,YAAY,EAAE,UAAU;YACxB,WAAW,EAAE,SAAS;YACtB,WAAW,EAAE,OAAO;YACpB,gBAAgB;QAClB,CAAC;AACH"}},
    {"offset": {"line": 757, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/confidence.ts"],"sourcesContent":["/**\n * Confidence score thresholds used across the application.\n * All displayed confidence values should be real-time (from extraction), not static.\n */\n\nexport const CONFIDENCE = {\n  /** High: auto-approve / trusted */\n  THRESHOLD_HIGH: 0.8,\n  /** Medium: proceed with normal review */\n  THRESHOLD_MEDIUM: 0.6,\n  /** Low: requires manual review */\n  THRESHOLD_LOW: 0,\n} as const\n\nexport function isHighConfidence(c: number): boolean {\n  return c >= CONFIDENCE.THRESHOLD_HIGH\n}\n\nexport function isMediumConfidence(c: number): boolean {\n  return c >= CONFIDENCE.THRESHOLD_MEDIUM && c < CONFIDENCE.THRESHOLD_HIGH\n}\n\nexport function isLowConfidence(c: number): boolean {\n  return c < CONFIDENCE.THRESHOLD_MEDIUM\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;AAEM,MAAM,aAAa;IACxB,iCAAiC,GACjC,gBAAgB;IAChB,uCAAuC,GACvC,kBAAkB;IAClB,gCAAgC,GAChC,eAAe;AACjB;AAEO,SAAS,iBAAiB,CAAS;IACxC,OAAO,KAAK,WAAW,cAAc;AACvC;AAEO,SAAS,mBAAmB,CAAS;IAC1C,OAAO,KAAK,WAAW,gBAAgB,IAAI,IAAI,WAAW,cAAc;AAC1E;AAEO,SAAS,gBAAgB,CAAS;IACvC,OAAO,IAAI,WAAW,gBAAgB;AACxC"}},
    {"offset": {"line": 788, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/services/decision/index.ts"],"sourcesContent":["/**\n * Decision Microservice\n *\n * Builds decision pack: policy grounding, claim draft, evidence summary,\n * document analysis, and policy assessment.\n */\n\nimport { getPolicyGrounding } from '@/lib/policyClauses'\nimport { CONFIDENCE } from '@/lib/confidence'\nimport type { ClaimData, ClaimDraft, Document, LossType } from '@/types/claims'\nimport type { IngestedClaim } from '@/services/ingested-claims'\nimport type { ExtractionResult } from '@/services/extraction'\n\nfunction maskEmail(email: string | null): string {\n  if (!email) return 'Not found'\n  const [user, domain] = email.split('@')\n  return `${user.slice(0, 2)}***@${domain}`\n}\n\nfunction maskPhone(phone: string | null): string {\n  if (!phone) return 'Not found'\n  return phone.replace(/\\d(?=\\d{4})/g, '*')\n}\n\n/** Build claim draft from extraction result */\nfunction buildClaimDraft(\n  fields: Record<string, unknown>,\n  claim: IngestedClaim,\n  extraction: ExtractionResult\n): ClaimDraft {\n  const now = new Date().toISOString()\n  return {\n    id: `DRAFT-${Date.now()}`,\n    policyNumber: (fields.policyNumber as string)\n      ? `***${String(fields.policyNumber).slice(-3)}`\n      : 'Not found',\n    claimantName: (fields.claimantName as string) || 'Not found',\n    contactEmail: maskEmail((fields.contactEmail as string) ?? null),\n    contactPhone: maskPhone((fields.contactPhone as string) ?? null),\n    lossDate: (fields.lossDate as string) || now.split('T')[0],\n    lossType: ((fields.lossType as string) || 'Other') as LossType,\n    lossLocation: (fields.lossLocation as string) || 'See description',\n    description: (fields.description as string) || 'Claim submitted via email',\n    estimatedAmount: (fields.estimatedAmount as number) ?? (fields.estimatedDamage as number) ?? 0,\n    vehicleInfo: fields.vehicleInfo as Record<string, unknown> | undefined,\n    propertyAddress: fields.propertyAddress as string | undefined,\n    attachments: claim.attachments.map((a, i) => ({\n      id: `doc_${i}`,\n      name: a.name,\n      type: extraction.documents[i]?.type || 'Other',\n      mimeType: a.mimeType,\n      confidence: extraction.documents[i]?.confidence ?? 0.7,\n    })),\n    coverageFound: !!fields.policyNumber,\n    deductible: fields.policyNumber ? 500 : undefined,\n    createdAt: now,\n    source: 'information_extraction',\n    confidence:\n      extraction.evidence.length > 0\n        ? extraction.evidence.reduce((s, e) => s + e.confidence, 0) / extraction.evidence.length\n        : 0,\n  }\n}\n\n/** Build full decision pack and claim data */\nexport function buildDecisionPack(\n  ingestedClaimId: string,\n  claim: IngestedClaim,\n  extraction: ExtractionResult\n): ClaimData {\n  const fields = extraction.extractedFields || {}\n  const policyGrounding = getPolicyGrounding(fields)\n  const claimDraft = buildClaimDraft(fields, claim, extraction)\n  const now = new Date().toISOString()\n  const claimId = `CLM-${ingestedClaimId}`\n\n  const ev = extraction.evidence\n  const docs = extraction.documents\n\n  return {\n    claimId,\n    ingestedClaimId,\n    sourceEmailFrom: claim.from,\n    decisionPack: {\n      id: `DP-${Date.now()}`,\n      claimDraft,\n      evidence: extraction.evidence,\n      documents: extraction.documents.map((d) => ({ ...d, metadata: {} })) as Document[],\n      policyGrounding,\n      audit: [\n        {\n          step: 'Information Extraction',\n          timestamp: now,\n          duration: 0,\n          agent: 'Extraction',\n          status: 'completed' as const,\n          success: true,\n          details: {\n            documentsProcessed: extraction.documents.length,\n            errors: extraction.errors,\n          },\n        },\n        {\n          step: 'Policy Grounding: Querying policy clause database',\n          timestamp: now,\n          duration: 0,\n          agent: 'PolicyRAG',\n          status: 'completed' as const,\n          success: true,\n          details: {\n            clausesFound: policyGrounding.length,\n            coverageConfirmed: !!fields.policyNumber && policyGrounding.length > 0,\n          },\n        },\n        {\n          step: 'Assembling Decision Pack',\n          timestamp: now,\n          duration: 0,\n          agent: 'Assembler',\n          status: 'completed' as const,\n          success: true,\n          details: {\n            evidenceCount: ev.length,\n            documentCount: docs.length,\n          },\n        },\n      ],\n      evidenceSummary: {\n        totalFields: 8,\n        highConfidenceFields: ev.filter((e: { confidence: number }) => e.confidence >= CONFIDENCE.THRESHOLD_HIGH).length,\n        lowConfidenceFields: ev.filter((e: { confidence: number }) => e.confidence < CONFIDENCE.THRESHOLD_MEDIUM).length,\n        avgConfidence: ev.length > 0 ? ev.reduce((s: number, e: { confidence: number }) => s + e.confidence, 0) / ev.length : 0,\n      },\n      documentAnalysis: {\n        totalDocuments: docs.length,\n        documentTypes: docs.map((d: { type: string }) => d.type),\n        avgDocumentConfidence:\n          docs.length > 0 ? docs.reduce((s: number, d: { confidence: number }) => s + d.confidence, 0) / docs.length : 0,\n        missingDocuments: [],\n      },\n      policyAssessment: {\n        clausesFound: policyGrounding.length,\n        coverageConfirmed: !!fields.policyNumber && policyGrounding.length > 0,\n        topSimilarityScore: (policyGrounding[0]?.score ?? policyGrounding[0]?.similarity ?? 0) as number,\n        recommendedActions:\n          policyGrounding.length > 0\n            ? ['Proceed with claim – policy clauses matched']\n            : ['Manual review – no matching policy clauses found'],\n      },\n      processingSummary: {\n        totalTime: 0,\n        stepsCompleted: 4,\n        stepsWithErrors: extraction.errors.length,\n        automationLevel: 0.9,\n      },\n      createdAt: now,\n    },\n    auditTrail: [\n      {\n        step: 'process_claim',\n        timestamp: now,\n        duration: 0,\n        agent: 'ProcessClaimAPI',\n        status: 'completed' as const,\n        details: { openaiIntegration: 'active', model: 'gpt-4o' },\n      },\n    ],\n    processingMetrics: {\n      totalProcessingTime: 0,\n      averageHandleTime: 0,\n      fieldsAutoPopulated: extraction.evidence.length,\n      overrideRate: 0.1,\n      ragHitRate: 1.0,\n      stepsCompleted: 4,\n      stepsFailed: extraction.errors.length,\n      successRate: extraction.errors.length === 0 ? 1.0 : 0.9,\n    },\n    createdAt: now,\n    status: 'draft',\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;CAKC,GAED;AACA;;;AAKA,SAAS,UAAU,KAAoB;IACrC,IAAI,CAAC,OAAO,OAAO;IACnB,MAAM,CAAC,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC;IACnC,OAAO,GAAG,KAAK,KAAK,CAAC,GAAG,GAAG,IAAI,EAAE,QAAQ;AAC3C;AAEA,SAAS,UAAU,KAAoB;IACrC,IAAI,CAAC,OAAO,OAAO;IACnB,OAAO,MAAM,OAAO,CAAC,gBAAgB;AACvC;AAEA,6CAA6C,GAC7C,SAAS,gBACP,MAA+B,EAC/B,KAAoB,EACpB,UAA4B;IAE5B,MAAM,MAAM,IAAI,OAAO,WAAW;IAClC,OAAO;QACL,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI;QACzB,cAAc,AAAC,OAAO,YAAY,GAC9B,CAAC,GAAG,EAAE,OAAO,OAAO,YAAY,EAAE,KAAK,CAAC,CAAC,IAAI,GAC7C;QACJ,cAAc,AAAC,OAAO,YAAY,IAAe;QACjD,cAAc,UAAU,AAAC,OAAO,YAAY,IAAe;QAC3D,cAAc,UAAU,AAAC,OAAO,YAAY,IAAe;QAC3D,UAAU,AAAC,OAAO,QAAQ,IAAe,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE;QAC1D,UAAW,AAAC,OAAO,QAAQ,IAAe;QAC1C,cAAc,AAAC,OAAO,YAAY,IAAe;QACjD,aAAa,AAAC,OAAO,WAAW,IAAe;QAC/C,iBAAiB,AAAC,OAAO,eAAe,IAAgB,OAAO,eAAe,IAAe;QAC7F,aAAa,OAAO,WAAW;QAC/B,iBAAiB,OAAO,eAAe;QACvC,aAAa,MAAM,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;gBAC5C,IAAI,CAAC,IAAI,EAAE,GAAG;gBACd,MAAM,EAAE,IAAI;gBACZ,MAAM,WAAW,SAAS,CAAC,EAAE,EAAE,QAAQ;gBACvC,UAAU,EAAE,QAAQ;gBACpB,YAAY,WAAW,SAAS,CAAC,EAAE,EAAE,cAAc;YACrD,CAAC;QACD,eAAe,CAAC,CAAC,OAAO,YAAY;QACpC,YAAY,OAAO,YAAY,GAAG,MAAM;QACxC,WAAW;QACX,QAAQ;QACR,YACE,WAAW,QAAQ,CAAC,MAAM,GAAG,IACzB,WAAW,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,EAAE,UAAU,EAAE,KAAK,WAAW,QAAQ,CAAC,MAAM,GACtF;IACR;AACF;AAGO,SAAS,kBACd,eAAuB,EACvB,KAAoB,EACpB,UAA4B;IAE5B,MAAM,SAAS,WAAW,eAAe,IAAI,CAAC;IAC9C,MAAM,kBAAkB,IAAA,oLAAkB,EAAC;IAC3C,MAAM,aAAa,gBAAgB,QAAQ,OAAO;IAClD,MAAM,MAAM,IAAI,OAAO,WAAW;IAClC,MAAM,UAAU,CAAC,IAAI,EAAE,iBAAiB;IAExC,MAAM,KAAK,WAAW,QAAQ;IAC9B,MAAM,OAAO,WAAW,SAAS;IAEjC,OAAO;QACL;QACA;QACA,iBAAiB,MAAM,IAAI;QAC3B,cAAc;YACZ,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,IAAI;YACtB;YACA,UAAU,WAAW,QAAQ;YAC7B,WAAW,WAAW,SAAS,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;oBAAE,GAAG,CAAC;oBAAE,UAAU,CAAC;gBAAE,CAAC;YAClE;YACA,OAAO;gBACL;oBACE,MAAM;oBACN,WAAW;oBACX,UAAU;oBACV,OAAO;oBACP,QAAQ;oBACR,SAAS;oBACT,SAAS;wBACP,oBAAoB,WAAW,SAAS,CAAC,MAAM;wBAC/C,QAAQ,WAAW,MAAM;oBAC3B;gBACF;gBACA;oBACE,MAAM;oBACN,WAAW;oBACX,UAAU;oBACV,OAAO;oBACP,QAAQ;oBACR,SAAS;oBACT,SAAS;wBACP,cAAc,gBAAgB,MAAM;wBACpC,mBAAmB,CAAC,CAAC,OAAO,YAAY,IAAI,gBAAgB,MAAM,GAAG;oBACvE;gBACF;gBACA;oBACE,MAAM;oBACN,WAAW;oBACX,UAAU;oBACV,OAAO;oBACP,QAAQ;oBACR,SAAS;oBACT,SAAS;wBACP,eAAe,GAAG,MAAM;wBACxB,eAAe,KAAK,MAAM;oBAC5B;gBACF;aACD;YACD,iBAAiB;gBACf,aAAa;gBACb,sBAAsB,GAAG,MAAM,CAAC,CAAC,IAA8B,EAAE,UAAU,IAAI,yKAAU,CAAC,cAAc,EAAE,MAAM;gBAChH,qBAAqB,GAAG,MAAM,CAAC,CAAC,IAA8B,EAAE,UAAU,GAAG,yKAAU,CAAC,gBAAgB,EAAE,MAAM;gBAChH,eAAe,GAAG,MAAM,GAAG,IAAI,GAAG,MAAM,CAAC,CAAC,GAAW,IAA8B,IAAI,EAAE,UAAU,EAAE,KAAK,GAAG,MAAM,GAAG;YACxH;YACA,kBAAkB;gBAChB,gBAAgB,KAAK,MAAM;gBAC3B,eAAe,KAAK,GAAG,CAAC,CAAC,IAAwB,EAAE,IAAI;gBACvD,uBACE,KAAK,MAAM,GAAG,IAAI,KAAK,MAAM,CAAC,CAAC,GAAW,IAA8B,IAAI,EAAE,UAAU,EAAE,KAAK,KAAK,MAAM,GAAG;gBAC/G,kBAAkB,EAAE;YACtB;YACA,kBAAkB;gBAChB,cAAc,gBAAgB,MAAM;gBACpC,mBAAmB,CAAC,CAAC,OAAO,YAAY,IAAI,gBAAgB,MAAM,GAAG;gBACrE,oBAAqB,eAAe,CAAC,EAAE,EAAE,SAAS,eAAe,CAAC,EAAE,EAAE,cAAc;gBACpF,oBACE,gBAAgB,MAAM,GAAG,IACrB;oBAAC;iBAA8C,GAC/C;oBAAC;iBAAmD;YAC5D;YACA,mBAAmB;gBACjB,WAAW;gBACX,gBAAgB;gBAChB,iBAAiB,WAAW,MAAM,CAAC,MAAM;gBACzC,iBAAiB;YACnB;YACA,WAAW;QACb;QACA,YAAY;YACV;gBACE,MAAM;gBACN,WAAW;gBACX,UAAU;gBACV,OAAO;gBACP,QAAQ;gBACR,SAAS;oBAAE,mBAAmB;oBAAU,OAAO;gBAAS;YAC1D;SACD;QACD,mBAAmB;YACjB,qBAAqB;YACrB,mBAAmB;YACnB,qBAAqB,WAAW,QAAQ,CAAC,MAAM;YAC/C,cAAc;YACd,YAAY;YACZ,gBAAgB;YAChB,aAAa,WAAW,MAAM,CAAC,MAAM;YACrC,aAAa,WAAW,MAAM,CAAC,MAAM,KAAK,IAAI,MAAM;QACtD;QACA,WAAW;QACX,QAAQ;IACV;AACF"}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/services/dashboard/index.ts"],"sourcesContent":["/**\n * Dashboard Microservice\n *\n * Delegates to Python (dashboard.py) for processed claims history:\n * save, list, retrieve by ID, export CSV.\n */\n\nimport { spawn } from 'child_process'\nimport path from 'path'\nimport type { ClaimData } from '@/types/claims'\nimport type { ProcessedClaimSummary } from './types'\n\nconst SCRIPT_PATH = path.join(process.cwd(), 'services', 'dashboard', 'dashboard.py')\nconst PY_CMD = process.platform === 'win32' ? 'python' : 'python3'\n\nasync function runPython(args: string[], stdin?: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const proc = spawn(PY_CMD, [SCRIPT_PATH, ...args], {\n      cwd: process.cwd(),\n      env: { ...process.env },\n      stdio: stdin !== undefined ? ['pipe', 'pipe', 'pipe'] : ['ignore', 'pipe', 'pipe'],\n    })\n\n    let stdout = ''\n    let stderr = ''\n\n    proc.stdout?.on('data', (d) => { stdout += d.toString() })\n    proc.stderr?.on('data', (d) => { stderr += d.toString() })\n\n    if (stdin !== undefined && proc.stdin) {\n      proc.stdin.write(stdin, 'utf-8')\n      proc.stdin.end()\n    }\n\n    proc.on('close', (code) => {\n      if (code !== 0) {\n        reject(new Error(stderr || stdout || `Python exited with code ${code}`))\n      } else {\n        resolve(stdout)\n      }\n    })\n\n    proc.on('error', (err) => reject(err))\n  })\n}\n\n/** Save a processed claim to history and CSV */\nexport async function saveProcessedClaim(claim: ClaimData): Promise<void> {\n  const input = JSON.stringify(claim)\n  const out = await runPython(['save'], input)\n  const parsed = JSON.parse(out.trim())\n  if (parsed.error) {\n    throw new Error(parsed.error)\n  }\n}\n\n/** Get list of processed claim summaries for dropdown */\nexport async function getProcessedClaimSummaries(): Promise<ProcessedClaimSummary[]> {\n  const out = await runPython(['list'])\n  return JSON.parse(out.trim())\n}\n\n/** Get full claim data by ID */\nexport async function getProcessedClaimById(claimId: string): Promise<ClaimData | null> {\n  const out = await runPython(['get', claimId])\n  const trimmed = out.trim()\n  if (trimmed === 'null') return null\n  return JSON.parse(trimmed) as ClaimData\n}\n\n/** Get CSV content for export */\nexport async function getCsvContent(): Promise<string> {\n  return runPython(['csv'])\n}\n\n/** Get real-time dashboard KPIs from processed claims */\nexport async function getDashboardKpis(): Promise<{\n  totalClaims: number\n  claimsThisWeek: number\n  claimsThisMonth: number\n  claimsByLossType: Record<string, number>\n  coverageMatchRate: number\n  avgConfidence: number\n  totalDocumentsProcessed: number\n  claimsByDate: Array<{ date: string; count: number }>\n  recentClaims: Array<{\n    claimId: string\n    policyNumber?: string\n    claimantName?: string\n    lossType: string\n    createdAt: string\n    policyMatches: number\n  }>\n}> {\n  const out = await runPython(['stats'])\n  return JSON.parse(out.trim())\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;;;CAKC,GAED;AACA;;;AAIA,MAAM,cAAc,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI,YAAY,aAAa;AACtE,MAAM,SAAS,sCAA+B,0BAAW;AAEzD,eAAe,UAAU,IAAc,EAAE,KAAc;IACrD,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,MAAM,OAAO,IAAA,4HAAK,EAAC,QAAQ;YAAC;eAAgB;SAAK,EAAE;YACjD,KAAK,QAAQ,GAAG;YAChB,KAAK;gBAAE,GAAG,QAAQ,GAAG;YAAC;YACtB,OAAO,UAAU,YAAY;gBAAC;gBAAQ;gBAAQ;aAAO,GAAG;gBAAC;gBAAU;gBAAQ;aAAO;QACpF;QAEA,IAAI,SAAS;QACb,IAAI,SAAS;QAEb,KAAK,MAAM,EAAE,GAAG,QAAQ,CAAC;YAAQ,UAAU,EAAE,QAAQ;QAAG;QACxD,KAAK,MAAM,EAAE,GAAG,QAAQ,CAAC;YAAQ,UAAU,EAAE,QAAQ;QAAG;QAExD,IAAI,UAAU,aAAa,KAAK,KAAK,EAAE;YACrC,KAAK,KAAK,CAAC,KAAK,CAAC,OAAO;YACxB,KAAK,KAAK,CAAC,GAAG;QAChB;QAEA,KAAK,EAAE,CAAC,SAAS,CAAC;YAChB,IAAI,SAAS,GAAG;gBACd,OAAO,IAAI,MAAM,UAAU,UAAU,CAAC,wBAAwB,EAAE,MAAM;YACxE,OAAO;gBACL,QAAQ;YACV;QACF;QAEA,KAAK,EAAE,CAAC,SAAS,CAAC,MAAQ,OAAO;IACnC;AACF;AAGO,eAAe,mBAAmB,KAAgB;IACvD,MAAM,QAAQ,KAAK,SAAS,CAAC;IAC7B,MAAM,MAAM,MAAM,UAAU;QAAC;KAAO,EAAE;IACtC,MAAM,SAAS,KAAK,KAAK,CAAC,IAAI,IAAI;IAClC,IAAI,OAAO,KAAK,EAAE;QAChB,MAAM,IAAI,MAAM,OAAO,KAAK;IAC9B;AACF;AAGO,eAAe;IACpB,MAAM,MAAM,MAAM,UAAU;QAAC;KAAO;IACpC,OAAO,KAAK,KAAK,CAAC,IAAI,IAAI;AAC5B;AAGO,eAAe,sBAAsB,OAAe;IACzD,MAAM,MAAM,MAAM,UAAU;QAAC;QAAO;KAAQ;IAC5C,MAAM,UAAU,IAAI,IAAI;IACxB,IAAI,YAAY,QAAQ,OAAO;IAC/B,OAAO,KAAK,KAAK,CAAC;AACpB;AAGO,eAAe;IACpB,OAAO,UAAU;QAAC;KAAM;AAC1B;AAGO,eAAe;IAkBpB,MAAM,MAAM,MAAM,UAAU;QAAC;KAAQ;IACrC,OAAO,KAAK,KAAK,CAAC,IAAI,IAAI;AAC5B"}},
    {"offset": {"line": 1064, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/app/api/process-claim/route.ts"],"sourcesContent":["/**\n * POST /api/process-claim\n * Orchestrates Extraction + Decision microservices.\n * Runs information_extraction.py, builds decision pack, saves to dashboard.\n */\nimport { NextRequest, NextResponse } from 'next/server'\nimport { runExtraction } from '@/services/extraction'\nimport { buildDecisionPack } from '@/services/decision'\nimport { getIngestedClaimById } from '@/services/ingested-claims'\nimport { saveProcessedClaim } from '@/services/dashboard'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { ingestedClaimId } = body\n\n    if (!ingestedClaimId) {\n      return NextResponse.json(\n        { error: 'ingestedClaimId is required' },\n        { status: 400 }\n      )\n    }\n\n    const claim = getIngestedClaimById(ingestedClaimId)\n    if (!claim) {\n      return NextResponse.json({ error: 'Claim not found' }, { status: 404 })\n    }\n\n    const extraction = await runExtraction(ingestedClaimId)\n    const claimData = buildDecisionPack(ingestedClaimId, claim, extraction)\n\n    await saveProcessedClaim(claimData as import('@/types/claims').ClaimData)\n    return NextResponse.json(claimData)\n  } catch (error) {\n    console.error('Process claim error:', error)\n    return NextResponse.json(\n      { error: 'Claim processing failed', details: String(error) },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;CAIC,GACD;AACA;AACA;AACA;AACA;;;;;;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,eAAe,EAAE,GAAG;QAE5B,IAAI,CAAC,iBAAiB;YACpB,OAAO,wLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,QAAQ,IAAA,yMAAoB,EAAC;QACnC,IAAI,CAAC,OAAO;YACV,OAAO,wLAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAkB,GAAG;gBAAE,QAAQ;YAAI;QACvE;QAEA,MAAM,aAAa,MAAM,IAAA,0LAAa,EAAC;QACvC,MAAM,YAAY,IAAA,4LAAiB,EAAC,iBAAiB,OAAO;QAE5D,MAAM,IAAA,8LAAkB,EAAC;QACzB,OAAO,wLAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,wLAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAA2B,SAAS,OAAO;QAAO,GAC3D;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}