{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/ingestedClaims.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nconst DATA_DIR = path.join(process.cwd(), 'data')\nconst INGESTED_DIR = path.join(DATA_DIR, 'ingested-attachments')\nconst CLAIMS_FILE = path.join(DATA_DIR, 'ingested-claims.json')\n\nexport interface IngestedAttachment {\n  name: string\n  path: string\n  size: number\n  mimeType: string\n}\n\nexport interface IngestedClaim {\n  id: string\n  policyNumber: string\n  from: string\n  to: string\n  subject: string\n  emailBody: string\n  attachments: IngestedAttachment[]\n  createdAt: string\n  source: 'sendgrid' | 'demo' | 'imap'\n  messageId?: string\n}\n\nfunction ensureDataDir() {\n  if (!fs.existsSync(DATA_DIR)) {\n    fs.mkdirSync(DATA_DIR, { recursive: true })\n  }\n  if (!fs.existsSync(INGESTED_DIR)) {\n    fs.mkdirSync(INGESTED_DIR, { recursive: true })\n  }\n}\n\nfunction getClaimsData(): IngestedClaim[] {\n  ensureDataDir()\n  if (!fs.existsSync(CLAIMS_FILE)) {\n    return []\n  }\n  try {\n    const content = fs.readFileSync(CLAIMS_FILE, 'utf-8')\n    return JSON.parse(content)\n  } catch {\n    return []\n  }\n}\n\nfunction saveClaimsData(claims: IngestedClaim[]) {\n  ensureDataDir()\n  fs.writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8')\n}\n\n/** Extract policy number from email body using common patterns */\nexport function extractPolicyNumber(emailBody: string): string | null {\n  const patterns = [\n    /policy\\s*#?\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /policy\\s*number\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /Policy\\s*#([A-Z0-9]+)/i,\n    /#([A-Z]{2}\\d{6,})/,\n    /\\b([A-Z]{2}\\d{6,})\\b/,\n  ]\n  for (const pattern of patterns) {\n    const match = emailBody.match(pattern)\n    if (match && match[1]) {\n      return match[1]\n    }\n  }\n  return null\n}\n\n/** Get existing message IDs / dedup keys for avoiding re-ingestion */\nexport function getExistingMessageIds(): Set<string> {\n  const claims = getClaimsData()\n  const ids = new Set<string>()\n  for (const c of claims) {\n    if (c.messageId) ids.add(c.messageId)\n    else ids.add(`${c.subject}|${c.from}`)\n  }\n  return ids\n}\n\n/** Create fallback display ID when policy number not found (uses message-id or claim id) */\nfunction fallbackPolicyDisplay(messageId: string | undefined, claimId: string): string {\n  if (messageId && messageId.includes('<') && messageId.includes('@')) {\n    const match = messageId.match(/<([^>]+)>/)\n    const inner = match ? match[1] : messageId\n    const local = inner.includes('@') ? inner.split('@')[0] : inner\n    const short = local.replace(/[^A-Za-z0-9]/g, '').slice(0, 10) || inner.slice(0, 8)\n    return short ? `MAIL-${short}` : claimId\n  }\n  return claimId\n}\n\n/** Save an ingested claim (from SendGrid, IMAP, or other source) */\nexport function saveIngestedClaim(\n  from: string,\n  to: string,\n  subject: string,\n  emailBody: string,\n  attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }>,\n  source: 'sendgrid' | 'imap' = 'sendgrid',\n  messageId?: string\n): IngestedClaim {\n  const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  const extracted = extractPolicyNumber(emailBody) || extractPolicyNumber(subject)\n  const policyNumber = extracted ?? fallbackPolicyDisplay(messageId, claimId)\n\n  ensureDataDir()\n  const claimDir = path.join(INGESTED_DIR, claimId)\n  fs.mkdirSync(claimDir, { recursive: true })\n\n  const attachments: IngestedAttachment[] = []\n  for (const file of attachmentFiles) {\n    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')\n    const filePath = path.join(claimDir, safeName)\n    fs.writeFileSync(filePath, file.buffer)\n    attachments.push({\n      name: file.name,\n      path: filePath,\n      size: file.buffer.length,\n      mimeType: file.mimeType || 'application/octet-stream',\n    })\n  }\n\n  const claim: IngestedClaim = {\n    id: claimId,\n    policyNumber,\n    from,\n    to,\n    subject,\n    emailBody,\n    attachments,\n    createdAt: new Date().toISOString(),\n    source,\n  }\n  if (messageId) claim.messageId = messageId\n\n  const claims = getClaimsData()\n  claims.unshift(claim)\n  saveClaimsData(claims)\n  return claim\n}\n\n/** Get all ingested claims (for dropdown). Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getAllIngestedClaims(): IngestedClaim[] {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  if (hasRealClaims) {\n    return claims.filter((c) => c.source !== 'demo')\n  }\n  return claims\n}\n\n/** Get a single claim by ID */\nexport function getIngestedClaimById(id: string): IngestedClaim | null {\n  const claims = getClaimsData()\n  return claims.find((c) => c.id === id) || null\n}\n\n/** Get distinct policy numbers for dropdown. Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getPolicyNumbers(): Array<{ id: string; policyNumber: string; subject: string }> {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  const toShow = hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n  return toShow.map((c) => ({\n    id: c.id,\n    policyNumber: c.policyNumber,\n    subject: c.subject,\n  }))\n}\n\n/** Seed demo claims from scenarios folder when no claims exist */\nfunction seedDemoClaims() {\n  const scenariosDir = path.join(process.cwd(), 'demo-data', 'scenarios')\n  if (!fs.existsSync(scenariosDir)) return\n\n  const scenarios = [\n    { folder: 'auto-collision', policyNumber: 'AC789456123', from: 'sarah.johnson@email.com', to: 'pranay.nath@aimill.in', subject: 'Car Accident Claim - Policy #AC789456123' },\n    { folder: 'commercial-liability', policyNumber: 'CL789012345', from: 'antonio.martinez@tonysrestaurant.com', to: 'pranay.nath@aimill.in', subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345' },\n    { folder: 'property-water-damage', policyNumber: 'HO456789234', from: 'robert.chen@email.com', to: 'pranay.nath@aimill.in', subject: 'Urgent - Water Damage Claim - Policy #HO456789234' },\n  ]\n\n  const claims: IngestedClaim[] = []\n  const baseTime = Date.now() - 86400000 * 2\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const s = scenarios[i]\n    const emailPath = path.join(scenariosDir, s.folder, 'email.txt')\n    const attachmentsDir = path.join(scenariosDir, s.folder, 'attachments')\n    if (!fs.existsSync(emailPath)) continue\n\n    const emailBody = fs.readFileSync(emailPath, 'utf-8')\n    const claimId = `DEMO-${s.policyNumber}-${i}`\n    const claimDir = path.join(INGESTED_DIR, claimId)\n    fs.mkdirSync(claimDir, { recursive: true })\n\n    const attachments: IngestedAttachment[] = []\n    if (fs.existsSync(attachmentsDir)) {\n      for (const file of fs.readdirSync(attachmentsDir)) {\n        const srcPath = path.join(attachmentsDir, file)\n        if (fs.statSync(srcPath).isFile()) {\n          const destPath = path.join(claimDir, file)\n          fs.copyFileSync(srcPath, destPath)\n          attachments.push({ name: file, path: destPath, size: fs.statSync(destPath).size, mimeType: 'text/plain' })\n        }\n      }\n    }\n\n    claims.push({\n      id: claimId,\n      policyNumber: s.policyNumber,\n      from: s.from,\n      to: s.to,\n      subject: s.subject,\n      emailBody,\n      attachments,\n      createdAt: new Date(baseTime + i * 3600000).toISOString(),\n      source: 'demo',\n    })\n  }\n\n  if (claims.length > 0) {\n    saveClaimsData(claims)\n  }\n}\n\n/** Clear all ingested claims and attachments (for fresh start) */\nexport function clearAllIngestedClaims(): void {\n  ensureDataDir()\n  if (fs.existsSync(CLAIMS_FILE)) fs.unlinkSync(CLAIMS_FILE)\n  if (fs.existsSync(INGESTED_DIR)) {\n    for (const entry of fs.readdirSync(INGESTED_DIR, { withFileTypes: true })) {\n      const fullPath = path.join(INGESTED_DIR, entry.name)\n      if (entry.isDirectory()) {\n        fs.rmSync(fullPath, { recursive: true })\n      }\n    }\n  }\n}\n\n/** Read attachment file content for processing (text files) */\nexport function readAttachmentContent(claimId: string, attachmentName: string): string {\n  const claim = getIngestedClaimById(claimId)\n  if (!claim) throw new Error('Claim not found')\n  const att = claim.attachments.find((a) => a.name === attachmentName)\n  if (!att || !fs.existsSync(att.path)) throw new Error('Attachment not found')\n  const ext = path.extname(att.name).toLowerCase()\n  if (['.txt', '.csv', '.log'].includes(ext)) {\n    return fs.readFileSync(att.path, 'utf-8')\n  }\n  return `[Document: ${att.name} - content extracted for processing]`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/fnolClassifier.ts"],"sourcesContent":["/**\n * FNOL (First Notice of Loss) Classifier\n *\n * Classifies emails as FNOL-related before ingestion.\n * Uses subject + body to decide if the email should be ingested.\n * Only FNOL-related content is kept; others are skipped.\n */\n\nconst FNOL_KEYWORDS = [\n  'fnol',\n  'first notice of loss',\n  'first notice',\n  'claim',\n  'claim number',\n  'policy number',\n  'policy #',\n  'accident',\n  'damage',\n  'leakage',\n  'leak',\n  'water damage',\n  'collision',\n  'incident report',\n  'loss report',\n  'insurance claim',\n  'filing a claim',\n  'reporting a claim',\n  'bodily injury',\n  'property damage',\n  'theft',\n  'fire damage',\n  'storm damage',\n  'roof damage',\n  'vehicle damage',\n  'repair estimate',\n  'police report',\n]\n\nconst FNOL_FILTER_ENABLED = process.env.FNOL_FILTER_ENABLED !== 'false'\nconst FNOL_USE_LLM_CLASSIFIER = process.env.FNOL_USE_LLM_CLASSIFIER === 'true'\n\n/**\n * Keyword-based classification: returns true if subject or body contains FNOL-related terms.\n */\nfunction classifyByKeywords(subject: string, body: string): boolean {\n  if (!FNOL_FILTER_ENABLED) return true\n  const combined = `${subject} ${body}`.toLowerCase()\n  return FNOL_KEYWORDS.some((kw) => combined.includes(kw))\n}\n\n/**\n * LLM-based classification for nuanced FNOL detection.\n * Uses OpenAI when FNOL_USE_LLM_CLASSIFIER=true and OPENAI_API_KEY is set.\n */\nasync function classifyByLLM(subject: string, body: string): Promise<boolean> {\n  const apiKey = process.env.OPENAI_API_KEY\n  if (!apiKey) return classifyByKeywords(subject, body)\n\n  try {\n    const OpenAI = (await import('openai')).default\n    const openai = new OpenAI({ apiKey })\n    const model = process.env.OPENAI_MODEL || 'gpt-4o-mini'\n    const text = `Subject: ${subject}\\n\\nBody:\\n${body.slice(0, 2000)}`\n\n    const response = await openai.chat.completions.create({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: `You are an FNOL classifier. Determine if this email is a First Notice of Loss (FNOL) or insurance claim submission.\nFNOL = insured person notifying insurer of a loss/incident (accident, damage, theft, water damage, etc.) to file a claim.\nReply with ONLY \"yes\" or \"no\".`,\n        },\n        {\n          role: 'user',\n          content: `Is this email an FNOL or insurance claim submission?\\n\\n${text}`,\n        },\n      ],\n      max_tokens: 10,\n      temperature: 0,\n    })\n\n    const answer = (response.choices[0]?.message?.content || '').trim().toLowerCase()\n    return answer.startsWith('yes')\n  } catch {\n    return classifyByKeywords(subject, body)\n  }\n}\n\n/**\n * Classify email as FNOL-related. Only returns true for emails that should be ingested.\n * Runs before ingestion - non-FNOL emails are skipped.\n *\n * @param subject - Email subject\n * @param body - Email body (plain text)\n * @returns true if email is FNOL-related and should be ingested\n */\nexport async function isFnolEmail(subject: string, body: string): Promise<boolean> {\n  if (!FNOL_FILTER_ENABLED) return true\n\n  if (FNOL_USE_LLM_CLASSIFIER) {\n    return classifyByLLM(subject, body)\n  }\n\n  return classifyByKeywords(subject, body)\n}\n\n/**\n * Synchronous keyword-only check (for use when async is not needed).\n */\nexport function isFnolEmailSync(subject: string, body: string): boolean {\n  return classifyByKeywords(subject, body)\n}\n"],"names":[],"mappings":";;;;;;AAAA;;;;;;CAMC,GAED,MAAM,gBAAgB;IACpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,sBAAsB,QAAQ,GAAG,CAAC,mBAAmB,KAAK;AAChE,MAAM,0BAA0B,QAAQ,GAAG,CAAC,uBAAuB,KAAK;AAExE;;CAEC,GACD,SAAS,mBAAmB,OAAe,EAAE,IAAY;IACvD,IAAI,CAAC,qBAAqB,OAAO;IACjC,MAAM,WAAW,GAAG,QAAQ,CAAC,EAAE,MAAM,CAAC,WAAW;IACjD,OAAO,cAAc,IAAI,CAAC,CAAC,KAAO,SAAS,QAAQ,CAAC;AACtD;AAEA;;;CAGC,GACD,eAAe,cAAc,OAAe,EAAE,IAAY;IACxD,MAAM,SAAS,QAAQ,GAAG,CAAC,cAAc;IACzC,IAAI,CAAC,QAAQ,OAAO,mBAAmB,SAAS;IAEhD,IAAI;QACF,MAAM,SAAS,CAAC,8IAAsB,EAAE,OAAO;QAC/C,MAAM,SAAS,IAAI,OAAO;YAAE;QAAO;QACnC,MAAM,QAAQ,QAAQ,GAAG,CAAC,YAAY,IAAI;QAC1C,MAAM,OAAO,CAAC,SAAS,EAAE,QAAQ,WAAW,EAAE,KAAK,KAAK,CAAC,GAAG,OAAO;QAEnE,MAAM,WAAW,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YACpD;YACA,UAAU;gBACR;oBACE,MAAM;oBACN,SAAS,CAAC;;8BAEU,CAAC;gBACvB;gBACA;oBACE,MAAM;oBACN,SAAS,CAAC,wDAAwD,EAAE,MAAM;gBAC5E;aACD;YACD,YAAY;YACZ,aAAa;QACf;QAEA,MAAM,SAAS,CAAC,SAAS,OAAO,CAAC,EAAE,EAAE,SAAS,WAAW,EAAE,EAAE,IAAI,GAAG,WAAW;QAC/E,OAAO,OAAO,UAAU,CAAC;IAC3B,EAAE,OAAM;QACN,OAAO,mBAAmB,SAAS;IACrC;AACF;AAUO,eAAe,YAAY,OAAe,EAAE,IAAY;IAC7D,IAAI,CAAC,qBAAqB,OAAO;IAEjC,IAAI,yBAAyB;QAC3B,OAAO,cAAc,SAAS;IAChC;IAEA,OAAO,mBAAmB,SAAS;AACrC;AAKO,SAAS,gBAAgB,OAAe,EAAE,IAAY;IAC3D,OAAO,mBAAmB,SAAS;AACrC"}},
    {"offset": {"line": 498, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/imapIngestion.ts"],"sourcesContent":["import { ImapFlow } from 'imapflow'\n// @ts-expect-error - mailparser has no types\nimport { simpleParser } from 'mailparser'\nimport { saveIngestedClaim, getExistingMessageIds } from './ingestedClaims'\nimport { isFnolEmail } from './fnolClassifier'\n\nconst IMAP_HOST = process.env.IMAP_HOST || 'imap.gmail.com'\nconst IMAP_PORT = parseInt(process.env.IMAP_PORT || '993', 10)\nconst IMAP_USER = process.env.SENDER_EMAIL || process.env.IMAP_USER || ''\nconst IMAP_PASSWORD = (process.env.EMAIL_PASSWORD || process.env.IMAP_PASSWORD || '').replace(/\\s/g, '')\nconst IMAP_MAILBOX = process.env.IMAP_MAILBOX || 'INBOX'\nconst INCLUDE_READ = process.env.IMAP_SYNC_INCLUDE_READ !== 'false'\nconst MAX_EMAILS = parseInt(process.env.IMAP_SYNC_MAX_EMAILS || '100', 10)\n\nexport interface SyncResult {\n  success: boolean\n  ingested: number\n  scanned: number\n  skippedNoFnol: number\n  skippedDuplicate?: number\n  errors: string[]\n  hint?: string\n  mailboxUsed?: string\n}\n\nexport async function syncInboxFromIMAP(): Promise<SyncResult> {\n  const result: SyncResult = {\n    success: false,\n    ingested: 0,\n    scanned: 0,\n    skippedNoFnol: 0,\n    skippedDuplicate: 0,\n    errors: [],\n  }\n\n  if (!IMAP_USER || !IMAP_PASSWORD) {\n    result.errors.push('IMAP credentials not configured. Set SENDER_EMAIL and EMAIL_PASSWORD in .env')\n    return result\n  }\n\n  const client = new ImapFlow({\n    host: IMAP_HOST,\n    port: IMAP_PORT,\n    secure: true,\n    auth: {\n      user: IMAP_USER,\n      pass: IMAP_PASSWORD,\n    },\n    logger: false,\n  })\n\n  const mailboxesToTry: string[] = [IMAP_MAILBOX]\n  if (IMAP_HOST.toLowerCase().includes('gmail') && IMAP_MAILBOX.toUpperCase() === 'INBOX') {\n    if (INCLUDE_READ) {\n      mailboxesToTry.unshift('[Gmail]/All Mail', '[Google Mail]/All Mail')\n    } else {\n      mailboxesToTry.push('[Gmail]/All Mail', '[Google Mail]/All Mail')\n    }\n  }\n\n  try {\n    await client.connect()\n\n    let uids: number[] = []\n    let mailboxUsed = ''\n\n    for (const mbox of mailboxesToTry) {\n      try {\n        const lock = await client.getMailboxLock(mbox)\n        try {\n          const searchCriteria = INCLUDE_READ ? { all: true } : { seen: false }\n          const searchResult = await client.search(searchCriteria, { uid: true })\n          let list = Array.isArray(searchResult) ? searchResult : []\n          list = list.slice(-MAX_EMAILS)\n          if (list.length > 0) {\n            uids = list\n            mailboxUsed = mbox\n            break\n          }\n        } finally {\n          lock.release()\n        }\n      } catch {\n        continue\n      }\n    }\n\n    if (uids.length === 0) {\n      result.success = true\n      result.hint =\n        \"Inbox empty. For Gmail: enable 'All Mail' in Settings > Labels > Show in IMAP, or set IMAP_MAILBOX='[Gmail]/All Mail' in .env\"\n      await client.logout()\n      return result\n    }\n\n    result.scanned = uids.length\n    result.mailboxUsed = mailboxUsed\n    const existingIds = getExistingMessageIds()\n    const lock = await client.getMailboxLock(mailboxUsed || IMAP_MAILBOX)\n\n    try {\n      const messages = await client.fetch(\n        uids,\n        { envelope: true, source: true, uid: true },\n        { uid: true }\n      )\n\n      for await (const msg of messages) {\n        try {\n          const rawSource = msg.source\n          if (!rawSource) {\n            result.errors.push(`Message ${msg.uid}: No source data`)\n            continue\n          }\n\n          const rawBuffer = Buffer.isBuffer(rawSource) ? rawSource : Buffer.from(rawSource as Buffer)\n          const parsed = await simpleParser(rawBuffer)\n\n          const subject = parsed.subject || '(No subject)'\n          const from = formatAddress(parsed.from) || ''\n          const to = formatAddress(parsed.to) || ''\n          const messageId = parsed.messageId || ''\n          const dateHeader = parsed.date ? String(parsed.date) : ''\n          const dedupKey = messageId || `${subject}|${from}|${dateHeader}`\n          const fallbackKey = `${subject}|${from}`\n\n          if (existingIds.has(dedupKey) || existingIds.has(fallbackKey)) {\n            result.skippedDuplicate = (result.skippedDuplicate ?? 0) + 1\n            continue\n          }\n\n          const bodyText = parsed.text || (parsed.html ? stripHtml(parsed.html) : '')\n          const isFnol = await isFnolEmail(subject, bodyText)\n          if (!isFnol) {\n            result.skippedNoFnol++\n            continue\n          }\n\n          const dateStr = parsed.date ? formatDate(parsed.date) : ''\n          const emailBody = buildFullEmailBody({ subject, from, to, dateStr, bodyText })\n\n          const attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }> = []\n          if (parsed.attachments?.length) {\n            for (const att of parsed.attachments) {\n              const content = att.content\n              const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content || [])\n              const filename = att.filename || `attachment-${attachmentFiles.length + 1}`\n              const mimeType = att.contentType || 'application/octet-stream'\n              attachmentFiles.push({ name: filename, buffer, mimeType })\n            }\n          }\n\n          saveIngestedClaim(from, to, subject, emailBody, attachmentFiles, 'imap', dedupKey)\n          result.ingested++\n          existingIds.add(dedupKey)\n          existingIds.add(fallbackKey)\n\n          if (!INCLUDE_READ) {\n            await client.messageFlagsAdd(msg.uid, ['\\\\Seen'], { uid: true })\n          }\n        } catch (err) {\n          result.errors.push(\n            `Failed to process message ${msg.uid}: ${err instanceof Error ? err.message : String(err)}`\n          )\n        }\n      }\n\n      result.success = result.errors.length === 0\n    } finally {\n      lock.release()\n    }\n\n    await client.logout()\n  } catch (err) {\n    result.errors.push(err instanceof Error ? err.message : String(err))\n    try {\n      await client.logout()\n    } catch {\n      // ignore\n    }\n  }\n\n  return result\n}\n\nfunction formatAddress(addr: unknown): string {\n  if (!addr) return ''\n  const arr = Array.isArray(addr) ? addr : [addr]\n  return arr\n    .map((a: { text?: string; address?: string; value?: { 0?: { address?: string } } }) =>\n      a?.text || (a as { address?: string })?.address || (a as { value?: { 0?: { address?: string } } })?.value?.[0]?.address\n    )\n    .filter(Boolean)\n    .join(', ')\n}\n\nfunction formatDate(d: Date | string): string {\n  const date = d instanceof Date ? d : new Date(d)\n  if (isNaN(date.getTime())) return ''\n  return date.toLocaleString('en-US', {\n    month: 'long' as const,\n    day: 'numeric',\n    year: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true,\n  })\n}\n\nfunction buildFullEmailBody(opts: {\n  subject: string\n  from: string\n  to: string\n  dateStr: string\n  bodyText: string\n}): string {\n  const lines: string[] = []\n  if (opts.subject) lines.push(`Subject: ${opts.subject}`)\n  if (opts.from) lines.push(`From: ${opts.from}`)\n  if (opts.to) lines.push(`To: ${opts.to}`)\n  if (opts.dateStr) lines.push(`Date: ${opts.dateStr}`)\n  if (lines.length) lines.push('')\n  if (opts.bodyText) lines.push(opts.bodyText.trim())\n  return lines.join('\\n')\n}\n\nfunction stripHtml(html: string): string {\n  return html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim()\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/app/api/sync-inbox/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { syncInboxFromIMAP } from '@/lib/imapIngestion'\n\n/**\n * POST /api/sync-inbox\n * Fetches emails from IMAP (Gmail/Outlook), filters by FNOL keywords, ingests claims.\n * Uses Node.js (imapflow) - no Python required. Works on Vercel, Docker, etc.\n */\nexport async function POST() {\n  try {\n    const result = await syncInboxFromIMAP()\n\n    return NextResponse.json({\n      success: result.success,\n      ingested: result.ingested,\n      scanned: result.scanned,\n      skippedNoFnol: result.skippedNoFnol,\n      skippedDuplicate: result.skippedDuplicate ?? 0,\n      errors: result.errors,\n      hint: result.hint,\n    })\n  } catch (error) {\n    console.error('Sync inbox error:', error)\n    return NextResponse.json(\n      { success: false, ingested: 0, scanned: 0, skippedNoFnol: 0, skippedDuplicate: 0, errors: [String(error)] },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAOO,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,MAAM,IAAA,mLAAiB;QAEtC,OAAO,wLAAY,CAAC,IAAI,CAAC;YACvB,SAAS,OAAO,OAAO;YACvB,UAAU,OAAO,QAAQ;YACzB,SAAS,OAAO,OAAO;YACvB,eAAe,OAAO,aAAa;YACnC,kBAAkB,OAAO,gBAAgB,IAAI;YAC7C,QAAQ,OAAO,MAAM;YACrB,MAAM,OAAO,IAAI;QACnB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,wLAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,UAAU;YAAG,SAAS;YAAG,eAAe;YAAG,kBAAkB;YAAG,QAAQ;gBAAC,OAAO;aAAO;QAAC,GAC1G;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}