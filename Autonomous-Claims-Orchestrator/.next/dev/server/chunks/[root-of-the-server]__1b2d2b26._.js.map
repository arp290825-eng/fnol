{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/lib/ingestedClaims.ts"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nconst DATA_DIR = path.join(process.cwd(), 'data')\nconst INGESTED_DIR = path.join(DATA_DIR, 'ingested-attachments')\nconst CLAIMS_FILE = path.join(DATA_DIR, 'ingested-claims.json')\n\nexport interface IngestedAttachment {\n  name: string\n  path: string\n  size: number\n  mimeType: string\n}\n\nexport interface IngestedClaim {\n  id: string\n  policyNumber: string\n  from: string\n  to: string\n  subject: string\n  emailBody: string\n  attachments: IngestedAttachment[]\n  createdAt: string\n  source: 'sendgrid' | 'demo' | 'imap'\n  messageId?: string\n}\n\nfunction ensureDataDir() {\n  if (!fs.existsSync(DATA_DIR)) {\n    fs.mkdirSync(DATA_DIR, { recursive: true })\n  }\n  if (!fs.existsSync(INGESTED_DIR)) {\n    fs.mkdirSync(INGESTED_DIR, { recursive: true })\n  }\n}\n\nfunction getClaimsData(): IngestedClaim[] {\n  ensureDataDir()\n  if (!fs.existsSync(CLAIMS_FILE)) {\n    return []\n  }\n  try {\n    const content = fs.readFileSync(CLAIMS_FILE, 'utf-8')\n    return JSON.parse(content)\n  } catch {\n    return []\n  }\n}\n\nfunction saveClaimsData(claims: IngestedClaim[]) {\n  ensureDataDir()\n  fs.writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8')\n}\n\n/** Extract policy number from email body using common patterns */\nexport function extractPolicyNumber(emailBody: string): string | null {\n  const patterns = [\n    /policy\\s*#?\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /policy\\s*number\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /Policy\\s*#([A-Z0-9]+)/i,\n    /#([A-Z]{2}\\d{6,})/,\n    /\\b([A-Z]{2}\\d{6,})\\b/,\n  ]\n  for (const pattern of patterns) {\n    const match = emailBody.match(pattern)\n    if (match && match[1]) {\n      return match[1]\n    }\n  }\n  return null\n}\n\nfunction normalizeDedupKey(s: string): string {\n  return s.trim().toLowerCase()\n}\n\nfunction normalizedSubjectFrom(subject: string, from: string): string {\n  return normalizeDedupKey(`${subject}|${from}`)\n}\n\n/** Get existing message IDs / dedup keys for avoiding re-ingestion.\n * Adds both Message-ID (raw + normalized) and subject|from for each claim\n * so duplicates are caught even when Message-ID varies (forward/reply) or is missing.\n */\nexport function getExistingMessageIds(): Set<string> {\n  const claims = getClaimsData()\n  const ids = new Set<string>()\n  for (const c of claims) {\n    ids.add(normalizedSubjectFrom(c.subject, c.from))\n    if (c.messageId) {\n      ids.add(normalizeDedupKey(c.messageId))\n      const inner = c.messageId.replace(/^<|>$/g, '').trim()\n      if (inner) ids.add(normalizeDedupKey(inner))\n    }\n  }\n  return ids\n}\n\n/** Add dedup keys for a newly ingested claim so future syncs can detect duplicates */\nexport function addDedupKeysToSet(\n  ids: Set<string>,\n  subject: string,\n  from: string,\n  messageId: string,\n  dedupKey: string\n): void {\n  ids.add(normalizedSubjectFrom(subject, from))\n  ids.add(normalizeDedupKey(dedupKey))\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner) ids.add(normalizeDedupKey(inner))\n  }\n}\n\n/** Check if email is a duplicate using normalized dedup keys */\nexport function isDuplicateEmail(\n  subject: string,\n  from: string,\n  messageId: string,\n  dateHeader: string,\n  existingIds: Set<string>\n): boolean {\n  const subjectFrom = normalizedSubjectFrom(subject, from)\n  if (existingIds.has(subjectFrom)) return true\n  const dedupKey = messageId\n    ? normalizeDedupKey(messageId)\n    : normalizeDedupKey(`${subject}|${from}|${dateHeader}`)\n  if (existingIds.has(dedupKey)) return true\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner && existingIds.has(normalizeDedupKey(inner))) return true\n  }\n  return false\n}\n\n/** Use email Message-ID as identifier when policy number not found */\nfunction fallbackPolicyDisplay(messageId: string | undefined, claimId: string): string {\n  if (!messageId) return claimId\n  // Message-ID format: <local@domain> - use the email ID itself (strip angle brackets)\n  if (messageId.includes('<') && messageId.includes('@')) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    return inner || claimId\n  }\n  return claimId\n}\n\n/** Save an ingested claim (from SendGrid, IMAP, or other source).\n * messageId: dedup key (stored in claim). emailMessageIdForDisplay: RFC Message-ID for fallback when no policy.\n */\nexport function saveIngestedClaim(\n  from: string,\n  to: string,\n  subject: string,\n  emailBody: string,\n  attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }>,\n  source: 'sendgrid' | 'imap' = 'sendgrid',\n  messageId?: string,\n  emailMessageIdForDisplay?: string\n): IngestedClaim {\n  const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  const extracted = extractPolicyNumber(emailBody) || extractPolicyNumber(subject)\n  const policyNumber = extracted ?? fallbackPolicyDisplay(emailMessageIdForDisplay ?? messageId, claimId)\n\n  ensureDataDir()\n  const claimDir = path.join(INGESTED_DIR, claimId)\n  fs.mkdirSync(claimDir, { recursive: true })\n\n  const attachments: IngestedAttachment[] = []\n  for (const file of attachmentFiles) {\n    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')\n    const filePath = path.join(claimDir, safeName)\n    fs.writeFileSync(filePath, file.buffer)\n    attachments.push({\n      name: file.name,\n      path: filePath,\n      size: file.buffer.length,\n      mimeType: file.mimeType || 'application/octet-stream',\n    })\n  }\n\n  const claim: IngestedClaim = {\n    id: claimId,\n    policyNumber,\n    from,\n    to,\n    subject,\n    emailBody,\n    attachments,\n    createdAt: new Date().toISOString(),\n    source,\n  }\n  if (messageId) claim.messageId = messageId\n\n  const claims = getClaimsData()\n  claims.unshift(claim)\n  saveClaimsData(claims)\n  return claim\n}\n\n/** Get all ingested claims (for dropdown). Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getAllIngestedClaims(): IngestedClaim[] {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  if (hasRealClaims) {\n    return claims.filter((c) => c.source !== 'demo')\n  }\n  return claims\n}\n\n/** Get a single claim by ID */\nexport function getIngestedClaimById(id: string): IngestedClaim | null {\n  const claims = getClaimsData()\n  return claims.find((c) => c.id === id) || null\n}\n\n/** Get distinct policy numbers for dropdown. Excludes demo if any real (imap/sendgrid) claims exist. */\nexport function getPolicyNumbers(): Array<{ id: string; policyNumber: string; subject: string }> {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  const toShow = hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n  return toShow.map((c) => ({\n    id: c.id,\n    policyNumber: c.policyNumber,\n    subject: c.subject,\n  }))\n}\n\n/** Seed demo claims from scenarios folder when no claims exist */\nfunction seedDemoClaims() {\n  const scenariosDir = path.join(process.cwd(), 'demo-data', 'scenarios')\n  if (!fs.existsSync(scenariosDir)) return\n\n  const scenarios = [\n    { folder: 'auto-collision', policyNumber: 'AC789456123', from: 'sarah.johnson@email.com', to: 'pranay.nath@aimill.in', subject: 'Car Accident Claim - Policy #AC789456123' },\n    { folder: 'commercial-liability', policyNumber: 'CL789012345', from: 'antonio.martinez@tonysrestaurant.com', to: 'pranay.nath@aimill.in', subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345' },\n    { folder: 'property-water-damage', policyNumber: 'HO456789234', from: 'robert.chen@email.com', to: 'pranay.nath@aimill.in', subject: 'Urgent - Water Damage Claim - Policy #HO456789234' },\n  ]\n\n  const claims: IngestedClaim[] = []\n  const baseTime = Date.now() - 86400000 * 2\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const s = scenarios[i]\n    const emailPath = path.join(scenariosDir, s.folder, 'email.txt')\n    const attachmentsDir = path.join(scenariosDir, s.folder, 'attachments')\n    if (!fs.existsSync(emailPath)) continue\n\n    const emailBody = fs.readFileSync(emailPath, 'utf-8')\n    const claimId = `DEMO-${s.policyNumber}-${i}`\n    const claimDir = path.join(INGESTED_DIR, claimId)\n    fs.mkdirSync(claimDir, { recursive: true })\n\n    const attachments: IngestedAttachment[] = []\n    if (fs.existsSync(attachmentsDir)) {\n      for (const file of fs.readdirSync(attachmentsDir)) {\n        const srcPath = path.join(attachmentsDir, file)\n        if (fs.statSync(srcPath).isFile()) {\n          const destPath = path.join(claimDir, file)\n          fs.copyFileSync(srcPath, destPath)\n          attachments.push({ name: file, path: destPath, size: fs.statSync(destPath).size, mimeType: 'text/plain' })\n        }\n      }\n    }\n\n    claims.push({\n      id: claimId,\n      policyNumber: s.policyNumber,\n      from: s.from,\n      to: s.to,\n      subject: s.subject,\n      emailBody,\n      attachments,\n      createdAt: new Date(baseTime + i * 3600000).toISOString(),\n      source: 'demo',\n    })\n  }\n\n  if (claims.length > 0) {\n    saveClaimsData(claims)\n  }\n}\n\n/** Clear all ingested claims and attachments (for fresh start) */\nexport function clearAllIngestedClaims(): void {\n  ensureDataDir()\n  if (fs.existsSync(CLAIMS_FILE)) fs.unlinkSync(CLAIMS_FILE)\n  if (fs.existsSync(INGESTED_DIR)) {\n    for (const entry of fs.readdirSync(INGESTED_DIR, { withFileTypes: true })) {\n      const fullPath = path.join(INGESTED_DIR, entry.name)\n      if (entry.isDirectory()) {\n        fs.rmSync(fullPath, { recursive: true })\n      }\n    }\n  }\n}\n\n/** Read attachment file content for processing (text files) */\nexport function readAttachmentContent(claimId: string, attachmentName: string): string {\n  const claim = getIngestedClaimById(claimId)\n  if (!claim) throw new Error('Claim not found')\n  const att = claim.attachments.find((a) => a.name === attachmentName)\n  if (!att || !fs.existsSync(att.path)) throw new Error('Attachment not found')\n  const ext = path.extname(att.name).toLowerCase()\n  if (['.txt', '.csv', '.log'].includes(ext)) {\n    return fs.readFileSync(att.path, 'utf-8')\n  }\n  return `[Document: ${att.name} - content extracted for processing]`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/app/api/process-claim/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { getIngestedClaimById } from '@/lib/ingestedClaims'\nimport { spawn } from 'child_process'\nimport path from 'path'\n\n/**\n * POST /api/process-claim\n * Runs information_extraction.py for LLM-based extraction (email, documents, images with Vision).\n * Returns ClaimData compatible with the app.\n */\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { ingestedClaimId } = body\n\n    if (!ingestedClaimId) {\n      return NextResponse.json(\n        { error: 'ingestedClaimId is required' },\n        { status: 400 }\n      )\n    }\n\n    const claim = getIngestedClaimById(ingestedClaimId)\n    if (!claim) {\n      return NextResponse.json(\n        { error: 'Claim not found' },\n        { status: 404 }\n      )\n    }\n\n    const scriptPath = path.join(process.cwd(), 'information_extraction.py')\n    const pyCmd = process.platform === 'win32' ? 'python' : 'python3'\n\n    const extraction = await new Promise<{\n      extractedFields: Record<string, unknown>\n      documents: Array<{\n        id: string\n        name: string\n        mimeType: string\n        type: string\n        content: string\n        confidence: number\n        keyFields?: Record<string, unknown>\n      }>\n      evidence: Array<{\n        field: string\n        fieldName?: string\n        value: string\n        confidence: number\n        sourceLocator: string\n        rationale: string\n      }>\n      errors: string[]\n    }>((resolve, reject) => {\n      const proc = spawn(pyCmd, [scriptPath, ingestedClaimId], {\n        cwd: process.cwd(),\n        env: { ...process.env },\n      })\n      let stdout = ''\n      let stderr = ''\n      proc.stdout?.on('data', (d) => { stdout += d.toString() })\n      proc.stderr?.on('data', (d) => { stderr += d.toString() })\n      proc.on('close', (code) => {\n        try {\n          const parsed = JSON.parse(stdout.trim())\n          if (parsed.error) {\n            reject(new Error(parsed.error))\n          } else {\n            resolve(parsed)\n          }\n        } catch {\n          reject(new Error(stderr || stdout || `Python exited with code ${code}`))\n        }\n      })\n      proc.on('error', (err) => reject(err))\n    })\n\n    const fields = extraction.extractedFields || {}\n    const maskEmail = (email: string | null) => {\n      if (!email) return 'Not found'\n      const [user, domain] = email.split('@')\n      return `${user.slice(0, 2)}***@${domain}`\n    }\n    const maskPhone = (phone: string | null) => {\n      if (!phone) return 'Not found'\n      return phone.replace(/\\d(?=\\d{4})/g, '*')\n    }\n\n    const now = new Date().toISOString()\n    const claimDraft = {\n      id: `DRAFT-${Date.now()}`,\n      policyNumber: (fields.policyNumber as string)\n        ? `***${String(fields.policyNumber).slice(-3)}`\n        : 'Not found',\n      claimantName: (fields.claimantName as string) || 'Not found',\n      contactEmail: maskEmail((fields.contactEmail as string) ?? null),\n      contactPhone: maskPhone((fields.contactPhone as string) ?? null),\n      lossDate:\n        (fields.lossDate as string) || now.split('T')[0],\n      lossType: (fields.lossType as string) || 'Other',\n      lossLocation: (fields.lossLocation as string) || 'See description',\n      description: (fields.description as string) || 'Claim submitted via email',\n      estimatedAmount: (fields.estimatedAmount as number) ?? (fields.estimatedDamage as number) ?? 0,\n      vehicleInfo: fields.vehicleInfo as Record<string, unknown> | undefined,\n      propertyAddress: fields.propertyAddress as string | undefined,\n      attachments: claim.attachments.map((a, i) => ({\n        id: `doc_${i}`,\n        name: a.name,\n        type: extraction.documents[i]?.type || 'Other',\n        mimeType: a.mimeType,\n        confidence: extraction.documents[i]?.confidence ?? 0.8,\n      })),\n      coverageFound: !!fields.policyNumber,\n      deductible: fields.policyNumber ? 500 : undefined,\n      createdAt: now,\n      source: 'information_extraction',\n      confidence: Object.values(fields).filter((v) => v != null && v !== '').length / 8,\n    }\n\n    const policyGrounding = [\n      {\n        clauseId: 'SEC_003',\n        title: 'Coverage Clause',\n        snippet: 'Relevant coverage based on claim type',\n        score: 0.92,\n        rationale: 'Matched from extracted claim information',\n      },\n    ]\n\n    const claimData = {\n      claimId: `CLM-${Date.now()}`,\n      ingestedClaimId,\n      decisionPack: {\n        id: `DP-${Date.now()}`,\n        claimDraft,\n        evidence: extraction.evidence,\n        documents: extraction.documents.map((d) => ({\n          ...d,\n          metadata: {},\n        })),\n        policyGrounding,\n        audit: [\n          {\n            step: 'information_extraction',\n            timestamp: now,\n            duration: 0,\n            agent: 'InformationExtraction',\n            status: 'completed' as const,\n            details: {\n              documentsProcessed: extraction.documents.length,\n              errors: extraction.errors,\n            },\n          },\n        ],\n        evidenceSummary: {\n          totalFields: 8,\n          highConfidenceFields: extraction.evidence.length,\n          lowConfidenceFields: Math.max(0, 8 - extraction.evidence.length),\n          avgConfidence: 0.85,\n        },\n        documentAnalysis: {\n          totalDocuments: extraction.documents.length,\n          documentTypes: extraction.documents.map((d) => d.type),\n          avgDocumentConfidence: 0.8,\n          missingDocuments: [],\n        },\n        policyAssessment: {\n          clausesFound: 1,\n          coverageConfirmed: !!fields.policyNumber,\n          topSimilarityScore: 0.92,\n          recommendedActions: ['Proceed with claim'],\n        },\n        processingSummary: {\n          totalTime: 0,\n          stepsCompleted: 4,\n          stepsWithErrors: extraction.errors.length,\n          automationLevel: 0.9,\n        },\n        createdAt: now,\n      },\n      auditTrail: [\n        {\n          step: 'process_claim',\n          timestamp: now,\n          duration: 0,\n          agent: 'ProcessClaimAPI',\n          status: 'completed' as const,\n          details: { openaiIntegration: 'active', model: 'gpt-4o' },\n        },\n      ],\n      processingMetrics: {\n        totalProcessingTime: 0,\n        averageHandleTime: 0,\n        fieldsAutoPopulated: extraction.evidence.length,\n        overrideRate: 0.1,\n        ragHitRate: 1.0,\n        stepsCompleted: 4,\n        stepsFailed: extraction.errors.length,\n        successRate: extraction.errors.length === 0 ? 1.0 : 0.9,\n      },\n      createdAt: now,\n      status: 'draft',\n    }\n\n    return NextResponse.json(claimData)\n  } catch (error) {\n    console.error('Process claim error:', error)\n    return NextResponse.json(\n      { error: 'Claim processing failed', details: String(error) },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAOO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,eAAe,EAAE,GAAG;QAE5B,IAAI,CAAC,iBAAiB;YACpB,OAAO,wLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,QAAQ,IAAA,uLAAoB,EAAC;QACnC,IAAI,CAAC,OAAO;YACV,OAAO,wLAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkB,GAC3B;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;QAC5C,MAAM,QAAQ,sCAA+B,0BAAW;QAExD,MAAM,aAAa,MAAM,IAAI,QAoB1B,CAAC,SAAS;YACX,MAAM,OAAO,IAAA,4HAAK,EAAC,OAAO;gBAAC;gBAAY;aAAgB,EAAE;gBACvD,KAAK,QAAQ,GAAG;gBAChB,KAAK;oBAAE,GAAG,QAAQ,GAAG;gBAAC;YACxB;YACA,IAAI,SAAS;YACb,IAAI,SAAS;YACb,KAAK,MAAM,EAAE,GAAG,QAAQ,CAAC;gBAAQ,UAAU,EAAE,QAAQ;YAAG;YACxD,KAAK,MAAM,EAAE,GAAG,QAAQ,CAAC;gBAAQ,UAAU,EAAE,QAAQ;YAAG;YACxD,KAAK,EAAE,CAAC,SAAS,CAAC;gBAChB,IAAI;oBACF,MAAM,SAAS,KAAK,KAAK,CAAC,OAAO,IAAI;oBACrC,IAAI,OAAO,KAAK,EAAE;wBAChB,OAAO,IAAI,MAAM,OAAO,KAAK;oBAC/B,OAAO;wBACL,QAAQ;oBACV;gBACF,EAAE,OAAM;oBACN,OAAO,IAAI,MAAM,UAAU,UAAU,CAAC,wBAAwB,EAAE,MAAM;gBACxE;YACF;YACA,KAAK,EAAE,CAAC,SAAS,CAAC,MAAQ,OAAO;QACnC;QAEA,MAAM,SAAS,WAAW,eAAe,IAAI,CAAC;QAC9C,MAAM,YAAY,CAAC;YACjB,IAAI,CAAC,OAAO,OAAO;YACnB,MAAM,CAAC,MAAM,OAAO,GAAG,MAAM,KAAK,CAAC;YACnC,OAAO,GAAG,KAAK,KAAK,CAAC,GAAG,GAAG,IAAI,EAAE,QAAQ;QAC3C;QACA,MAAM,YAAY,CAAC;YACjB,IAAI,CAAC,OAAO,OAAO;YACnB,OAAO,MAAM,OAAO,CAAC,gBAAgB;QACvC;QAEA,MAAM,MAAM,IAAI,OAAO,WAAW;QAClC,MAAM,aAAa;YACjB,IAAI,CAAC,MAAM,EAAE,KAAK,GAAG,IAAI;YACzB,cAAc,AAAC,OAAO,YAAY,GAC9B,CAAC,GAAG,EAAE,OAAO,OAAO,YAAY,EAAE,KAAK,CAAC,CAAC,IAAI,GAC7C;YACJ,cAAc,AAAC,OAAO,YAAY,IAAe;YACjD,cAAc,UAAU,AAAC,OAAO,YAAY,IAAe;YAC3D,cAAc,UAAU,AAAC,OAAO,YAAY,IAAe;YAC3D,UACE,AAAC,OAAO,QAAQ,IAAe,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE;YAClD,UAAU,AAAC,OAAO,QAAQ,IAAe;YACzC,cAAc,AAAC,OAAO,YAAY,IAAe;YACjD,aAAa,AAAC,OAAO,WAAW,IAAe;YAC/C,iBAAiB,AAAC,OAAO,eAAe,IAAgB,OAAO,eAAe,IAAe;YAC7F,aAAa,OAAO,WAAW;YAC/B,iBAAiB,OAAO,eAAe;YACvC,aAAa,MAAM,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,IAAM,CAAC;oBAC5C,IAAI,CAAC,IAAI,EAAE,GAAG;oBACd,MAAM,EAAE,IAAI;oBACZ,MAAM,WAAW,SAAS,CAAC,EAAE,EAAE,QAAQ;oBACvC,UAAU,EAAE,QAAQ;oBACpB,YAAY,WAAW,SAAS,CAAC,EAAE,EAAE,cAAc;gBACrD,CAAC;YACD,eAAe,CAAC,CAAC,OAAO,YAAY;YACpC,YAAY,OAAO,YAAY,GAAG,MAAM;YACxC,WAAW;YACX,QAAQ;YACR,YAAY,OAAO,MAAM,CAAC,QAAQ,MAAM,CAAC,CAAC,IAAM,KAAK,QAAQ,MAAM,IAAI,MAAM,GAAG;QAClF;QAEA,MAAM,kBAAkB;YACtB;gBACE,UAAU;gBACV,OAAO;gBACP,SAAS;gBACT,OAAO;gBACP,WAAW;YACb;SACD;QAED,MAAM,YAAY;YAChB,SAAS,CAAC,IAAI,EAAE,KAAK,GAAG,IAAI;YAC5B;YACA,cAAc;gBACZ,IAAI,CAAC,GAAG,EAAE,KAAK,GAAG,IAAI;gBACtB;gBACA,UAAU,WAAW,QAAQ;gBAC7B,WAAW,WAAW,SAAS,CAAC,GAAG,CAAC,CAAC,IAAM,CAAC;wBAC1C,GAAG,CAAC;wBACJ,UAAU,CAAC;oBACb,CAAC;gBACD;gBACA,OAAO;oBACL;wBACE,MAAM;wBACN,WAAW;wBACX,UAAU;wBACV,OAAO;wBACP,QAAQ;wBACR,SAAS;4BACP,oBAAoB,WAAW,SAAS,CAAC,MAAM;4BAC/C,QAAQ,WAAW,MAAM;wBAC3B;oBACF;iBACD;gBACD,iBAAiB;oBACf,aAAa;oBACb,sBAAsB,WAAW,QAAQ,CAAC,MAAM;oBAChD,qBAAqB,KAAK,GAAG,CAAC,GAAG,IAAI,WAAW,QAAQ,CAAC,MAAM;oBAC/D,eAAe;gBACjB;gBACA,kBAAkB;oBAChB,gBAAgB,WAAW,SAAS,CAAC,MAAM;oBAC3C,eAAe,WAAW,SAAS,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI;oBACrD,uBAAuB;oBACvB,kBAAkB,EAAE;gBACtB;gBACA,kBAAkB;oBAChB,cAAc;oBACd,mBAAmB,CAAC,CAAC,OAAO,YAAY;oBACxC,oBAAoB;oBACpB,oBAAoB;wBAAC;qBAAqB;gBAC5C;gBACA,mBAAmB;oBACjB,WAAW;oBACX,gBAAgB;oBAChB,iBAAiB,WAAW,MAAM,CAAC,MAAM;oBACzC,iBAAiB;gBACnB;gBACA,WAAW;YACb;YACA,YAAY;gBACV;oBACE,MAAM;oBACN,WAAW;oBACX,UAAU;oBACV,OAAO;oBACP,QAAQ;oBACR,SAAS;wBAAE,mBAAmB;wBAAU,OAAO;oBAAS;gBAC1D;aACD;YACD,mBAAmB;gBACjB,qBAAqB;gBACrB,mBAAmB;gBACnB,qBAAqB,WAAW,QAAQ,CAAC,MAAM;gBAC/C,cAAc;gBACd,YAAY;gBACZ,gBAAgB;gBAChB,aAAa,WAAW,MAAM,CAAC,MAAM;gBACrC,aAAa,WAAW,MAAM,CAAC,MAAM,KAAK,IAAI,MAAM;YACtD;YACA,WAAW;YACX,QAAQ;QACV;QAEA,OAAO,wLAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,wLAAY,CAAC,IAAI,CACtB;YAAE,OAAO;YAA2B,SAAS,OAAO;QAAO,GAC3D;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}