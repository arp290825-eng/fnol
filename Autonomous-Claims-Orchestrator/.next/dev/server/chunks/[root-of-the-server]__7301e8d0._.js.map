{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/services/ingested-claims/index.ts"],"sourcesContent":["/**\n * Ingested Claims Microservice\n *\n * Manages FNOL claims ingested from email (IMAP, SendGrid, demo).\n * Provides CRUD, policy extraction, deduplication, and attachment handling.\n */\n\nimport fs from 'fs'\nimport path from 'path'\nimport type { IngestedClaim, IngestedAttachment } from './types'\n\nconst DATA_DIR = path.join(process.cwd(), 'data')\nconst INGESTED_DIR = path.join(DATA_DIR, 'ingested-attachments')\nconst CLAIMS_FILE = path.join(DATA_DIR, 'ingested-claims.json')\n\nfunction ensureDataDir(): void {\n  if (!fs.existsSync(DATA_DIR)) {\n    fs.mkdirSync(DATA_DIR, { recursive: true })\n  }\n  if (!fs.existsSync(INGESTED_DIR)) {\n    fs.mkdirSync(INGESTED_DIR, { recursive: true })\n  }\n}\n\nfunction getClaimsData(): IngestedClaim[] {\n  ensureDataDir()\n  if (!fs.existsSync(CLAIMS_FILE)) return []\n  try {\n    return JSON.parse(fs.readFileSync(CLAIMS_FILE, 'utf-8'))\n  } catch {\n    return []\n  }\n}\n\nfunction saveClaimsData(claims: IngestedClaim[]): void {\n  ensureDataDir()\n  fs.writeFileSync(CLAIMS_FILE, JSON.stringify(claims, null, 2), 'utf-8')\n}\n\nfunction normalizeDedupKey(s: string): string {\n  return s.trim().toLowerCase()\n}\n\nfunction normalizedSubjectFrom(subject: string, from: string): string {\n  return normalizeDedupKey(`${subject}|${from}`)\n}\n\nfunction fallbackPolicyDisplay(messageId: string | undefined, claimId: string): string {\n  if (!messageId) return claimId\n  if (messageId.includes('<') && messageId.includes('@')) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    return inner || claimId\n  }\n  return claimId\n}\n\nfunction seedDemoClaims(): void {\n  const scenariosDir = path.join(process.cwd(), 'demo-data', 'scenarios')\n  if (!fs.existsSync(scenariosDir)) return\n\n  const scenarios = [\n    {\n      folder: 'auto-collision',\n      policyNumber: 'AC789456123',\n      from: 'sarah.johnson@email.com',\n      to: 'pranay.nath@aimill.in',\n      subject: 'Car Accident Claim - Policy #AC789456123',\n    },\n    {\n      folder: 'commercial-liability',\n      policyNumber: 'CL789012345',\n      from: 'antonio.martinez@tonysrestaurant.com',\n      to: 'pranay.nath@aimill.in',\n      subject: 'Commercial Liability Claim - Slip and Fall - Policy #CL789012345',\n    },\n    {\n      folder: 'property-water-damage',\n      policyNumber: 'HO456789234',\n      from: 'robert.chen@email.com',\n      to: 'pranay.nath@aimill.in',\n      subject: 'Urgent - Water Damage Claim - Policy #HO456789234',\n    },\n  ]\n\n  const claims: IngestedClaim[] = []\n  const baseTime = Date.now() - 86400000 * 2\n\n  for (let i = 0; i < scenarios.length; i++) {\n    const s = scenarios[i]\n    const emailPath = path.join(scenariosDir, s.folder, 'email.txt')\n    const attachmentsDir = path.join(scenariosDir, s.folder, 'attachments')\n    if (!fs.existsSync(emailPath)) continue\n\n    const emailBody = fs.readFileSync(emailPath, 'utf-8')\n    const claimId = `DEMO-${s.policyNumber}-${i}`\n    const claimDir = path.join(INGESTED_DIR, claimId)\n    fs.mkdirSync(claimDir, { recursive: true })\n\n    const attachments: IngestedAttachment[] = []\n    if (fs.existsSync(attachmentsDir)) {\n      for (const file of fs.readdirSync(attachmentsDir)) {\n        const srcPath = path.join(attachmentsDir, file)\n        if (fs.statSync(srcPath).isFile()) {\n          const destPath = path.join(claimDir, file)\n          fs.copyFileSync(srcPath, destPath)\n          attachments.push({\n            name: file,\n            path: destPath,\n            size: fs.statSync(destPath).size,\n            mimeType: 'text/plain',\n          })\n        }\n      }\n    }\n\n    claims.push({\n      id: claimId,\n      policyNumber: s.policyNumber,\n      from: s.from,\n      to: s.to,\n      subject: s.subject,\n      emailBody,\n      attachments,\n      createdAt: new Date(baseTime + i * 3600000).toISOString(),\n      source: 'demo',\n    })\n  }\n\n  if (claims.length > 0) saveClaimsData(claims)\n}\n\nexport { type IngestedClaim, type IngestedAttachment }\n\n/** Extract policy number from email body using common patterns */\nexport function extractPolicyNumber(emailBody: string): string | null {\n  const patterns = [\n    /policy\\s*#?\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /policy\\s*number\\s*:?\\s*([A-Z0-9]{6,})/i,\n    /Policy\\s*#([A-Z0-9]+)/i,\n    /#([A-Z]{2}\\d{6,})/,\n    /\\b([A-Z]{2}\\d{6,})\\b/,\n  ]\n  for (const pattern of patterns) {\n    const match = emailBody.match(pattern)\n    if (match?.[1]) return match[1]\n  }\n  return null\n}\n\n/** Get existing message IDs for deduplication */\nexport function getExistingMessageIds(): Set<string> {\n  const claims = getClaimsData()\n  const ids = new Set<string>()\n  for (const c of claims) {\n    ids.add(normalizedSubjectFrom(c.subject, c.from))\n    if (c.messageId) {\n      ids.add(normalizeDedupKey(c.messageId))\n      const inner = c.messageId.replace(/^<|>$/g, '').trim()\n      if (inner) ids.add(normalizeDedupKey(inner))\n    }\n  }\n  return ids\n}\n\n/** Add dedup keys for a newly ingested claim */\nexport function addDedupKeysToSet(\n  ids: Set<string>,\n  subject: string,\n  from: string,\n  messageId: string,\n  dedupKey: string\n): void {\n  ids.add(normalizedSubjectFrom(subject, from))\n  ids.add(normalizeDedupKey(dedupKey))\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner) ids.add(normalizeDedupKey(inner))\n  }\n}\n\n/** Check if email is a duplicate */\nexport function isDuplicateEmail(\n  subject: string,\n  from: string,\n  messageId: string,\n  dateHeader: string,\n  existingIds: Set<string>\n): boolean {\n  if (existingIds.has(normalizedSubjectFrom(subject, from))) return true\n  const dedupKey = messageId\n    ? normalizeDedupKey(messageId)\n    : normalizeDedupKey(`${subject}|${from}|${dateHeader}`)\n  if (existingIds.has(dedupKey)) return true\n  if (messageId) {\n    const inner = messageId.replace(/^<|>$/g, '').trim()\n    if (inner && existingIds.has(normalizeDedupKey(inner))) return true\n  }\n  return false\n}\n\n/** Save an ingested claim */\nexport function saveIngestedClaim(\n  from: string,\n  to: string,\n  subject: string,\n  emailBody: string,\n  attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }>,\n  source: 'sendgrid' | 'imap' = 'sendgrid',\n  messageId?: string,\n  emailMessageIdForDisplay?: string\n): IngestedClaim {\n  const claimId = `ING-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`\n  const extracted = extractPolicyNumber(emailBody) || extractPolicyNumber(subject)\n  const policyNumber =\n    extracted ?? fallbackPolicyDisplay(emailMessageIdForDisplay ?? messageId, claimId)\n\n  ensureDataDir()\n  const claimDir = path.join(INGESTED_DIR, claimId)\n  fs.mkdirSync(claimDir, { recursive: true })\n\n  const attachments: IngestedAttachment[] = []\n  for (const file of attachmentFiles) {\n    const safeName = file.name.replace(/[^a-zA-Z0-9._-]/g, '_')\n    const filePath = path.join(claimDir, safeName)\n    fs.writeFileSync(filePath, file.buffer)\n    attachments.push({\n      name: file.name,\n      path: filePath,\n      size: file.buffer.length,\n      mimeType: file.mimeType || 'application/octet-stream',\n    })\n  }\n\n  const claim: IngestedClaim = {\n    id: claimId,\n    policyNumber,\n    from,\n    to,\n    subject,\n    emailBody,\n    attachments,\n    createdAt: new Date().toISOString(),\n    source,\n  }\n  if (messageId) claim.messageId = messageId\n\n  const claims = getClaimsData()\n  claims.unshift(claim)\n  saveClaimsData(claims)\n  return claim\n}\n\n/** Get all ingested claims */\nexport function getAllIngestedClaims(): IngestedClaim[] {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  return hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n}\n\n/** Get a single claim by ID */\nexport function getIngestedClaimById(id: string): IngestedClaim | null {\n  const claims = getClaimsData()\n  return claims.find((c) => c.id === id) ?? null\n}\n\n/** Get policy numbers for dropdown */\nexport function getPolicyNumbers(): Array<{ id: string; policyNumber: string; subject: string }> {\n  let claims = getClaimsData()\n  if (claims.length === 0) {\n    seedDemoClaims()\n    claims = getClaimsData()\n  }\n  const hasRealClaims = claims.some((c) => c.source === 'imap' || c.source === 'sendgrid')\n  const toShow = hasRealClaims ? claims.filter((c) => c.source !== 'demo') : claims\n  return toShow.map((c) => ({ id: c.id, policyNumber: c.policyNumber, subject: c.subject }))\n}\n\n/** Clear all ingested claims */\nexport function clearAllIngestedClaims(): void {\n  ensureDataDir()\n  if (fs.existsSync(CLAIMS_FILE)) fs.unlinkSync(CLAIMS_FILE)\n  if (fs.existsSync(INGESTED_DIR)) {\n    for (const entry of fs.readdirSync(INGESTED_DIR, { withFileTypes: true })) {\n      const fullPath = path.join(INGESTED_DIR, entry.name)\n      if (entry.isDirectory()) fs.rmSync(fullPath, { recursive: true })\n    }\n  }\n}\n\n/** Read attachment content for processing */\nexport function readAttachmentContent(claimId: string, attachmentName: string): string {\n  const claim = getIngestedClaimById(claimId)\n  if (!claim) throw new Error('Claim not found')\n  const att = claim.attachments.find((a) => a.name === attachmentName)\n  if (!att || !fs.existsSync(att.path)) throw new Error('Attachment not found')\n  const ext = path.extname(att.name).toLowerCase()\n  if (['.txt', '.csv', '.log'].includes(ext)) {\n    return fs.readFileSync(att.path, 'utf-8')\n  }\n  return `[Document: ${att.name} - content extracted for processing]`\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/services/email-ingestion/index.ts"],"sourcesContent":["/**\n * Email Ingestion Microservice\n *\n * Fetches emails from IMAP (Gmail/Outlook), classifies via LLM (FNOL vs non-FNOL),\n * ingests only FNOL-related content. Uses Node.js imapflow - no Python required.\n */\n\nimport { ImapFlow } from 'imapflow'\n// @ts-expect-error - mailparser has no types\nimport { simpleParser } from 'mailparser'\nimport OpenAI from 'openai'\nimport {\n  saveIngestedClaim,\n  getExistingMessageIds,\n  isDuplicateEmail,\n  addDedupKeysToSet,\n} from '@/services/ingested-claims'\nimport type { SyncResult } from './types'\n\nconst IMAP_HOST = process.env.IMAP_HOST || 'imap.gmail.com'\nconst IMAP_PORT = parseInt(process.env.IMAP_PORT || '993', 10)\nconst IMAP_USER = process.env.SENDER_EMAIL || process.env.IMAP_USER || ''\nconst IMAP_PASSWORD = (process.env.EMAIL_PASSWORD || process.env.IMAP_PASSWORD || '').replace(/\\s/g, '')\nconst IMAP_MAILBOX = process.env.IMAP_MAILBOX || 'INBOX'\nconst INCLUDE_READ = process.env.IMAP_SYNC_INCLUDE_READ !== 'false'\nconst MAX_EMAILS = parseInt(process.env.IMAP_SYNC_MAX_EMAILS || '100', 10)\nconst FNOL_FILTER_ENABLED = process.env.FNOL_FILTER_ENABLED !== 'false'\n\nasync function classifyFnolByLLM(subject: string, body: string): Promise<boolean> {\n  if (!FNOL_FILTER_ENABLED) return true\n  const apiKey = process.env.OPENAI_API_KEY\n  if (!apiKey) return true\n\n  try {\n    const openai = new OpenAI({ apiKey })\n    const model = process.env.OPENAI_MODEL || 'gpt-4o-mini'\n    const text = `Subject: ${subject}\\n\\nBody:\\n${body.slice(0, 3000)}`\n\n    const response = await openai.chat.completions.create({\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: `You are an FNOL classifier. Determine if this email is a First Notice of Loss (FNOL) or insurance claim submission.\nFNOL = an insured person notifying their insurer of a loss, incident, or damage to file a claim (e.g. accident, water damage, theft, fire, collision, bodily injury, property damage).\nReply with ONLY \"yes\" or \"no\".`,\n        },\n        {\n          role: 'user',\n          content: `Is this email an FNOL or insurance claim submission?\\n\\n${text}`,\n        },\n      ],\n      max_tokens: 10,\n      temperature: 0,\n    })\n\n    const answer = (response.choices[0]?.message?.content || '').trim().toLowerCase()\n    return answer.startsWith('yes')\n  } catch (err) {\n    console.error('FNOL classifier error:', err)\n    return true\n  }\n}\n\nfunction formatAddress(addr: unknown): string {\n  if (!addr) return ''\n  const arr = Array.isArray(addr) ? addr : [addr]\n  return arr\n    .map((a: { text?: string; address?: string; value?: { 0?: { address?: string } } }) =>\n      a?.text || (a as { address?: string })?.address || (a as { value?: { 0?: { address?: string } } })?.value?.[0]?.address\n    )\n    .filter(Boolean)\n    .join(', ')\n}\n\nfunction formatDate(d: Date | string): string {\n  const date = d instanceof Date ? d : new Date(d)\n  if (isNaN(date.getTime())) return ''\n  return date.toLocaleString('en-US', {\n    month: 'long' as const,\n    day: 'numeric',\n    year: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: true,\n  })\n}\n\nfunction buildFullEmailBody(opts: {\n  subject: string\n  from: string\n  to: string\n  dateStr: string\n  bodyText: string\n}): string {\n  const lines: string[] = []\n  if (opts.subject) lines.push(`Subject: ${opts.subject}`)\n  if (opts.from) lines.push(`From: ${opts.from}`)\n  if (opts.to) lines.push(`To: ${opts.to}`)\n  if (opts.dateStr) lines.push(`Date: ${opts.dateStr}`)\n  if (lines.length) lines.push('')\n  if (opts.bodyText) lines.push(opts.bodyText.trim())\n  return lines.join('\\n')\n}\n\nfunction stripHtml(html: string): string {\n  return html\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<[^>]+>/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim()\n}\n\n/** Sync inbox from IMAP and ingest FNOL emails */\nexport async function syncInbox(): Promise<SyncResult> {\n  const result: SyncResult = {\n    success: false,\n    ingested: 0,\n    scanned: 0,\n    skippedNoFnol: 0,\n    skippedDuplicate: 0,\n    errors: [],\n  }\n\n  if (!IMAP_USER || !IMAP_PASSWORD) {\n    result.errors.push('IMAP credentials not configured. Set SENDER_EMAIL and EMAIL_PASSWORD in .env')\n    return result\n  }\n\n  const client = new ImapFlow({\n    host: IMAP_HOST,\n    port: IMAP_PORT,\n    secure: true,\n    auth: { user: IMAP_USER, pass: IMAP_PASSWORD },\n    logger: false,\n  })\n\n  const mailboxesToTry: string[] = [IMAP_MAILBOX]\n  if (IMAP_HOST.toLowerCase().includes('gmail') && IMAP_MAILBOX.toUpperCase() === 'INBOX') {\n    if (INCLUDE_READ) {\n      mailboxesToTry.unshift('[Gmail]/All Mail', '[Google Mail]/All Mail')\n    } else {\n      mailboxesToTry.push('[Gmail]/All Mail', '[Google Mail]/All Mail')\n    }\n  }\n\n  try {\n    await client.connect()\n\n    let uids: number[] = []\n    let mailboxUsed = ''\n\n    for (const mbox of mailboxesToTry) {\n      try {\n        const lock = await client.getMailboxLock(mbox)\n        try {\n          const searchCriteria = INCLUDE_READ ? { all: true } : { seen: false }\n          const searchResult = await client.search(searchCriteria, { uid: true })\n          let list = Array.isArray(searchResult) ? searchResult : []\n          list = list.slice(-MAX_EMAILS)\n          if (list.length > 0) {\n            uids = list\n            mailboxUsed = mbox\n            break\n          }\n        } finally {\n          lock.release()\n        }\n      } catch {\n        continue\n      }\n    }\n\n    if (uids.length === 0) {\n      result.success = true\n      result.hint =\n        \"Inbox empty. For Gmail: enable 'All Mail' in Settings > Labels > Show in IMAP, or set IMAP_MAILBOX='[Gmail]/All Mail' in .env\"\n      await client.logout()\n      return result\n    }\n\n    result.scanned = uids.length\n    result.mailboxUsed = mailboxUsed\n    const existingIds = getExistingMessageIds()\n    const lock = await client.getMailboxLock(mailboxUsed || IMAP_MAILBOX)\n\n    try {\n      const messages = await client.fetch(\n        uids,\n        { envelope: true, source: true, uid: true },\n        { uid: true }\n      )\n\n      for await (const msg of messages) {\n        try {\n          const rawSource = msg.source\n          if (!rawSource) {\n            result.errors.push(`Message ${msg.uid}: No source data`)\n            continue\n          }\n\n          const rawBuffer = Buffer.isBuffer(rawSource) ? rawSource : Buffer.from(rawSource as Buffer)\n          const parsed = await simpleParser(rawBuffer)\n\n          const subject = parsed.subject || '(No subject)'\n          const from = formatAddress(parsed.from) || ''\n          const to = formatAddress(parsed.to) || ''\n          const messageId = parsed.messageId || ''\n          const dateHeader = parsed.date ? String(parsed.date) : ''\n          const dedupKey = messageId || `${subject}|${from}|${dateHeader}`\n\n          if (isDuplicateEmail(subject, from, messageId, dateHeader, existingIds)) {\n            result.skippedDuplicate = (result.skippedDuplicate ?? 0) + 1\n            continue\n          }\n\n          const bodyText = parsed.text || (parsed.html ? stripHtml(parsed.html) : '')\n          const isFnol = await classifyFnolByLLM(subject, bodyText)\n          if (!isFnol) {\n            result.skippedNoFnol++\n            continue\n          }\n\n          const dateStr = parsed.date ? formatDate(parsed.date) : ''\n          const emailBody = buildFullEmailBody({ subject, from, to, dateStr, bodyText })\n\n          const attachmentFiles: Array<{ name: string; buffer: Buffer; mimeType: string }> = []\n          if (parsed.attachments?.length) {\n            for (const att of parsed.attachments) {\n              const content = att.content\n              const buffer = Buffer.isBuffer(content) ? content : Buffer.from(content || [])\n              const filename = att.filename || `attachment-${attachmentFiles.length + 1}`\n              const mimeType = att.contentType || 'application/octet-stream'\n              attachmentFiles.push({ name: filename, buffer, mimeType })\n            }\n          }\n\n          saveIngestedClaim(\n            from,\n            to,\n            subject,\n            emailBody,\n            attachmentFiles,\n            'imap',\n            dedupKey,\n            messageId || undefined\n          )\n          result.ingested++\n          addDedupKeysToSet(existingIds, subject, from, messageId, dedupKey)\n\n          if (!INCLUDE_READ) {\n            await client.messageFlagsAdd(msg.uid, ['\\\\Seen'], { uid: true })\n          }\n        } catch (err) {\n          result.errors.push(\n            `Failed to process message ${msg.uid}: ${err instanceof Error ? err.message : String(err)}`\n          )\n        }\n      }\n\n      result.success = result.errors.length === 0\n    } finally {\n      lock.release()\n    }\n\n    await client.logout()\n  } catch (err) {\n    result.errors.push(err instanceof Error ? err.message : String(err))\n    try {\n      await client.logout()\n    } catch {\n      // ignore\n    }\n  }\n\n  return result\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 675, "column": 0}, "map": {"version":3,"sources":["file:///Users/pranaynath/Documents/GitHub/fnol/Autonomous-Claims-Orchestrator/app/api/sync-inbox/route.ts"],"sourcesContent":["/**\n * POST /api/sync-inbox\n * Delegates to Email Ingestion microservice.\n */\nimport { NextResponse } from 'next/server'\nimport { syncInbox } from '@/services/email-ingestion'\n\nexport async function POST() {\n  try {\n    const result = await syncInbox()\n\n    return NextResponse.json({\n      success: result.success,\n      ingested: result.ingested,\n      scanned: result.scanned,\n      skippedNoFnol: result.skippedNoFnol,\n      skippedDuplicate: result.skippedDuplicate ?? 0,\n      errors: result.errors,\n      hint: result.hint,\n    })\n  } catch (error) {\n    console.error('Sync inbox error:', error)\n    return NextResponse.json(\n      { success: false, ingested: 0, scanned: 0, skippedNoFnol: 0, skippedDuplicate: 0, errors: [String(error)] },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GACD;AACA;;;AAEO,eAAe;IACpB,IAAI;QACF,MAAM,SAAS,MAAM,IAAA,8LAAS;QAE9B,OAAO,wLAAY,CAAC,IAAI,CAAC;YACvB,SAAS,OAAO,OAAO;YACvB,UAAU,OAAO,QAAQ;YACzB,SAAS,OAAO,OAAO;YACvB,eAAe,OAAO,aAAa;YACnC,kBAAkB,OAAO,gBAAgB,IAAI;YAC7C,QAAQ,OAAO,MAAM;YACrB,MAAM,OAAO,IAAI;QACnB;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,wLAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,UAAU;YAAG,SAAS;YAAG,eAAe;YAAG,kBAAkB;YAAG,QAAQ;gBAAC,OAAO;aAAO;QAAC,GAC1G;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}